(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports=[
    "12RPuTzifQJLmbvLLPde16XBe7VZT3c1BDfBBZLm9CSY",
    "12RVQuCZdabGqY6t6fEUZF7hMnkzx3hKh2HgH3sUKaY9",
    "12VWkFnzi1GMS3J7eTkNBL1hobLAut8mU5Bk6AMfSiVf",
    "12iHVRuND5Cz7YRXp4e4A72UzWCFhegh7gFeEk3f4oFA",
    "135BGxmZpXEi45npnvjPF6CwL2gLiCs45ezrwcKYhJdK",
    "13MmvBZqZAhcPtQSd6WqcrXPXnPwG17erjwFvA8kutLJ",
    "13NRdBKwR3771dnyXACxs5TQgQwCx6kpyY68PT6VmjQJ",
    "13TSCGL4H7qLXPgJrSWMbrdHv77tHZUAJVXMMFhnnMKh",
    "13qu3VK6KA55313CJ65YHd2zQ4Ed2d3Bg4pHheA2UtkT",
    "14MNiVtwXsSSJXq7db6veUJCCRXacYnguLabpt8mPYdB",
    "16cAZCqLSMqwj65cdxybDnjXsRUgKoVyne5MyW2oMdv",
    "1MKGbEsnppKEVm2k6MZSU48mMTwCf1iVRx92RF9wSEX",
    "1asmf7LmsEs3DK9nXJXCWvGtarqdVQuvWyPZD8is1hN",
    "1hduUFi6wAxvsXd3xcPseDTAQH1Xs3i1jJE5yYNXcxB",
    "215BrT44bx4tLDTF1mp6vuqHE31XN1h3orE3f9w3Prhn",
    "2166psJKcbg5uQYL4s6eBtVoQW19vuBWuDMC4YjLnZcj",
    "21N9KV3SowKSuQj6wB7pgMuBXznsZrLcMeopW887jkwc",
    "21NyLKupixBS6pZkQRZwkJQGhCsXZZQjaE3PxQWxqnsw",
    "21zKfZ1c59UZ7TpiSykVdBGqSk1HY6zAf26Byz3QfNui",
    "22fwbxpvMmRayzJH5Mzu2GkWYzdvbk3gMsJa5dKi6zcn",
    "22gW8tm1rAS5Xsz4ZzqpZog7JqFRgPbFnNgfTDrkEFWk",
    "22sRwzVJap3T2gf9K8ffZ5a4wAp2SBkrVRgjo45cUPhD",
    "23aAAjc4ZxAzu2kzxYD2UJ91G86djj4EnuWqQx7ghEyY",
    "24H2RwRkoy2mjTkQYHBWbCdVqTGUgdbwGBDXj4scEsFw",
    "24VEupDJY7FF5wrrmJxbKTps3c5g2ppnyY8meqM7RLs2",
    "24eRYJnHhvVCzKiKxCLUobBAYo3EuqqiGHpMB9sSFQ3U",
    "25J2LTCZx5Q8qM6KhPy99L8nDqLHSVguPp7UA8Rmvtpj",
    "25bRXVJoKnHWtFuKpg6x1cH1QhDUizoSzoCM2EfES6hv",
    "26A84M2aBex1fr71imnNF1Gd1cb2bnrJrM7zoePJFW7Y",
    "26YLVaJXQVynHpUGr2BACLwHWYL1z4zv7742hgHknRtC",
    "271jCKjq3ZgEuHJ6tCvGuE6ro4XmvLc4ozEjnt2QP8eH",
    "27ECrupBMGZXFwQUjbRhduPcDYGvpK57JPKnjbvqKQd5",
    "27Sb6i7wW4N27toKEZWPWiQgUcZH3b8DAnsg9L1L6Lqu",
    "27TZigMhqD6CHx3FfyZWhNE7mUU6hDt6QvS8zCzQNtB4",
    "27pewLAHbKKKWHJ7eR5VTqat5ptE67FvSLWBxMkvHE7q",
    "283daQnPDbeGzjGFeBomBVLXyMiPVuCeLC9urJCdTYDq",
    "28bjEWZv4yJoUy2hkAWgVsBCTWdPbNkSyaXzMtTXs6gg",
    "28kBubwxjzjDkYtAz8UV1S3gNcGbNiknASonXzJwerFj",
    "28kM4CyrUGhwskFD89HXokyByxT3WcYw7tymAy8y7huC",
    "29EqmLAaTtR14jnwYPcs4dfSmWbv4VrykAai9NsgwkmB",
    "29GW5jAxzoizsCEwMLbPkfULmx5GZViQjvvHdyB1WvBg",
    "29J11tAMLJLqQC48R86VB2e82YpQmZEavbgbwh1z8RdT",
    "29XDcgJgBDC4YTZxzcogQigPA7ZKSRQqg7YS7pV8ufVH",
    "29kYSD6DFDy9fCQiBisQEg4gDkqC3Kzh2ujLYPXDXWdF",
    "2A2VxWtRJGkQoQbBGKR1aaEqLBnZTH9sQSK62x3uKELc",
    "2AuNc1WqNoH8UDFKhF5oeFXnMgWniQiUyMD6Y84GJh7x",
    "2B76zGyHm1BCo9ZkZMKf22UvtvQ7oKQFZDRhXXj4XW95",
    "2BEXGzmD54EFfoi98Gw27VVjA2HwrAj1RYydB1a7no2x",
    "2BixL4zuqXzL22Q7H5ADx2MQ9RhSk1whMSxEDaBorLFb",
    "2Brf2yzdVVNFfxp5R5pj7GmyiadiW7icLZN3UWcvpbeE",
    "2C7MDXPNJ17GbWxnFu2M5uGWV2DcqJDbTmimxpbPa2Ga",
    "2C7PdLb6Xcy7ZJLQbCXaYAiPCH1Szvovq2sNRXkmA6RH",
    "2CgrH79WoJWDE8xfEz8KnqXeegTtfZnaz6g8Co12WmtA",
    "2D35bJzcx2n8HzLgsTyFtP3f7iLJ4M5CQxMUEQDgxrLY",
    "2Dt7aLgu6oi37qX9bdRUTuNAZiw8TGHaJkNgNg9ATN3R",
    "2EGLR6t9hP5bQ3ZcsJyg4PYGs23kZXBjKwHwLPZYxYpq",
    "2ET5oYSNrcXCSEDKPe4FSExusHLowRVfMHyUEBJBUtAt",
    "2EZbCSeK2Z83LCMsNs3eSfvw2WJMt195FLb2k6QcCjSB",
    "2Exr5n6y3gUvu5cZXfVFmLeWJk3SWQycCSR9xQNdgDdK",
    "2FFmjwApLqm6upc5LCnX9oJCnmTPJCPQdfnNerVTRWKo",
    "2FYGFeGymsAaGG43vqZzxsTBBtWzPLJG4zaZNfXF6CWZ",
    "2GGLtohYmSi1cX7HbtRqfGHPkbfu6jJpV27GHXPKQm7U",
    "2HSizUnVb33jegGc7grz6Tvpq2gRQNkQtbgXtDtBAaNM",
    "2HWYfjhBTjGjULG4fxaxL4my4Zrp7NYLMnxsLHwFWKoe",
    "2Hy5osS1oFYR4BRDFSyFdoGmqs33GCURybMZbeRfJM71",
    "2J51BQt15e9obZSpDkJU1zSdtmigAJdTu4nYwBxi2gZu",
    "2JZXS2Nyc9y2vgypT1jVoJx3WDTyLdnxFDkaXfoaVDq2",
    "2Jgo7Snfg5nfr8t82bJKVGzmSPkUfXp9UruhK64g4h6y",
    "2KMKhqaPmDMyUa2L5fEAG8NH8PmQ1mWToginB41Tytux",
    "2KbBGWRJj8RwpeLqDfLJZfAZ7Hn6YmjaPP7Q3HttC3J7",
    "2LGs9K6jXx1CVdACccLfvavWGzu4biZ1oiSuJ58pZ7Ag",
    "2LSGD8Uw73gkXGXc9hbqsakRTFe9LKGAzydZTDTpC5vr",
    "2LdDJxrtP81LLyt2UUohP7gWqD4R5STfanDvqZpofJ15",
    "2LgPJED9hS33Lx5YeQrjrFppCNiCjwir6BmtZDywJ9qx",
    "2MNtKjUkdZqP7YBR87os7VHEXQKzCNDqrkuntk22H29X",
    "2NKgayQYXF2FVA4AKBAS7xKarGHHJV4kPyumWXh1ePT8",
    "2P11g11QwncUAgT1xMqtdwJZoAiMSonVq9TM6yc3uVbn",
    "2PaQHvsfAG6rgoQqHEccSJ13BQEykXagGfDP9C4xJawR",
    "2Ph7ppAMySh4w9FungCmaXD4Ry9uYX75sJnMbCWaDHGN",
    "2PusmTXYidvJ1Ck3Keqgje9hz66t4GbLSt6AyJA6RFwu",
    "2Q4PWQ79CRNoUQrojmfwXVKj79PV1RkhWtFThUz2ZErV",
    "2QDtjmMsvNLPFaR7kU7Ptf48cz4aS11BZ2tukQFbUBkF",
    "2QdaksoQwepKDhYh6yFt42M8rMLSQ6zkKJtrVnf2CnNA",
    "2R7FpofSPcsEYk4Mffsn7ob3jCiv7ajxpFLXGbP4r9w8",
    "2RJhe3mFHoNcHTRoEti3nchrtUz4kuMnjzuyg8gZ9sHw",
    "2RLuwj1wNs7tyH7L1vhSR7irJR23zpiDVeJQyVnmUKhQ",
    "2RR24TDtuRsVi8sAkks9N8BV9D3teJ42e5GxE54qoNJj",
    "2RUFXXekcxgp5bvNKYfXntFTVLs3q7haDTRxfiBJ3gfN",
    "2RY3o1FMHW9PNdSLsrLWKFpaurG1ubtEcLCHoeSwxA9B",
    "2RdGxHBk6d4XumJpNejXbcb1qbEdTCz5Ce344bYJKmWy",
    "2SEMn45784JeDmCkqDTf9x1NMMRCT3ZcAsviN5QTafxX",
    "2SKJQNCWuWkdEKn82pjTE16MT212ELsmFUmBQ1f4AhNU",
    "2SLwbporYiSwo6HqfbFUftFPvN9HVxuPWXhK2LVEa28V",
    "2SSoWhwkv2mg4KU4cQYLhsBFQrfi1jgNxMV2tkFGAbG3",
    "2Sbv1Q9u7vKdKCS1y2TFYEu8Tj85GyNZnyvCM1yaUqa2",
    "2SgJBrnMabrEC4SZKEwxz4zqvJg4MvqC1pC9TcmNrYpD",
    "2Sj9c9rvNnc9A3trMCAuH3Cho1VujXrQVTKGHt5NMH8k",
    "2SoZ8jeYqR5yEFE2gFzTP5egiZrRs9XpKvLG7XJ1JijW",
    "2TRZJoCryq42GaxHqnUhVef5krgibqTcVtDcKK1VAZ3q",
    "2TZCxPTNcxXy1WioGAKN9KUDAn83cV8TpbRdxCLFo1HC",
    "2TuPPxCpU91JHZ34nuoEXeRJiUELyycWLZN68ZnGkpuB",
    "2UBzCgfJHJ4kG5yVbLfQFzfQfR8bnLg99s91acen6WS9",
    "2UcugasMYjRjWijmcJxpwugBYSR8wSSWvySKgiS4utM7",
    "2UjDxscfPkcic11o9aTD1wYpmaww35Ls9ZEHukxTwdXB",
    "2VUdRnh4Hp7EVxZrTHhTSJYJPuoA2Eky8KxFNA5BmcdA",
    "2WQkWERr2ZfK9oLvZUc6Tbgwr9TeJakV7cDXckTHUv1N",
    "2WSkLXAzLftJrEuPv4cML5VsxA2y24zRyvJS2ytyCEJa",
    "2WXmWqZGNBRvEHWUDdtiR86V8Snz5kC3g6zJsFXmennu",
    "2Wm1U5PiGQz2Le5F47p3Gh6yKsJ6pAzkyzhiWZk3NW9K",
    "2XC7GKCasb2ew1kzQHR475cRXKaJFzuaFnLYRPjsuz9R",
    "2XDjvQXUCHfXjVZEmX5SrmvvVHfbjuDxBkCY62xoJgy2",
    "2XJLyGhC6wraNVowHrknBsvEzZc6uJB1Hv1ru5xxThdt",
    "2XP7CPC2VmetmmXyctJSJhtjbw9T2t6DZ3aTJPHfmK6f",
    "2XZKbXs5r2vwu4qaxM1TfahvzsQWHkAChEfNe2gCr9e1",
    "2Xu2fHAmpyCYoYKaX94GaHw2U4QPaCYCPyAEAreZaKBP",
    "2Xxcrb5RoBC8frkY1cdLXV3W7YKpEKhGmJSRXndr8eFR",
    "2XxkVsfkXVK7sRYUBTcUkaxTGrihFJGhZhjaoc9ZW5Fp",
    "2Y8dbrb2o5pM1xXigBSZx7egAdUmkAQsMupbfo2XB5mR",
    "2YA4z44Yof59w7zDzo8sBky1CuCjwZnKA4NLTjhNkdVh",
    "2YQGFeadbSPsrXVySwxkPP3dBfjqTTsuhMeJpabKP1Xp",
    "2ZhXu9kWgA55UCyiauCkCkazcytg6285isC9nnPMfKqR",
    "2ZidHC2JZTS3g6Q4SPULPPqcmGeL42HPg87gPa4q7UWj",
    "2Zo7Cn3HQbW4GRFNh9nnwLvbHus7BTVmriBYTZs93EQG",
    "2a2sP6Nrn9Uoqu4BZriv3NeKm3FhRhEcTPyDyL2yz33R",
    "2a99LKeC3zsgMLxRUL2SXcFfrz92kCrVPZzcXvzRSSVj",
    "2aL4Y1R9kFWXYhM3LKyZDE7FqsKpfzsWrjFVAtBePWSP",
    "2aeJgi4MFJqN6EgTVZ44nGSmpPhxFbUSed4zEYRgsr7w",
    "2bHnQo1rsnhh2JK8eEJZSfwvmDcZAjYq7rfvnG45o8rb",
    "2bkVzniY8oNwTwRV5AgVdTj75FgrYHn6VsiFn1ohKKS2",
    "2boGr9jf22a5wkSUjboRSBp9rm4sA6gnDTG98NrGaHYx",
    "2cL3WRhsnK5Kr767DPkmxjfTxKjmN5hosgpabSNNzFLi",
    "2cbW7Qyudj8chDsPvgiDDB82B3c4T56NZ57mqTyo7vjc",
    "2dydML3CZfMmaBsSENTqAT8GpbUSeLRGtJnDz6aWt7ab",
    "2e8VXvhxwMLbBC3GFkvkuganfm1MDx52firmk4rWZQ9h",
    "2emw17NWk57Gahq1R5UrW8Ya1e2Kuyj7hMa8qChaHfyj",
    "2fFRsuQapAbCQ9DT1qRgsK6wdyCM3KokZYqi8jMiXXNy",
    "2fhFhEPW2p1yhq7ghtqCwPJfBz2VUTU4juQWJcF87JJg",
    "2g3gLLd7X471wfyFRaGmukoCYp43cxFdwb7ptRjJSQys",
    "2gKAig9RqRrZT3ULVdELnoCTDUjpFihwX3DwTX7xdxV9",
    "2gPBBuyrwLD4e6GTph5EGK3L1EYhUhnS6Qd78NBG4FGr",
    "2hfuE2VbMGKKzMP6UT4qkwdvgTVg4trthFbvvzCk7xTj",
    "2huu877YEQg6MSywRvG3snDs5ZKvqmKUmwKPTGLh2kT7",
    "2igBez2XbRDDamb811kKqRs2qABdC1XDUiqU1home8B2",
    "2ioW5EaYyTaK4uZyDaLGvmaRQ141gG12a42m1X6gBsjE",
    "2irJwyWYxwHyVdDgUKyENLG3aAsyLHHXxs7EXYrEERBd",
    "2isA6iSvz1q1bsGytYkrJumHHTxj81L1cqrZdU9sfC6D",
    "2jGwRkRgDN9dHVDNybTJkJoTu18svN8nR5fv2LiVf7F3",
    "2jybj9M7DkPsZYF4uSrCD4D1WbyRFwNXDRAF9RaUhe4w",
    "2kj9apfFsLLbA4MQYF7D6rTv3jiBVJMAzqsrsppAtRWG",
    "2kvtVfR8m5dMhjh5zprAbZDexwTaBCnThP4joswDTMUo",
    "2m8AhFPfmr6KvrZbWYsynuhhPrURpNNEvd6GDdYBkjnP",
    "2mLKnhET9MPdn4cq1ZxWfaqJEwbDmEyVPpJRZgy7NvTn",
    "2mUKZpgnxs79coDVfW9YeRxp3mHceNamCjzzjtKEggGE",
    "2maKBG91TxtrWCag3ssZqY2Ay8MtJvoZBnoGkxakXRy4",
    "2mc7nCpp7TbJcMxoS8FcrGzUZg8tE3eZgC6jb8UyJmit",
    "2mqbC6EBGjxAsVvDHEd3dBKrfnjEx1ALFp6k8MdErEJd",
    "2nfMXEgYpdpxXuPDDfb73eAuJxfFe8nNwEwDh3xHhpbL",
    "2nppCf3oKpRaVrPYvcNdQBTGkZvbro3GAXmEH2CYAPov",
    "2ohREjXNdbvcCYdG1yDC8w7NbJR6GtcikBqZEM4KGycJ",
    "2pLwTCdrjBYn6dJ1Z3PBXfqLbSJ18dMUy2rfmc7HenFH",
    "2phhJ6B64MZCBcA4jLTzP1VMc9dzSAFCsQQs8s4vVX1s",
    "2pmUgD57H1vVTHkzCLrxQqDRWSnb4pAB7U3puARtpqEK",
    "2qBxYrBXsp2CuQek8gyUGSPAsrD5wysWVaviTpP4H3v6",
    "2qEsfHwk7BBU4LP239wk9qX8xxPNQnoTnRutHxTKwusC",
    "2qK1m5bYiR9eVsBGdchM5k1tCt5oEXkZHCYXAPJwV3Qm",
    "2qiGaosroo11aJBpEbhrjnzbuXhGTtoE4PWmFaquxLKB",
    "2qrBR73qDjqFpwpg9JaYp2fAerLQp12E2n6ow6CibJeY",
    "2qxmrVRtLCbpz4Cp2RhfvjfcVHAPwqBxvZSTsCJU17fZ",
    "2rbQa5BRkEFfdmqnQceZJc3nT8oPGkVmhqWF8S7MsPyc",
    "2reXLeB7pYdvtbAumvw4T9ua2ZEvjjy8qa9CybyT235J",
    "2sBR1LGDWzPCNf5RwGfB4dC5jLJ17NX6jjFe5Fkc6jCG",
    "2sTYo1X6CWYxZwmpBvxfxKicszzcxJBaPM7ySSr3NwqP",
    "2sgPxTPcRHJ41SYY5jueBdYXXv6HFH1rBwyfFmcDYcfq",
    "2sgUXyv9YH4FnNrrn4H5wWdkUoYeJqf7Q1Vzi3n2v7X9",
    "2toidXqV7MJTVy3FftNqnQQxjenYqXMeS5An1DbkiCHJ",
    "2vYA3S1bNn2zeTz7XX8wtGftHeRK25g2bE9Ew96Adtob",
    "2w9VxAssdzVZnBBkci7AevddhxYnSHvGLNLPRyg5AqXF",
    "2wMGNLh4k5TUjY9DnHtUJjvom2KLqRZdUDWYRLxsMjh8",
    "2wYJC2i4tXDZtFyHmRU44qsmQdSrYG1qZRe41MgGhVGJ",
    "2xQ546SafUn9Lzgsg9CEFyqpGV3LLQnbzFczaj9NigoK",
    "2xS8ezAU57crTFG67oq8iyfEYFUprfURetc6u8EeouCP",
    "2xWS8226eDdMc3bM5quA9hgeSC2KMJ1QSChn2rgGaEag",
    "2xnL6Uy44F6tYA4sLy3i3tK7S8TqFfhbWdqriTQgfJvK",
    "2xxvu5K2hyv95iNphJvjp4yJxGxRUaB7yAVgSBWs6Dv8",
    "2xyYB7HdeQ8SQmEsirDP9VLtFH6uGHUUK8FrWAVeGk3x",
    "2yaKqqexFr2Xg9xdb42vHDUQM6Sodcg7AoHonvj2cnMk",
    "2ynqw4QgBjPpfXaFYCHJazN4R56hpnZfrpa2XWeBKshn",
    "2zSWiA63ZwkWuFr99LgRaBV45LLPq4o98rWVzM63R1g2",
    "2zYWvYx1yhKkRNm46WdtyDuqQxCKyd3WC4DcQLtKc2rf",
    "2zrknzjjFkh4QcNPKvZxrFm4RgPLTBFQvthiAvLQM5zd",
    "2zyAkgBC2MLehq9tLvhV1HruvGFYL1amjPPfzimvUWo3",
    "31QLLv2VvQtjcKEp4oKVQ6V4aQGNZPSaR1npndoJ2Z9B",
    "31xzhBWh7C6gw9HNVjvJpbHCqSLmvm9ZYY5P9YAwSg22",
    "32E3SnX2oJHRhbKzv8hEZTt4F9sNWb7B3bb44yRx7Kkn",
    "32FuKfSyHVwfgwn1QDJBmy2oHh2qxqGUxWxf21M8ouXS",
    "32hJcy4L17cJ7DKXjd5bBwCLaRRn9tPGdYSZRthoNMhM",
    "32hUVBD5fA88itxpqDMCxQ1C59Ljq8XZcB1muep5DYyE",
    "33DW3j7VkShmVs8vom9VoiRn5gYugA4HXLnTjAvsnFbp",
    "33bDZfkXRehJLs55JyLmebWnjfknmoPvMnMQMDapZY6N",
    "33gUQtP67bp2tHc5HkhhYNkAk9iQgpz2bpiQB4AsZ4dU",
    "33sVvKc3hHqk6scP6SxnWyv3J9FAeG8nWKaK2WLkrPy4",
    "348fkuG3c62uLWPSY43PTfYWkPBPiCefgTrNKjdKFP7H",
    "34TbQw4vdfXTtsBKNrb7MiFGWJKUPuT32nHHmYTQQTXV",
    "34cDfGQ1HXekZJA5tLxBBB9yMPcMcQdFwdWVGGKU26oN",
    "356MN8P25pif1UiCsSh8VcjRD142XDdJSLCXpXQNksLn",
    "35rZmeBm5towdKpTXh7vrEondMdbtFojkEqJoyTvmPhS",
    "36ER59cdmpfVqEF7DMZfUYsQE2ySqubho8j2QzjqyUWV",
    "36VnmXGUDQbKaH7cHyZd1H8CBVifYAonAerMTTgDDKJg",
    "379TL3PwT63SF8Xg4exBbE5g8F4bz4kCmJgETSLpuB3H",
    "37Co5PFnkfS6FwawGtttyX1JigPdF8p43NBn6aka7Tuq",
    "37HrVKaWEPVt1TZKzAk41HWd8Wzv2rSCH5PN2mncWDty",
    "37Qs2gPdM2QEYYdJQuaHNV7fciridmkgPkQFP3zf7Nk9",
    "37XDqsrR7pKg38W74GHJ6r9UnkgtW8Ar9ca8A6tzTpnC",
    "37ZJQBCvtLFcVC3JT4nrQK9tLUXvkWt2XsKFsZM1yPdp",
    "37bB2sqTNtWFrrb71kokeK6cdauYDhdkqGcFVJQp8VYw",
    "38HGFenQSqi6PvEHQ3v7UtXJoyCVz2U2DVo3rXSo5Tgy",
    "38jKcZuZJhtkrBVBXYeM6u2Ezw5YLuiRBSXi3d1a84me",
    "39L2cAw5AEtCYDsunhy7XA3BTpifpJ6UCHFTu9cnkTBV",
    "39RfV21m5VgMmkwtPEhxtoYELLLQ5vhBD4sD53C9nW8o",
    "3AyDo4t8wKyJpqUWy6958MG7ME7nDubi2odG5usxEgTk",
    "3B6nDrak7DbxxxvtRcmnR5oUheXqgXee3Ec8uy12rs9T",
    "3BVJ9Qacs5u7XEZqVKAy3WespW774osk5M1aUbWUTE1N",
    "3BtyBfNexGtRiHbnuUzBZ6x6sBbHH2e1cS9tLELawk1G",
    "3Bz1uRgESVgtaPAxhSSMknmvMQudtHbfTs98VsRiJkyE",
    "3CAoLnhLdamEzpRR9NbJfFV6m59CPXvagQCXunh54fVG",
    "3CKmLsy49ERqGvTxnsmsqJWFRqEtRPNvzk1nQosVNz1J",
    "3Cm4mpFLBPj47UfnZdmc38Z64wxX1vHXevfZb9iiqN13",
    "3DBXJZwE9mweVTb52JoS7YpPYHzfqoD2bhMgzxFZZyvx",
    "3E4hVw1s8JvAoWPi1eGpjf68DtsNGHg9VGxVSGqXvWKh",
    "3EHoVcZkeyhxkK3dD222Bg77mgBndLL99HNP9ANXDFYD",
    "3Eh3hmKyKJhuy4otVU4Jf7BwKtWHwrNheFYMj23xXcmd",
    "3EkYq8fuWg7q7TTXdxHqe5DoXXp4o63rQRLfNpCGACW8",
    "3EozJtFhmmXo5oNvGRToF3FyGQpe4wgReDKxie2gUmpP",
    "3Eut98RRHaDrGD7qGukiYKrnbmiHA1weHrhq9RdiJJAW",
    "3F7XyB8qU12pc33iTwGd3J37Qa5x3V9YQY6pmqTXvzBC",
    "3FrmAnWrrnyjK5fFjV4oPRpb1oBazEhPRkjk8YPq9su6",
    "3GFW7vJ1rpqEcFJpXFyZN3eXcVD7rzGygdoYrEpYvPU6",
    "3GLPS2tVxVVMCsqdHfBxAneKZmiuQAYkBLSiGiBVhtQQ",
    "3HBKD963Z81KZWiinjVoCTR6RwYv5FLrg4BRnwVbEUAX",
    "3HkuW2KanbK88kr2dcNp8mtmKyQodddZKu9vDePSieE7",
    "3HnFPFicVstZ8GgCrjRWHm87DjJKZEsZb8G5RpDXsnb5",
    "3JNDQMCcTra8cDWekrVHFvBuiMeJqRpXSt8HsxwYShv9",
    "3JgGsuTGfjAx2KBs3NhSUUQoh7XMy32y93bPgH9nxPtJ",
    "3JjwfK4qrwvtWEnfghnd2TADEyu87B7R3fDhQkNd7Vc2",
    "3KPqjvxLXsqYSSbtvnvZxxPBdik6ACtaNfJcZnyjxpP2",
    "3KVxKXArJr2Xa1rosHVjECPRcHHdvzex3aUEdGoDBUKi",
    "3Koy9FBBQibNLmW5M1xiRDrmQtAgC6SwDq2S8nNTYFb3",
    "3LSUjrXQuUon83Di2yhG42rEXaL1vNvbovZajMAUAbxU",
    "3LgUsy1QE41tmY4CTL8V5qJWfwFk4VBhdBtvgxVvHPqB",
    "3LkZAS8mQRtfd8imaZ2KHyDwwnXcT6Ej645X842kKvbS",
    "3LnU3AXYLpniFyfw21Uyb2ciTgwhFY9itJLsjcwb45Nj",
    "3Lo1WCkgjcp4YMmidF6WbeeRqAzoUsqSytDoZmfEMJYQ",
    "3LpALxXSiH7N3GgCQ2yy2b43yBuhWhTBjDxwz8ovkRtf",
    "3MERZGLML1JpG6D1w335tDyeu41tLrLq8cWpmMpHZ6iE",
    "3MZo6QASWu6sscKnpiz6XxC6NrchoxgrAaZLaQ5r1LdL",
    "3McHq1fZ5hRjgLtFCGmnKuKWDKZXQEihyf6fpmwNTM76",
    "3McNG9K9bx5qu41Tudqmz1oxippsPvL9pcyrsnHRafHd",
    "3MefuJDrSi7SKJqtASBC1X6Dn1Jbq1xS7KzL3ETa9T7M",
    "3MjwPKxbhUY8pqqUxAgZBwqeZy8JUCxVjuBFMcBphvEX",
    "3N3zZ1oKaNEP9WpDRXyYLmCXRP4YgortUnfSo3FG3Fcf",
    "3NmqFmoDUP9Yr1vQwpLRY135omNbxt9bfn8By75MyrmV",
    "3NrDU8JgVnKkCwRzRsw6oi9C9xJprEUiqkmDonC6hzNY",
    "3P1dzMcsgVXKMJ5aWKrrSjVx21qJTLPpYfxnZQjVkq9k",
    "3P45yQXq66RgvaETiqh54zTsYUhpb7yP2WZF6TAqUAXi",
    "3Qg1nZSE9gpdL3HaiedxAU3qNvK7bjm7Ry3WCG8sDsuK",
    "3Qh6m8HyR4YcGAZp9i3krmnY2zN5ddGwWGdk4V8uJ91a",
    "3QhKV4ym3JydofW3PKN4HKrkurBSVGv7635PY3sMawT4",
    "3RMEJvYzrSaKFjWt8S1mKLJJyPMJi6rRsndwefjgFHZ2",
    "3RXAW5J7i6hdLyMGhWheFYchK84zfC87Yz3ppLvcbETc",
    "3RcxqzTKu3jirS1DMTPf2o9TxgzMuic9WSckgrFzCiVy",
    "3RznD1Nj6oQZN5v6srKy5WmUVxN1okibs2UYZ6Sp6mk9",
    "3S2unwyMHEGBjQS1JWbNEKwcusJV2ZJZDY3nfaqmFsVq",
    "3Si2RCYHSHyP2avq9AahSnkjVvYgqhcyavhLb1Y9Fn4E",
    "3Sq5GYxGG4PsTQja7RB26BfHEv24TVH3EMGE8ymwiv56",
    "3T4SgvBQahbtUd6S46aYfBXPFjY7nUgqQB4oU3B94iaw",
    "3TMcmzMtd6nn5QJSMPjpSVwo6YdwiRXcAG7CLr63PrCD",
    "3UFswLJfDWG2VQ8ukRApG2un3B6imnchnNtj6Mcvf9Tp",
    "3UMPbXFuv1n1yoM8tDve28iaC1oWV7xdQsnnXNNaT9JJ",
    "3UcjPPpN2ooYteyKwfMHAz9aoUwpLpqqyqazhp1YTKT4",
    "3UrQBVuCAgqn5BXWuGF8oAnM1zh2LZaUaFEDuu1pvH5z",
    "3V8GuLsHqMYapkzYKrtaNjR1eisfnuiRNTGZy5Wr7X3p",
    "3VcZsnQE1k24aJCSWzhqDPPWuzZD8EHgDRgFJbsT6Lov",
    "3VwtSttuGKG3B33bj4AutUU1Nf9nNEBV7HKnmHf1wFLX",
    "3WCH2R1B6EbcHh699TkyQBuAtdcMcBCtYGsxizBQkuMZ",
    "3Wc7n943oqWzLYqjTzHxnkjewk3RvW3BrWo9dr2haqkh",
    "3X48BwLZxZR7qWFoknTFSD8UfriVwVWguNbhU946qbNE",
    "3X7jxqCzfQWrobhepro2iwZTm5zY7awUEkukd1KAPNjB",
    "3XLbrHuf8Ksp62nQKJgfEddV1KcaC1iZt57Rt8QQt8p9",
    "3XWR9JUbDxpfthQmUbxkLPBfhiwBkstzw6goUtCDxV6t",
    "3Xuqn6YceMiZMfWkgTW7Tk3LvC1DtcWDCLktb8LgxhhF",
    "3Y5SqjjkAzQhEkoeAZS1y7qUP2qcCpheb2eVCG5wTW7M",
    "3Y5XwXZuff6FqtPYaNeRex98BoAJkTHPfqRN2rrcsago",
    "3Y5aQ36amxYtm3XAmCPFM6eEP63EZFbGCwbU9taX33iZ",
    "3Y8bRj65AYdzMbpvjNdudhThWoSUGjXefLv9Cg7Lco1d",
    "3YSMMpzyUT43JN2Cj8fY5o323ZVcJ8DTNfsSFBkdkn3n",
    "3YrgiSwoNBQrPdupRDrzCdfPLUP6VnME81mDMLmuv3gU",
    "3Yt9yPiyzCCEp72Rcfp1EwZR2jNhYLxc5cv5JFy6aypq",
    "3Yw9kp78zDkeLD6AC2HjSVHkMMNWuZEdXntSFLvSz6sM",
    "3ZRVpTqBYCnns3wnF4GBeC77HAXCoo6Deqqq4JGcHpr1",
    "3ZynZaXaeXwCcYMLT9Lgcmw4adqm1EQtaqHSC9UnwaJb",
    "3aC7Mpdq9ZLHY5E1uuxZ9BYLgJrvweauRjk2pu19cYW7",
    "3aWsxSQwsiyor36S2SJQUgUvjgfr68xv4xTE7MiY7Pzp",
    "3b6Ga5QNncpkeHjXrw9Dspzex5jpVejz3JqhK4vkSDxK",
    "3biusQeKPbG7ao42cgVnEtEs9VM8Emtn6BgeZh54ABmP",
    "3cbqwfwGUhtakvTvibRQF9GCDnwvPaseM4ZUpr2ByUcn",
    "3cojsW1zq3Auxws8QgLiehYGBFWXLiSYb2ADgW2aDvSn",
    "3cqpyiJYU9d6MFCxHcSwndNNRYPugXuwgoJkC6cAEtKs",
    "3cxPej4WETfnm5F1UpBWPSYMr5JgeChz3RCUsKpnhESQ",
    "3dAyqT6xjVJqs5SApzRfKSQdQ6mDbbhSZ8ms4RdKSLZ5",
    "3dntHxaZGdHCvy3ZeizHhKtGTPRscFBaP4X4gkTxcKKF",
    "3dpPmU9wCHQ5gi8nZS4peqinsDVK7wsri5m9XcbDDFqU",
    "3e5fE1qhcLjsqjiQ2trHhGLv65U2xgKGpJarCBCJ7PfL",
    "3eSyf82gBUEqWAD4iVNZHckL8Ly5eKK9jorsVn3vwT7w",
    "3eVQyzyCQid9QRA7ybXhYXTpW2wrq8F9VHcBKZTGzA77",
    "3ehiGd75jW44Ny64hhhRjzJN9SdSh34bX8tLDEPuP4iQ",
    "3f6UjWRKgtQ7PJwCs7NVSoRLzPfdAiJKY6jEcP5mW1rw",
    "3fdt3eV8GbG3xAVMEpqSubaeTEkfU9CCGAo4M8vEUxJE",
    "3fjH48MFfseaH9YNFpyLVXc1rEW6m8hbKM4e8b8QwfVJ",
    "3gSnGkv2Yi8VKMHFieuuDQybJgsNqPjMVtfhvUcAoyCr",
    "3gT8SVpAAEATLFY1q75wycQ1igQ5SeaxQRAKN2V6w2Br",
    "3hfNQGMNDCddS4aC2j35LHZTAURFB4mbYxzKpdSkhLZZ",
    "3i5Qsquqb2mQrXXN5DcFEap54r37y3JRAEbyEpeKnivb",
    "3ioS6zQJh65wF3AmDxBxfYjMftTD59zzTkp7pb3q9jff",
    "3j8iqN8KQziAeuysxt15M2SYaickGEKYdvMpdJGMyKjc",
    "3jocYiPtQzmVVSNwQPh2VHwWzUi7XvcvgkXwb65ZHCaQ",
    "3k7gA6xCf7Am8cBB4mYCohiUNnRrAECWSLXqHJSebAU8",
    "3kA1Y9vanmHQw86sBzJUFgx7UktUJXzTVepXgaFmZYrw",
    "3kFWLtadg5SLaShvfJvFPzpjqTRAAobZ1XfdrHMUSRtJ",
    "3kVtwqGNuQKtwxnfvZ7Hj2YujReDwGRyFqqihm9vhkvQ",
    "3mR1Cr1VmTV83ck755zp7H5pPKKBcpHs3KP5CwT1fNCd",
    "3mbdPjWeJNA7fV4yiL8NjKwRziZi2YRGTaNL6CVivdEU",
    "3mkJLqa7grMK53ZuZVyYv4qTXn8ZfH5wbqbqaEWQfP3y",
    "3nhAWfactoLzpAixKtaEqZRw4TbGXj15Acy9qV1o2cMQ",
    "3oNT6NpVeBG4tp4JpMgTeQchTZ1vfXCy3YGqaWYsfpUm",
    "3oUJ15zmURCqc9JXwxwCLYJg6gqxKPs6PGJr2UtGCMDM",
    "3oVbso1kL4FkwSG2ixCTtTQBCvLYQbWueGSd6JBUg5cK",
    "3ofDuBnQ9xVpMXuJbnEFpV3aDbNeFXTws3nyob19CBaS",
    "3ovdb2toVahwWrddEChuQvoKb8YUoqsg1yu1ZTg5bk9Z",
    "3pghUx9X5f9r6HkRHmYcxAHcp5nW8Je6dsVMbNdNkFyG",
    "3q4s545U5DZB3HmtxxhhSku8w9oPtwdxWMSHAQe9qj7v",
    "3reg8K9CQ7KzgUc275Vwr86qFJ2aTsGVeqE9TqRGuMy6",
    "3rhEUpBM7Tr6M41AY53Tu9sJj97VxBLkqXks7TmFZYiW",
    "3rrRxAT9bnbH4cPieWGDuL94uQRn5S6gQerxtpsUqiE3",
    "3rshuqbDFiy3pqRJFNFEmUkrycxEpLXAQaZdLzQ4d184",
    "3sSumnRbt8schErxpQrbd27hxFu8aH9KG9JaSEDGhuwT",
    "3sfHXLxHTBx1MdvRqipTnCumgSrNg5AJiwtkaijX1VEJ",
    "3sgQCA5dijZBJFahqmRmWUxjomuHvxn9HS5C4cCBiL87",
    "3t1WrRYqZytPbdVbxThUPFMEBPHkUY6DFxXYJHDnGLE7",
    "3t8NCCJXRUpkU38pkecgMpjbc86g3mxeKpuUTdGgF8J6",
    "3tSazjR7ZPwJCcyT9ybmitFj4HnXrThnWiSzAs63jmpR",
    "3tZ14y1jE6w5HWjgvKJvFPvYydCs2xDgNxCuPGRd1KvH",
    "3uPCH83icVLmc6HLmbSQ9n2Ws4mc7SwMPpVernK52o2E",
    "3uYRv1yapAyTkZdoErLhjn3cLSrfDx6Rkrf8VYkWQ4rG",
    "3uZNQDjWCTmKhyL8gPmWm7YvAqdPBmADZudfgFWNp4sn",
    "3usDaktV48e3XMsgpWpNDBjmaVMkUU2TBWPAWJqokRuz",
    "3vpcCtCXRKCYh1iUSYdCCkFaXK14Qb8uYUZsDP9puJcQ",
    "3w6aTfxJQ5fwNzRBiMDgofaKNNwsbp4EEqxqaUEMKrav",
    "3wQVzvLyiNJQvdcB4PocdJ3W8xUcHnEAGZPCRRiR957h",
    "3wRNyqJTnv5fTJs3EmE7di3wQggaSLeHCVfCwdHDceBM",
    "3whUAA4BzUaBfaLrC26in9Y9XfsPypxs9sg8bEagoHXm",
    "3whmvb2VdVWsTkJNVitZ8kRdj2xTPuonk9dNxNGrC9Xy",
    "3x6WzQCD15KXVC7EWr17qqVS8r2NS7QUjuG4SdLmRzHv",
    "3y6GuWSuPksiP1KsKkuJfwiaG6SXRrojBmg5vfUMQXsy",
    "3y9YZFmw1xy4hBkAebLBWeZGdrpMy1UjNXkttu5h4K1W",
    "3yCPhPDWwsqW3s6BLF9rVDudwmUZiKfoGiz8UaNLdimP",
    "3yyLFHKr3pZtLtsKFoiaYnaYgK5kd2dk1boZBKUhtzmx",
    "3zE23UeT9S1S7QB2nRUAtQb9LcdYC6pAa2JxZ7VFiFR5",
    "3zwuKwgwWLhdDUPS2io2JsvNqjHw2VgxmTvjHv4kxeWH",
    "3zy3Ur946niz3MbJc3GbNukzorG27zVyLZ4qhY4te5pH",
    "41uJKsKGQCUin6ppUJiziJvFj7fyfEcrE5dKHSndcFsA",
    "422rqrtHJmmLTqbetATFX85SDkUEDG9c6QzJRQt5KsZe",
    "42Jv7JKBwYqJ7E1jhdXxCSdM92VVncJwjX4mAma5FrWm",
    "42jz1ACsBnKAoZVPKCmrTcZzed7vPztFsk7R1JN16vUP",
    "42w4X4VVvnfxAvXKRNfir34fAyrLZdKCAA8feHNCU888",
    "43mMKuPGceXU3UdcQ1YBGpTbvfC2yaqWdU285ivej2sQ",
    "43wLbxwoaMMpULHn56gyted3yvhbDhMkBGSHHVd9kCBA",
    "444HuRHHNEQLPyjUm562bNnypxR7VqbWV87KssxFSGYi",
    "44FLryGjEbbJUEbSQUN7yksesY1E8oipjur22ao7nrDr",
    "44jVZG3d8YoRzizcdBovJ5k2tTZUirJXaqXC2YxoFeYQ",
    "44nVPdXSAJX5dk12d5YPryjjsepzQARX18SgQMCzQ3Z6",
    "44vxKbvS7yheUo3Nw6JvrzmkocQvUXXt8JSVVgDmPMMK",
    "45DzHWbpYA91pTFbjxxns8CRwFgzJUY9L2BA2tuEmfhc",
    "45EZH9mqv4k8GvbENTwFVp7KnkRopHgmEXyjugeeyJxP",
    "45b88cnPi5cVdMdBMh2BaqyR72geMGGwLVR5xHNKCbrg",
    "46Ya22LVYcngqK55kwvmW5MBk7Po9sKcZkxSpujRt6N8",
    "46jxRRvgDzswuKkEbVeAazSC6qtDbq68tzJqKs8Vxtdt",
    "46rmZo19SZhb67PuxajqzoP1n5UiUdQ3SPrY6qNULRxR",
    "47Nkdkp8TLgdZ3RT9GvPRD4pi1DjHcf3tshEB555cg8n",
    "47bDKJEZFiysYZkpidsFBHhvxoFExUz9hbKGBhm8CtPu",
    "47edy9iQdngrDJ8rdBi4byTQk6S5Xynr7nWzLZJLQC8T",
    "47jyEAahjjb8P65tZ4Yu1vtFnWPu9ZUX2ST7Sj9SMixg",
    "487c44vREJavyrpgFUZ9UiVCshiNA5UZWnssDm1tKCVK",
    "4886LcweiLqWDkYceXHzecJRzcShpuvZBDBbFkGewQrY",
    "48NMx9sMnSQxEj1MhzpEeikvdYyPjzwDTEud5kyiwnqp",
    "48UZJgEnNEypL9HGVQCaqSfHMMrJziNAaLEGbpmjrh7u",
    "48Ws4yDhMJx2nhF8orXH9i4hrJvyTDeCq8BTV9ha4bE5",
    "49Kp8zHA2zjyLpsfqxEC3GtCs1gaY4aisjWRq18BLgGu",
    "49TAGP3TpaNdix8JZaNZbNb9tjXZkSYrtrANm4zkxMFa",
    "49VBxJwqMorwqmc8AxbP6BFLgx5y5iWUme7tDt3LnNhW",
    "4A2wNHG1WLhmpycjtP4bVYnJG1Mb8wCyTLpiE1R91K3d",
    "4ARffgjtXxiFZqq1GKTyomXpPFe8dNbMGKAydUjbDbFW",
    "4BNy3P8xY8vtPVK98iB75nypFraavx6wU8u2RAsUZdT4",
    "4Ber6kLwnjrmYjx6PNdPyKLN5ekSYR1HmuSmj6MvrsFH",
    "4CBFx89aBwVjet8tw6pkC5NqPmRTSJiA3EqXh6Fi8Fhn",
    "4CWLsthvLrqfZUD2mEE1e19gDJCCVFNR6UMRswX6Mabt",
    "4CbkiSQGayqN7TY1c8H7Qpm8a9EaPZqnmChCfr413xDM",
    "4CcygZ2NWfojJyrbe2yEkhpmLCSeUR4b8cmdikH3TYQ7",
    "4DDDWw9VHn3E4v7QKtHb1oYjRLiBFStpTvCoGTbrqCpK",
    "4DKXJM6SdFbRfjMyoadt4csLNzdYpXMbXWDTDwosmXUm",
    "4DfXtuojDZetEJqKUN2Tvmf8mZnR2FfaCsLKMTqDntMZ",
    "4DrT2jTfHCBeEKFEpBnSWcgmVDmGuaJ91igEn3CUXgBw",
    "4DwAVQmEBL1tKpKdyq7tvgXktUzqEyPB8LxMEL8CmjfE",
    "4DxC2GDb38L6ioC3GUzCqvaW8w58VRncQ4ug2EXSfB71",
    "4EEBed89DxYvvLV9GZvGxAnzgeZhS6mSyN4j4AHnJpgM",
    "4EU8YF3Y5smpvoQUrqwVALYH8jDFQZKyEzzp4BnHWG47",
    "4EcHWWLYhvepTm7rdEiv1psgE3np5Kfctb2eQeQMDzo9",
    "4EcMb4N22T6xGLGUgPnshGgcDMXjJaGhaN2JeDBzrxtV",
    "4EihvCiG1YYkUvRFHr335sU2mSRUeZnx1FK6h83ZcY8W",
    "4F1HeQ2km5fECD4UJoxudUdVbyXiLxJqBAPQ9MHpVyfs",
    "4Fz1SDghWSvTPsH5qNCWUTcLveavuASxpRLoh7kp8BqE",
    "4G27SLKUnY2EtWLHTaFJBC1d6rim3ZAck4hrho7awZoh",
    "4GZFjWbASKUzxJzdoU3mtW4Eusixa1iGLiLYWzipmSFD",
    "4GxJqz3tVzJ8Q5xavsepixfQY53GVNuXF22856x3Fobt",
    "4JAiZ2YSdFqMktqekep5YF8jE14ecEL1hkLbAJvvH5Sk",
    "4JKW9iMauZ3Ed8gjVHQfz2Qyu93Uynpym4yox29kyVSf",
    "4Jo76XdXi5iFuh5UzPvXoixELKh5LVMXq9zawGR56wh4",
    "4K69H68iVyZiruty4RbCuHbZcpLzzRWnKtbJQ3erFUER",
    "4KA7Zv4upX3tZDB292HGhgNmZfw4PRPg9R6Q1DAPQUyw",
    "4KBq8PBo5NYtaYHdbHUdU6bxqFU4q4ZQG4U91f45y28h",
    "4Kger2Atx8nZwAhP35etRBmseDPYVhfRDbnq7pqMr2QE",
    "4L3N3138ZfdC1yvUUKbv9YY4wRsXeT793fg91tftZ1ZK",
    "4L65Y3w9gW5AusKg7AVsizeSfLfEPno1cE3YjnuHRP9k",
    "4LFpTmiiTUw2Ugp218htGLMMsMEuCs56xQvmsfSZbJjn",
    "4Lxfw8raAMxfaZsRpnEkcpUocepcfjdJ4uJJpLQdFScj",
    "4M1go97deGcjQo211D65NZV24FCrGE2d61c2G4dSXzbn",
    "4M84AmRQN2GX6UtCoTVaR4iHsXGTC6iozdSMKKqMBApw",
    "4MXJQGpEgq8bc5i1FKqUxKwDgT76X7NCB624Aq6eAVCB",
    "4MruxbEsQwEj768Pz1VGy8sJzHPv6BPTHM6SdSprwFDa",
    "4NjxtGNrybGTa2HfiwXMAg24dyDQNktrhvKUAXy6gvo7",
    "4Nn9CcPsMxwB6fr47k225wZ5uHVAth2ixi8ddU8YF7dp",
    "4Nz6x24EC9MFAtoS2g441WqbTdYtQu2UHTBjmbRfbfqL",
    "4P9EfV5Uw21ig4sbuKF7BLX5hb5UUc1rCWn8UUurGkcb",
    "4PFBmFtkfYNTz3wHSZBdzKzWgKRinbSqE8GcEtxxbdMh",
    "4PHaaahp9p4XUsi49QZEFtqd6ZF37SSUm9qU7xAfrCZx",
    "4PL41zH5UGwUdHPb5VWB3EmUNZMDKP1oc2YnXrHnGXTv",
    "4PMcf15tp8EvJPwytq6fvAQ9qWJ7jjUGxvPRXM425UMU",
    "4PjWzLs3EBXi4yc8EbfC4UikAyxjXRy3EP9VNbK2ETrK",
    "4Pmdo1bTHJoQehonf47nBsbwUtcreyCmXcMFaoa1QwXi",
    "4Q527tYGVeRmo2wExFUDKsMTjhZgDUtyfDC3U7V4tZbs",
    "4Q9fbMVGwczZ3UGJKtUwRsSQt2WHb5HXor4svqC4GL2u",
    "4QJwqU9n5Nc6mVqfBFUadpLaeBsXW1qCrNsBceMefYSW",
    "4QiYVsPotv8KKLzLxk3FweHC41na7TU7dT1sgMzZq5T1",
    "4QmynaDegWkFbfokZe2X626wDirbJ61P5yJ1uhhfG4wq",
    "4RaU7RrQHC9FEK53A7mcJJGRrJx9arxym83kPaGcoXxd",
    "4Rg92cDpVmY8Ht1yuZyAvy1YjvwQuFx3FZhCqbdiMx3S",
    "4RxyjBoZ5Uidek7Ar8P4xntTY6kMJLvNkQWHUyYnMABs",
    "4S54TPwhdLTamqvzV8vrjvnsWFFWAWs5j3xqgLZUwZq3",
    "4SpCqcnGuqYd5ooGReKZA178Q9nmTxQyuy9JnZYmnzrJ",
    "4TG14jwHiiRgoymCWX6T8Nz6uwPq5tsYtX5i1fakcZjL",
    "4TGEXsq8W5kZBXZhJRnLYjRWRdrNEcb8SWWdtL6pPx5f",
    "4TM45hLxUruBUe3ZuqoGsddCHRp23Uky9Y1ZmNNbxJbw",
    "4TQ8WFSMtgaEDKg3VPVcDw7DdH8EdACzad8G2p3U46Mz",
    "4Tji31u46X9CABAes1zST2aixHSxFLk4R6P3JK87KMdL",
    "4UEqS9Z5YKTwXHqhpXpsYYobDRGKGGkSnEhHdbN1m5Ld",
    "4Uezh8Nz83Jf8JofEkJdzzcYCrkZtyt7H7XHJLUR84Sw",
    "4V7Gyf23BQSAtFjh5baAbbAhuUs3rg2GZRtA99Ue9hrF",
    "4VSe3agE2gzJadkjYMH3GQbxRGLrZecX7LVxqdWAvLfg",
    "4VsA71GyaqZk1UZtt8Tbsb6mESQiUWxsv6XV2KNAnFcf",
    "4W6UPg7pRG2CwDys4rPawRu2xhS9mEJT6bw8BSH8kVQm",
    "4W6k3kE9Qkuz5wSiwkx3QgdSHr3xaLc5QLDR5cMmsoRo",
    "4WW47A8hgUQ9yVxqiuhhEtkgLP7FKkCnSTWQm17kSWMd",
    "4WhMGGBgRvrY1VdUk7UabkRfNVmDgNwSQZQia7PtWvhD",
    "4WjPoFoC23B8dKQUTazZackj722J2wA25UqB9ZmuKMGp",
    "4WwD9NEF8chzmeiRnGdu4wmJxJ72FgtY6JCVcrx9Sq2K",
    "4WyzbreNKf8Q3KfFSx4BZZdUnSw7mJ1XW6mx8uSj2PEh",
    "4XG7CyWcWpF9L6vVeoGK4Cz6JKkiboj8URBNdQpqdwaD",
    "4YHqmBRteXrVxP4i5ZjxSjPZf1VfmKSRTUKd73euoxFu",
    "4YKPFpqxQFsjYoDfZsiHGPibrBd1jiP37j4P92msWoP1",
    "4YLUnwALmyvPkEs4Q4erthsxPCW4NPxX7MMy3ciDiwJG",
    "4YVT9EAH9hJz5wuvdUUb31KkpYnZGF8353a3466Ze234",
    "4YdAkKEr4Jno8GUVrdR3E5FTtV2AdTqjgHviT4Tkn76V",
    "4aqtBa2dMJoeFGyjHyXRicHqxP8p83GaoQFJNr59PFQg",
    "4b1EXJ1tzSTThsfUXevT3ioEDNcZgE4bknEBasdDaWe4",
    "4bvBtj7PUwfoqpN1aYJbbDQtonZjkJKs2tTbyyGLu6n7",
    "4cPCSws9uunBzFUaCgZ3UiMpAsUcWGSXyQFpQSoa3QCA",
    "4ckAm9BQown1EQRJrP6TzgHnoZ37X5v1ewY83f6K6k4w",
    "4crzverDN9gEvBZQbRRJMFUe9AAbB5LPYj1N1APtbmcE",
    "4dA8ScPaKP6om3wmXM51F58jPoNk8kD7YUXy5Q1PEZ4Y",
    "4dCdhweaCTD2YJKb2F853A7YZCWFuYsCq9uewHCtr67S",
    "4djK9eHjJLfZKfJLcLgEp3G8dzy7H5r3cQywpgnirW4J",
    "4eai5DKX6yWvZAUTKWXXWasfuq1AbTBM5hAUsHb9K6vK",
    "4h265uoowPDPdu6wDpi5zpLPhuKXwJEd8AhL3i7uWT2r",
    "4hA9REdoWHkRLwK3wPgxG7teShVwZafecRZAYG84LWQ9",
    "4hKf2w3A9bZdSh2gPfJ1uvbo6FwfswoBmgdsoWN1kALb",
    "4hPQk1CLTDYndsttLTL1AFqRygvMDaLC21cnWceMtW5E",
    "4hZiCvWv5kjNkmt2TKuEhw5hD6KLzD2zXdsyhmQ48kCw",
    "4ijXPpngxTMyTUD9Mcg3DYywSbyVWksSvbUi8jDfCV1S",
    "4is41kitGtU8t3p31jfJ4j9kCSuuzcFtU5CSneKzdm8i",
    "4jGKDVSbJGqqo9XSDDiV8HUCS4tcJZCjfjP8SpUi3wRD",
    "4jGL5TrD3BtwkQt4Z19p5H4SetjBLCkPN6Uq3cXKhqET",
    "4jqzuuZ9sgir79ACyYrS27KF9GaeJpc69zttUh9PAo7q",
    "4kD6HPdx6rnJv7VxfBmSeggxqxyX73mJHferxv3ZfGer",
    "4kmhxgpCDdLJ6WSZDQRS6raKLXwA6bxTJFvHVxztWRn9",
    "4ktY1LsHBzg2VpuyKqwjxovPJn43dzZEpyFM6zWUcnBe",
    "4m56XFQeefPkvJJTeQyg7HmwwGqmU4NyefzFs9VXQU24",
    "4mCs6jBpocT7SjVTrgSus5JjWcea8hjqxQYvjhH6MFT9",
    "4mGR2t9T8eXMPJFeWghP2RDaMqP7cTk9ZMKbyzARpAkv",
    "4mJyZtL1xkGMRZC25ApC2rEWoBaTmrtbFmu5TiieY5VL",
    "4mZE12H5pYz1PTaPyzpUprfMtUUtdjjwC3ATA7tid5bu",
    "4maNdxoosc65JZi4j25Tw6HFQpp9u65k8aP4S4LyTrKP",
    "4mbyggGFFVPMAXMV5ttrBTaubWTcgoh8C2dEcE8VNwdG",
    "4moqdhPtxh7PkpJB987jnjKYP2F2zSCpqZxPYJpga7ob",
    "4n96NMvqCM1aacUhdiuy4tqCLZGmHsyPid37A8NwxbU6",
    "4nFTzauwSn3CkFn2PbEkVPqirRsNHP926qnJD7VA1X8e",
    "4nK5D6u5nEPDG8rKnxTvgDBafMdHnC1nooxDDNhExEi8",
    "4nKhVVa3RoLaCqMrVJNQij1kq9VCEfaopn5Ls6Jo2Stk",
    "4nQprnNwcSVvFUUKs2zTAfK5E1ksaVZwDxKKrHpQYSsP",
    "4ndDLu6o66ZXnkXaRjTSUArUMVQuf9QiYo9QKqmsRdmg",
    "4noPcARSSSdL9FPnhTFmCY8aq4R6AqVhN6stVrTnusmc",
    "4nsUqmp37EXDRR1jiBYNM8TyNrMJPa83u4ed3VvQnSNt",
    "4nvAtzCSCo4zYYhQ7V45YtBWwAZ3nVSHv18ahmxjvzAM",
    "4nwML5zUYCNNB8PKxysJ3rXjCFeLRf5tXdenuxMpiaiv",
    "4o5tysfEe6VGpABizjPtNxs3QNtqLQQxKn3AVKZnFUiT",
    "4p34yT5ZNJhz6fBsGyoHEbhkt9N4WrAYfuzdQNFA3RbH",
    "4pffBEbJaeZwet7QHNj7z9PzH81TrYtaNqgbRLgf65Kp",
    "4psy12aMv2VPkLyWejmnrrg7quHf8hVUiYWBJ6amWJUC",
    "4qF7jj2Z2nzdPNskXtGpSuMah5wBbJVWV4WzeMp9faS3",
    "4rRVhmGhknHb8wmVCNTGyHLFoQ8Fxj8YzP11NRni8mM7",
    "4s5bYFQW6R9jf8LMrZHQgodBDbp8KdjqW1RJHYYeNvuX",
    "4s5dr8veVBSbSjtLFqTi2yZAzixDiuqVvyFzoG622V8V",
    "4sox7ExEthDPANgbnVFVXjEEHnXGCdWqqbyBkCuGKiEf",
    "4t5nW4aigR9qh9VUmp6fDkvH3kxYTF4zsWBHRxVmCgCu",
    "4tCmeC7RPfsWHkYmswywHk5Ab87Zc93j8599WjEgNmQv",
    "4uHsErpc2gFCnbne9oEHvF2eFrh7GBMva6fdvJ5Np5uj",
    "4uU8zh6QTaANSmxxUyFMZy3MYnav2tNExNH5xzLNy5JK",
    "4ujvij9drZPm9bnsxzKqSW3uhrpAC7NGbRWEUwsUbcHM",
    "4uwxv4cZjASRpoLKfGkwqrp2eCwCst6pfWjKGLW7tQr2",
    "4v8ryBVdZnsw1ZgnLjYnExacwt2Bf8UwdLNFNbVj3NQQ",
    "4viPNLBV81rBEkQ9XWaKwXx18n4DKLqbbyuNzVBoBV3R",
    "4vjTRNqe5aT7YP5Q2db1Ym7dBiiV6hAAUspp1xonjtei",
    "4vjeWYhFTLd3bQkDyd4FYcfsaMPmFQFasrDGmgLNvcD",
    "4wUHjeh9ssgxWg8jJJqbm8qjtowDwJ6sHyzx5u4YXMmi",
    "4xSLBaq1JbcwRjd9x4DJqC7xQxTyvGS2yDhWbA6kxvad",
    "4xv69tKe7UruPDg2DWULSrdfWijXycfkSbNckDmunyBn",
    "4y2SH2uwTy96eHXzVQmbJWttcA2uYaVpWqSRdD1MyR9m",
    "4znJ447D6Y855ZZJ2wvtk8Gv2UfSFSH1z4LxUKM7XgZA",
    "4ztKYctVT1MyRQrqKTrwJw9g2DDRfiMAmkeXBse6bhxY",
    "5138CzrHPqRPGD57dVki6hDZeb6aYAW4S6CdYPAop1ho",
    "51JsjZnL3bAaD4wDBD3xRqmKvwT1q6pPArjxBPp2n1UL",
    "51MiZzcJDMZK4ef7EacmooW8nWLAYxTZnc3EKtg3uEVv",
    "51P6CtVbAt1XMpkZ5wep7Rhr2u3seDmZAT4UGLXEoBWd",
    "51YymkQamZfRirzbs4DvmYExDaJK1kJqnChKg1e1Tr1k",
    "51ozUUVgLTK2Ym7pvggaPzVYNoSRyVxUzt4BGC4Ekstu",
    "522TjuZhhu63fJFGyj7FcMhpqengL5Ccvbnr4ywzPuSr",
    "5297Ww5TfTCgHC3VBw2aGwbHBrhC7ocBjmzrMcnd3tpz",
    "52XKdf1hsbcbVSQuup8YznAm5zkkLKtY7jwincpisDM2",
    "52bkSGSRhUxXw1EFMv7q5BZ8n9huXVDzT4PW1RD8ofZ9",
    "52pqYmgLSzCz7EFckacHX3XmmNGVHxGWuoRLN2aydKVo",
    "52wYT2Fy1ck7r5ANPSD9kWKmsgzjaRzoKCWYKwbiMHaG",
    "53F4Kf8VEDTSFdroKJdNrHXkT83XbqpptUbK5d9BUK3X",
    "53jWknuhWTekhjLwfi74SqpMPkFfHng67iSYruVeixch",
    "53mxc4SNedMAjQznBKFYPKtXvsTLeLGiMR6PANwLZu1c",
    "53nKWs8C4GtuzjCZrHr1AUh9rHrwLTRQNY22sQVsQcRA",
    "53oZWkVwRQUWbWA5cGxBn8NVZHMAQc1dtyYvkbS6dfFP",
    "54Ghvi6uL1p4xGW3ny7QYLBTuthivw8XrP6KsHr6XXba",
    "54KZiQ9NTCK5FTPAPChVvW3A8FHDcJtY79FgbSFMhSda",
    "54eHEVkLLapT9Y2MmbqmCAUrJvXWZvrQHf75Uc64CG1q",
    "54f6rSoBwBWud113PsoyKRvzobkoNe8VxHrwMRSzsBPp",
    "54v9mE4oYik7dhdXvrSmbHXiosajrJ5DhSAreQoz8D38",
    "5515wAkC2tZtfGa3EZ8QeMtjNtK1HAGe7Z4kABHUDJm",
    "55EHw6nB8uwqoPhaMvZCdwv7FV8ttMCrqa2Kao4cYZmg",
    "55YziaXWKgaxSBMHhHUz4kj19iJTyAiKQDZ4QrA29yFJ",
    "56WFPMs8nPAtqsn2sYZZ2jqLuTFGsA4GbFhdzTHum9XW",
    "56kNzqZN5CdLfRCLPsgzaCRzZpyQoTnKxdDdgHsnUk6h",
    "56sBpNhprNM8DY6ZQVj71aJxvhhr5tf7VghBZGE2XbPq",
    "576hhS6dtzAKGKiUscWZBRWXMBziSpEVtxGRZGpM9pjk",
    "57SBuBBV31PFp7P5TP6Hqc1BW7d7beSG5PsmXXmd5eif",
    "57XLfg1wRrWN9CB7RhVhxHL47vZhQAA5Hwm8D2XPemWw",
    "58dGqZwFP14SVtG9W94rANw5W9KYjW6HUVGT8PKmgmo7",
    "58hAZbGkC8vvTw294MtHDn9rVLt15nZQ4YoyHJ5NFkSQ",
    "58odvbhESy4RkAQovQXrZQmeMPTPf8nhrQEMcx7xf9Ne",
    "59JWpEg1FWxTdVPdgTP4gcJZThDWyR184BSVdTrRJ9pR",
    "59j2XNCH3bGMztdYDYr9akw2uz2YySSzBZzDpY3Xb52Q",
    "5BTKK25644ccKuYFvuBZto91QxWXy5kBX9riZATNy9pU",
    "5BgUjvm5QgbY4gUYFposxTozs5iddbSQ9bDtAEgrcpaJ",
    "5BqMmSmcPcSN6C2fzzNS7XjJ1SJCEykbqJ9yjfCQGKD3",
    "5Cc3ZDTmUyqsfZo1qkujuv4qFd6X4LhGnWkRLeBv8SpG",
    "5CeZP51tFC3rio3AcbDmCtmoyUDYEetESKewxCrvqrYc",
    "5Cqj3TJmUFJK1N5GC4XVPgZGca8RGJN9yhQnvKX1cXQ3",
    "5D3R3vZRFcLxadXqM5Cwn4xCnsuAqeGscFP6voM9kNZq",
    "5D7WzbJK9nbsdFRJFCCQhGH83ZgmfdYmdaJ9JzfpEnzE",
    "5D9fai8oMfEY6kaUCLE3HfJYhrwCJfcupQpcQYtRNvC3",
    "5DGy1dC2PTx6yfPcVugSh6DsZiNB8xEq3CBUqrPmXQXG",
    "5DdWY6E1BvHZxwXQYGsfjdsD4LnQeKCKxgEhfTUrhwUd",
    "5ECZL1vkr64bdmLa94hgLPY2tNpSZY1rvWuFt7D3bwci",
    "5EJXsagg9sm3LRu7YBcMESy96kdZAcj6Uy4sTyZ8Cpag",
    "5ExpUbG2WGKfJ69adke9JYpm5MXHu7HgRkndNW8S4eYC",
    "5FE7Y4RDweFaYHxdvcYHZJj2beBvxEAnQZfAaFdXBwJf",
    "5FtG5k9WSrEuvn3iaLB4agcC2D464AajNnPMbGuWvJnj",
    "5GN85NkZXxcuey75HtNwSQcScctpBwMi43MjWUuLYxwZ",
    "5GXZFSQt3dCSAwUVR8jnNAHEde4hRJJba1vmYYaabo1i",
    "5GfF7QHTrL2jTFF37jhwgX6QUaEMGRHc8CUXKbRVbAQh",
    "5Gh6SW81SiDsMwpnDf3C4EwYubG4K2w8w2H4hdRYYRDC",
    "5GsKaK1RWU6z43uYm1Vdvy63eNsd9JgRqB3p7951aYpy",
    "5HBhvuEvgRZ8A8JSaTrb7TNzzXScdZLfVam3hr1BPvZG",
    "5HV8w8y7UqqKHnzb3P5QhFLaswBxuauQ8iaWjZCvGZmN",
    "5JEMkDtZ3HxhcU5e7Z3BorfCcPB9Fb5q7GpijWt9qXu9",
    "5JHaeU3Tr38xb2iiqbGyxTMruWiVm9vixouXexgiBYhw",
    "5JJAbwbyhMU5xNvpCjXELhPQcuxPQ4NgqY2RJbTD4ZxH",
    "5JpeQkugqSp3s2DgRK7uHzatUSieuvxLoozAdS5BUt6k",
    "5KA7a5Htu4WLjPJXLabWB5u7MB71pDiLFMJgNKRQFiSm",
    "5Kv2eNCfbXmZJYmSxejVBbG2kFbH6FiugyArcA5jpUjw",
    "5M1JeczTo3NyY8TbWCDkqH23HWVuv9MNmfLndnDtP4w8",
    "5MT6jmWTit1DvQFRvQqs2et1uXtrqwabZCX1QZNhwe66",
    "5MUQhxncoaYQ49YqvoQsY3F2WZycizst6Yd6AEvSsd3P",
    "5MYuaHmndgBWZMJVesjCvT11uH42Zr2SNrbxdsM3ezBm",
    "5MdijQ683ftrpD7cqwjukNuhPhBDDL1wCgrJN4Dah8FL",
    "5NPNrKmHe4MvAA1oteyK1jedVCPH35UUjWxPVivSMz6d",
    "5NyjgXogWYR2wNZu77N8h2fzvV3MemXZUYC4LhiUFoPu",
    "5PZLcKwor5oSKcmAcLkx5R3LrevCd57581fpTkDyZL33",
    "5PkUDVzZZakxjeiSr5smzmCuLvTg4eD6x38jNBc2nUKs",
    "5QAskFXxcvVkTdvNTVa2MfHrLFErt4aLrvwFttr1Zm2N",
    "5QiZR4vhbqqcwPVPbf6KKk3gwBD6hCPnAnKVuCSNezeq",
    "5QuEdRun2osRB3jyJ9jp3uQLz11P5cmXJuXQbLkV7BCw",
    "5R6V2LNMcwueJ2mkSSyqDcPHdmZx64zKzcLXFotkYgFj",
    "5RHJoNqkTYKqJC6iGALBBHgRjAMGj1NC8vD8hpcrCeLa",
    "5RgGgnnEg3doyAiJeHGzjyFhgri8Z8Rv5zGC7EDSbXXp",
    "5RqLZRWmKGV5EDgvyZW9RDMDqYWfGoZqUtBezR1LQt7e",
    "5RsWRnWmrUQmDtVHPVmmKs5nFo6FP5YxZTKCYDuRGvQb",
    "5RxmYvX4QKTvU9Ue7LNcJBknBx3gaqpom2Xtf3SvHXWG",
    "5SLaKoa9rmjja55zY8PE4EcjtZcg99hSGw9JHsmqd55B",
    "5SR9YLTDZFvDErrnSK6mpJJC7nqAyqwueUwhYVpCp1Aq",
    "5SVTMVBya2rzLNG5eLLM7Ac7d4iWKvdFaLmNHzSruKGj",
    "5SZkehHhp3mRc8iBET8LzrZPP1niyPqZttS6XkXit5fV",
    "5Sgk5VLqJDnvs7ySg6LZ2DuEbTAtQszuAwKsRePUjQi2",
    "5SorGjWXpCgNTLvi7wo4MTFiBR2n6x9H44xUjq6NieKN",
    "5T9NGk4fNf5XCJMbD2ZqVekxd5tTxNmgQRV5HTXmmSu9",
    "5TKfJZa2R4GFKPB1YvHcAPxrVKCw4vFpd4e568yKJuAh",
    "5TV8VzgPhaWf8mp5eAV9QeGuTdUewhvB7VhpNgRs4s7X",
    "5VL41ecTZutuXMqdoQk9eEG5UkoMwggUdiz6SQDKW4mG",
    "5VR6BepYV3uR4ZKMrfS2yLjqGsvADpNZ7SN8DooxnP7C",
    "5VVSDmbTSUTezpC1GeotpVsU2zBQStzuSepN2iqGfVCw",
    "5VXnDHyuEK7tfNPHzyiQumLUYdXqSCHGrFC9qo6ESkkA",
    "5VouWYD9orbijQDxx57EqJW7R9LUNy925eVWBKCzj67Q",
    "5W9tKeFkE4MyaMmJo7wz3FN8VycYywVTRmGXCUiaqtv5",
    "5WeJHPx26xhpu7ejobbrkGP56r4JsHSjTkLW4UL4HTTv",
    "5WfViPoj38R2gPjeqgLS6BRjRGFbnfEV9xF8f3xgLuzb",
    "5WoYd4GrySBZynjC2ux165xHnJqcV6yaLys5o1ZFE4qP",
    "5X9iNcEUoJwCjFJtAcFnN2RmiiqqCA3sZDsZHpFJMrvD",
    "5XWFDfHoFMw5Rx6bu2vaGHV111dUqgaagA862byBxgHs",
    "5XWUaXSKbBa8WFfoar21wWa2DibrKAziMeX2TRvTm2A",
    "5Xa1d6tVvMfe441V64XjBL3sMXFNykmwPit7pHdtWFqW",
    "5XpYr6F8SA2qYxk3Tw5xsd868ff6AzSgv3Jmhv5bvopV",
    "5YCQzTnv4L1dgFoQ12r9TuUBVnrsE4FyApPyQRnaMTTe",
    "5YWcd8SikVgM7D4CymtyC5tAjrRmEXK5PH8GWAiLZize",
    "5YiyV5rXBvV8AJmXQjuQ6R3sXFjyhxEVbN1KpeVC8bgF",
    "5Z3rCWUWQBpMiXRt128HSCaApAMKuU4J15AySQUgpXca",
    "5ZKeFhRwU8bvDyQY8MWp1nYyQAGqpZoJmVeDh5WgKHiw",
    "5ZbHEF3hF87CaLQhR32mLqXPiFmeC1xVfMujT9TQ6V1K",
    "5ZbSLuC6P7owqo7yq3UXGcBiqMTfw25EpiRxqPNoTmtd",
    "5Zhwo53Qj1yDuUz55EFsUSByhLRrh2Z3DgbXjwvoSsSh",
    "5ZwxbjDhy6gkS8mB25sArsTdv2BCe5uYE9eyWWmJ53mP",
    "5a26hNDkY8NDskDmAKiVgHZuLwXVpyM1WAQzaKPBhGPK",
    "5aToQUXQEuFr1jnUgHpCU6tEkvn8vLkJ6Yhtp4Mvjk4g",
    "5acnRXwghQdYCwPKmDeuzy4y5mDDzxgDot9fX8rBpJJT",
    "5acoFhDYQ5R8uYqV4vkowrMVYhGJ7FavQz6H5WensXxf",
    "5agHU5Do1DmBgkfKwHaqT72SCCSbrqUpqKTzoLbwVvbC",
    "5akxc898xfuAJrX46DNuWjqRaJgGFu1h864tsVSMeh8q",
    "5axxY5XjMuc9wPPDLnfWi5hfpHJpGFYs1e6ochQnw12D",
    "5b9n8cXaCGFnfTKeYaq5kTt1s2qW52HtjGfqnFh6Vgfd",
    "5bxyYYLuba5Me9vCWAfm2PziyrgkpMiDYBz7fVRfaesg",
    "5cDMdMHSkfReo4UNCj5wybao6nwNTCRtxLRkYELdhFYH",
    "5coFvZnHoK7nivy4cprfh5bgjXmWs9aJfEYbD2aLkZni",
    "5d8FrqrHAcmVmVimVb9cZeeWmqteqQuvrG45UT8Z8izi",
    "5dEjRJP2e7cZppUVj8qPCJ76uaRTW2dKqw89wD4cBN1Q",
    "5dLLTS1KLqvJtgcCMvxdK7GvdV91H1hKZrM6s9FqypZK",
    "5eQ6JHmEaPvvEJMzy8iQ8q6dUzr36AFh23YugV5r6SRg",
    "5eYoGRqYXfFGLLpkoDywUSUf58bUAJN7kZAy5Tvyi35N",
    "5gKToSfrknPSPGmPqXXDSBuPhzD5yS3z1gLkLytkMECc",
    "5h866oZChhaGqo89q2myH7X3Buu1CprKYFf3azJDqqHJ",
    "5hHSGQXzNceRX5hXuR6kovqS946qxbGeScmY7BF2pk1T",
    "5hkuCnbaKjh7uSAjaSqCkZPNfDanY2cN86etK36vWXwn",
    "5i9y3AHUQJrdmz1MgBYJPudUB2jBd2XFAgYDwHN3pqgh",
    "5iB44TRbboZVy6Z8DovQbWGkvCF5dQaNksV9qjk9JkEk",
    "5iR2EYCevrsAn3K9pnVE89oyhsRAeoBTQnhHZ2Jpwib2",
    "5iiPbC1KaiiKB1KoheKn15NhbTjFyT2CWbhhajZsWWAE",
    "5j2c8DTsG2wQPwLjJKTfBDAtxzc6VzWGsG23G6YwtbCK",
    "5j9UFdKDfXECky1mrQkKx2xuUmWrQvcST87jhZJjzW5w",
    "5jBFrXHyJ3MT1je8Q46dwjbieHbY2JjLrNJ9zRWr1vZ4",
    "5jRsjP1t9LtGhvY9tSpUuE6dZhcaiqB9XLX3qQBdcndW",
    "5jXt9jMZshpJjQ1s1zpJo6gagazkL2qtfLwSAJiUqcRV",
    "5k1Fr9MNmqfDB4j237bCnLmkNcJ26rT4N1ohvjmMSSod",
    "5mrohMr4w9fsWijbrh8vA3RUeVNedn88QGWvrsFrvg6T",
    "5mzz9M9aXC6H3vkSugE3rRCXZKmvTBG8gdVGPE4JJ7hU",
    "5n2Bkk21r16he59uBvgGeWDQnEU2txscpaK5DfTEteQQ",
    "5n9g1d5U2AbygmED3Fw6dXynpoJp89nhw4ReVCRQ4ZQH",
    "5ngUiTtXmeRguSAs8iMjny6ACyNd76XLS6E8g7ZoAW9i",
    "5nncToPvgSHnJeQPedjNhrsKcV4FgUGPQ9CMwRc5p5Mq",
    "5nqd4Q7ytLF1VG1D4ZU6L4csfi93Ev79B4YFFAHrK4nX",
    "5o1GfefbGjpyXDPLp4Dt71WCDieHxnEBNT7QFXmPAXrK",
    "5oJeWLMb4zpaggMMEKu2HP2udUhfqekWTnB4o9Y3Ct7P",
    "5oajGkJJBeTZh3FtsGLdTEMdbfyQdUcVt5vpuYwJ5KyT",
    "5osmuJKRWx6enoCQHnbRk26JyBYP7VsxRUG64s7JpV6Y",
    "5ouCJoNJrinZZZRwLyb4smDM5m3u5J5FyQ5wd9bJXzgp",
    "5qBCNuSzS9HC7Uzpep25a8xvXah6ou5JTHDGqhVygCTQ",
    "5qZ5eAFgd9HP6q1XPE2baQSUvR33ctJG4BRBVe3ofGYf",
    "5qiTFFFCfPBoUc489Z1mhinHct4HogsgxDeSsko2HcXW",
    "5qjoJo22ZZxU3V5opRoMXAXS1UoZNa1V8SgZwDdrd4bi",
    "5qvbgL6yzt1JScNKjFHr1YNubK9ZZeua6d3ym6MuFUZ6",
    "5qxC1Ct5mUaUNydhTH9ygCJFLM1MiFpbMhuoU6Lv2wMj",
    "5rJkmqoKuu7zb2LaAq8Uv3v7mXFmTxfWWfBeABmSnUyy",
    "5rUSDU5NtTHQyZspmvBv5Xudu4rxiVA2xrHfq3F8W7nm",
    "5rcFZxXHGPoYQhETihwMmDMHFCrq6ZHiDzkJT2M9nkKV",
    "5s6s3jbXvpWWCr12GgpsUD4cKqAgNtx3kKbjuq3nywji",
    "5sR1Y1ELHDR3ni9N9Sh4WhjKRqj63oz8TwSXwmyoSyYB",
    "5ssX7x4NZUjHnZ1bcKwdcxoiRAY8w4ojXPXLZ61w47sr",
    "5t62iPsjtLhR9ur1Vau5QhPWm2QXfvmLtiKe5WzH7Wfk",
    "5tCAmuY1hnjzcKKooDHcEeMoeZY1WRdkA8H1WWqkDo1b",
    "5tK5S5gNgB7PxHDxdPWKcYRepcnLAKQ54HQQKxjiPPfm",
    "5uFFbAJqsQh1XuXZBmZeQzffCZUsoedywKWHVDyGEevZ",
    "5uGB5pQ8c9u3xFMAytpLLzVBUnad1U1F5XjMhtWqWwLK",
    "5usxtHZT3cNrDir8j62kANcA87Xcp8HD2nudvcJBBSj9",
    "5v1dHSiLe42E5Zi8F9egCF12oQEhaBCNcUcHk494UuEg",
    "5vYLdh32XGsPoHA8aDiWhDTwjLZs3KQ7i5Q5Px4i6SUf",
    "5vtr9CqgAVreNxhNAGApyfRbnZuR98geHq8frthxHXfZ",
    "5vxzAU1C9FQbHdvFXSThnWVb8cT2z4JLrnGemjnYpnHE",
    "5xRxGKWLQx2hyqujdYYLdZ4kcH4NVavUpnHsCpdhrMuY",
    "5xfPWtU1iPWfDorNagktVvr56Nd1Kjx951jANYgLWVP9",
    "5xiVJBxj7ro5DZbYQe9uDVUXKSurvdfxeBExrHZHaYdG",
    "5xnarrzeTHN6sm2pt3og5v5otDqFmSTpRhoMehRhNRTr",
    "5yPqMLWFgeV4wAShjxV4anqEQm94DQeykxgvm1FxmDmp",
    "5yzyHG3Gaoy6HEo8V46rboDBzYjJiYws6fnKamUS48uK",
    "5zUZKhQSCqitdqGvpKT2XnuEofjtueoBkcXj5Stpcvbs",
    "5zbqH6d9EQUFZ3Pap8SRaVwBdw3zR2F9FJ6FyG1U6Rfj",
    "61X6zQmyZ2H8KbVExQYYZEYoQ9wX3VtGwsH8U4qmrxEB",
    "61nt3RcjdjePy65YvLDVjZRZFzUJPHeCvcxcGj4Ds8UF",
    "61xVjQojB2nToLrtxsC56DQqujG8GyzBopVjFMo9GHoe",
    "62CGGfgFXDtUD1G2Jk7VbEsWmJ4qSg3upvWirBuhskCx",
    "62f5fShELPB5SUfsHtCVfHKZCKGWENcTv3b9JvePEiNH",
    "62vQT93iq3FoVV3hGmAakKVzbq9tKnntcS7Rc8v1P7o",
    "637NWA9RU6pD82hLvBGR2fRj1PW3nfmaq7pKXYNFSdSs",
    "63GvT65M46fre1hFdxa5DfVwZm7TN3AUBgCgMeVRWjRE",
    "63St5CfqfaxRQ4PPGczi75VgcWg5JXQsMoSjH1bBHfYp",
    "63h7BSj6r33WKMEyBbRScyjK97Z5rKksFdWzh7wgXqFc",
    "64JdHfWUbnzEaFJBU1NEHVvcnVNKSuPDKUoMCKPbKubV",
    "64za84XCH3JPaufiMb5FJYbiurfdCkbHvwYCYENthhUn",
    "659oXnLikdqavuN7osPwBXg6py3GgeKBaZj8UXAixvDZ",
    "65R56WZnmV6bkxYXbgczcYPft9Z72wQHrNhRnBv3t5yU",
    "65WzhJBCndMwhaqYLy3qTREyakqEeVGbwS2DqFwo2r63",
    "65sjZgBY2eQngYauBNrQZrvgC2GbenjAT4tU5TH7GrVu",
    "66MMo64ULMXd7PX1vaLxD6LJCgwzZ1RsCnJoC7YYicwC",
    "66fVyjHiYbiMfT1i6kGCqb2KvRqLX4kJEXMECJ3zJgW9",
    "67fqvjfcvocQYxo6eFD6EnJEUL7uvjei6oT1GGFEFKHp",
    "68RfawVtUJiKxuT158o1XQC4KFwmgzPf66jdpJ3dP6p3",
    "68Y9hRE6LKZnthDS9gNSPfJmFHsEQ6FjJqvH91PmGQq6",
    "68qew8CBgBTRpmJHG3G3QRbLWg5P6SGMrh9MmVemw5dX",
    "69LEnQMh66Y3ABrfLmYNVvhuun8YPwPos5oTBN25gyS6",
    "69oCxj4ZQXTbsofnudqb3CbiHnrgBrSKdAGvujaDv3vc",
    "6ACfe9H3XsMHCW17VsvBAzxP1weYfUDejznzHCeMi7gu",
    "6AJUBce9woQegJwQ4SGXKtQ8Xhck1njygmDSuRBen2RJ",
    "6BDCnb74Kcu6JWvYu7PGYec8vfWgtyQxtQ23uhT7ipa9",
    "6BDomhcaMYwkekt3FNMhr8uzgK5K1mZu42JLTRx2YAbh",
    "6BNs16VggADTLSQgHavfBC4VrRhggHkWTtmUhDMzChKi",
    "6BUNbzKdJDCQqd34SPK3Y5P3dcDtngASLyr7dZkTguhn",
    "6C3SQwPGXj2JCg7JToHyQ7pxSRPXV8unQNxnwLUYXDNK",
    "6C56obH9eJnQq1WnRTt3DT2Wyiwob7CLU9DGv2aAbrdo",
    "6C9b5kg3Cdeqaj32KSdEAkjVxX44ctbsoXzmkni8gwMG",
    "6CPEzydU1REHoy97ABvVamAVS9nXbxgikJsSsBXawgTT",
    "6CfW11eF1PKweGqXD7LtGi2yiTFPBmCJmS2xgTLgoYMr",
    "6CgsDw8qRoUqeWCSXepkYjVqXrfvBMFQ7zmHAJeDZ8wq",
    "6D8AizkTsfcYY5JkWmS5FRYh7VawRkrWYPvpb1V7TSPp",
    "6Dx9xgDG4R7fPbt9stYfphc4iyCDE8BCg9E28M28nmyW",
    "6EBGdPxcKBYHbmkeppyyDBGHkVQFbupoyAopU6DY3esd",
    "6EUY2shSJqYdY4Jivh8mYfb8h7EdN7FPj352XdLtUxXe",
    "6EsmmJKrUAX1ig5byrnRkUggSCwFdeg7nQSXBbUcDyyn",
    "6FDTC2qhAAk68KcwwMyFnS2tcaTvkLwe2XNyqiMH7Fr4",
    "6FM1gTxXhGvNXUmyHUYkr7kAwJhWTGQ8xxYBdEC61qPh",
    "6FpA3iTg9eBEGzdtJs9ALDVDjZb79tvCQAkCzchtpasR",
    "6FtBtPrhQznytcJMnPyPsiv9XitbmoBiPufG3w9onMT",
    "6FtZMPcfLvTa4SrzYkLyBETvhzXtSrkUK2sqRXZY5otf",
    "6GCFaTkChSHQFNqeGMeoKaxZyzsAZ7Gk4cCCigUgD8b4",
    "6GxV8e26uFwrAVvsVGcbjumuibNvCrsr2GNuaerBoxvm",
    "6H68T45UB35i666xojTwsezKU8EZ8piy8f2rFUyaqhvV",
    "6HNKmbBDZq3wVNQmZUFjrsBGuosA3jiwB6feXoqaqf5c",
    "6J6MPFH9oqKk2ofpjtLs8Z9nonMvkETXZ9e5krQkiJk1",
    "6JE9s7Qxoe6EVowE8BBJ447ZTFC8tP6bEo4RuEE9hByd",
    "6JdU3i3ekYupfVNbDpAAKpwJLmjAyMRdB4n4EE8j8ZhC",
    "6JgpsBCCQKLh2GxprcftgRsZ3s7HHFgSzevvcJMr3VPg",
    "6Jn2mZJCPq3ZECQF3ygPQpBSDhshPDtbYoDciku1mocw",
    "6JoJDTJjib4WquqsSUhjsa9MnXnhkjjRhW55m5v9ZE5X",
    "6Jps8oqvJoE5FoouUVnUFTibkoLvFZwosanNRhfBAy9A",
    "6Juf8GFrp2ZdHqs3nYNpDRcE8xs4F3dC4iLzuf3Nxmun",
    "6KdH53vn2MoEtDymajSrEfvjycXV2KaD78ZuLvGY8jzo",
    "6KiaWNffVMkpj3pqWorG438UbCC5egHACFM5s8fhtsnw",
    "6Kr1oaB6twm5UToXfiXXrxuRRdXHqLt7evfYTC8pFZRF",
    "6Krgz4MWpeZQnUT61FrZZMwuXWx4LeddrdAX6SNf5kcL",
    "6M5EQHYjMmM7DeKWS6DoHTopFhbjhbMeTTpMgMaYYLoL",
    "6M8BSxi21G9QwrUMdqAqfLqCxNE3KBw5ndUG6yYbJwqa",
    "6M8qEUqpNhxDSW6gwjCuBUzwFtR7qD5WoSsS9AAXKiSf",
    "6MddDntmnrWfkSeBZ5YWhxiy2gAZjB8kdkHUcRgPqeBe",
    "6N5guHrWcRraouaYhkbsL3sw96t326qiYh8tcxLCcDgh",
    "6PWZxyV4PmJB4onsvEszvdQ9s2LynV6eVMuheQ6NkGkC",
    "6PpNY2wjbUC3ZevUYsBFWHQxxKNjg7N7osVADAGiNzvu",
    "6QKRtXejh2DNHCkshorMgUS8BX8Xbz97uBgi8bwhXCaU",
    "6QL2JfjaeQmBo8jiG5jpcjVrM7iKhq9daEhUo6XEEzyL",
    "6QxtAD7T3RQhWqw8o65QDqh15iRdj9VhhHaePJzmP82e",
    "6RBHh5Zs5hMf2pju1JFpfNrqMvLVaDDXEuJ8Uh77FukS",
    "6RpqTfXYWYeHoXqrvwhcg98EcfE863rqCZ1nzTgqW2NP",
    "6S4g4ZETvqyUKamHsLykmwUpSHmyUFsgqfUfezKnQohZ",
    "6SDE7Y3fGGfg4c9k1eN1qAztmgsjdnJvqbM8FFrXmhxy",
    "6SVtn1uDybPegbH8dAXbhUG4T3LKB7jWujThzKjVoCNQ",
    "6SphoczbYM1BgMvCkfkY8wVqtPPFbSc4UcqfMMJDBcdm",
    "6T1wqT1ZthJ3X6oJQLEXwUxMnMkbWt8Pqmerh4wt7BLy",
    "6TDsbJ9yLbv5Ekw19qBRgugMbocTnkiEw51bYa2WYJx7",
    "6TRk7aHpdSyBDuUenJtCR3gp2Qjfcs3Zh3fKxZSRe5LN",
    "6TW7mACNeAAN6r8GXc7S5Y2K5oVogEweBxpXwqHQ16rH",
    "6TZhrEtppS9MFgWKxodPrEVvJBEfbM7YasE8LKbsepXm",
    "6TfCPQvt5FeorPPSHFYySTmMSDinyQx1TELtyrfWqufn",
    "6TjhmMamg48SutLDPwn2nn5on9zj3sGAf8kqSSY87Yp",
    "6UbGw98L1yopYBe3zPsNr5yzM6zkD88bwxmiYca2RV5c",
    "6Ue4JTHpp3jnsLAso3cd6hzRDgzBmX5vfmAhS6m5Jy9F",
    "6Vb883cT3qJ3cnfMebVuc1DHw4Mjsqdc9Nt3spy2qeVJ",
    "6VsmzTnNA1YrqZUwSoKnfqmM2pT5WCDwMAm7ve2jjZqW",
    "6XV1r2FrtnBDb5bikHp7opkeCULuyHxrVA64LXvHPPcx",
    "6XVPtN8UExGdPui19Z8eidLWPdWLcoAfvzvk3g7yEV5J",
    "6YDJxAq2NKRZn2WwLMSvdmj9gxP2a24sxLZD64XYZa85",
    "6ZL9sB3PucNzJX4FPvs5mA7p7ZnqoPYDs5S1UQ4iS5eb",
    "6ZQvoSt79AQJmKuBfLhppdksV93xyWPXyaeEHGrcZHVn",
    "6Zv7hzKcTz7HZRNRK17RrJX5HnQi3C2LbpoZbpnaZWAB",
    "6aDdf1vHaonJnGm8znweK3ZWtqRnnEK3NN46SvNuVaXz",
    "6arFQUaG3RU5eK1Pm2JmckajwKqkCnWZXgMyvE6oDNV9",
    "6asDp1erXzo4SqZWEX5c7jEvQYAirP9BmHhqbVGz4Vnr",
    "6avR2ZhCBZ7BCEdLB4vJGJY4a1U5McDhcGoy5RvPQwi",
    "6ay7EFoZmpf9ytmRx882U53Cbi6JUV7jMhSqjacgm92G",
    "6bLP6ddCc21E53yMyZgtwkNKrbY6PDmpuZTQuucdPPQR",
    "6bcgwYRLMFdt79KRPJJaXZVk3LHdvefDjw8QhpaJC7sr",
    "6bfthn3U4bdNRf3sbxvn62poX8iwSZdKF1956w3hsSJx",
    "6boeodEvNyzKRj29cWgjjURAfnTA9MKYAT1qFRR3uJdQ",
    "6buvG8gGSABf89bij6N5JcxY9jitzouEb2K24Fj2T8Yu",
    "6c4uuYUpD8MUrW7PnLjo2bLN2xo9d6rTkrBZtscJPET9",
    "6cKjanLpsV3h82mrcsmycE1bhAw79s6WXBWmesYd9rD9",
    "6cv95fzDGo7BUVYKHY1xWkdjFrLN9rNtxYmTzSNbxN1c",
    "6d1K3x9TTuX8fSA9NVRe4wyVkKuzQaNKQDVaxjgVFfAu",
    "6dBoNdYPFoMKuDSQXsPCNJHZHtStUjHqpZ7LjrEi87Yd",
    "6dMsLF1yfAhCUKLCS6GSFAJhkJ2DX273JpF8kkVFDZ2K",
    "6dXCqcEjHZhSm3oTeNZXWDw6LNr5g811yBSEXe9LTzKZ",
    "6dg8xdeVcpKdrN9D7THfsnThNJWxKCHdoVRSLaaY2zVj",
    "6edxHJ8Jp1TWDQJbAJfC9dm4QhSUVpb81wXrRmbsnxAt",
    "6f5JKwsoT4CNzyUGNXennNBhpeGBUonLpvogrWXKdWEm",
    "6f8sFHezyVW758Nn4fiee9ZsBxpW2sCMUgjpaxG7y2ib",
    "6fpQyH1tnvHxgM9Jt3Vze9XQi5HmUjQUq9GVspTkU6ah",
    "6fvgkFf8yx2gtPvSz9MVtyggEzmfefthxSJCVWUHuGte",
    "6gFTBBYfM782pFRbi9x4Tx3KqpH3XoYDgSJVGhUNq4aK",
    "6h7q3VJt8GF9taUpnca6fCUK11ZGR6RxpbXdNB4DYuhR",
    "6hSfre8ZnV3gxfC8jSmuMP31iejLYwkeecJ1afHatGkc",
    "6iRpAvUbECp7AkFSgd8HFKkznLaeGSTAY65wBsDW6gdw",
    "6iTbVAirCaJco6jp9SM5aA1jiDbE8WgRHH3woypggwqG",
    "6j1eBzQySta9pDThM6JMGdnoskkDRBc6NnoX64mneP9c",
    "6j1pVnfwd5tm9nW36KpqHWKaidURjQGaUDaYT6tGmK6e",
    "6j3VWieM9vyw27bbSyprQy8gxmLvufhf5ViZFvBzKNHc",
    "6k4NCCaWwXyb7cf6ecTzr1beS6DUM6bvA3ep9xkWDYfn",
    "6kcdhforN7chPHBVCrokA1H3VKYjsdJQGFSu8ZsjBiME",
    "6kdwCLYnodgLvS5DaUwiNkEJsQY8tuVhWqG7fb5qJr1Z",
    "6mR6sBPWUCSLJFKkdWTNA2AmZ9WvziYaXYqRY8F4HMnS",
    "6mpYPhYSvqG7A5UNbYoBA9g7UxDpin1AQLgMH5sdXJpQ",
    "6p43orWzqfPhVk9PcRvqgTQ55RP9j3Kt5WJwasaKYJYh",
    "6p5NGyNpbmEqPsYd9M5yA4SHze3agxaUQAwS1F2ZnRF2",
    "6pRgEwEr4prGQkBeGko38pt1CYSfNVSTwtPuN9YaxxqF",
    "6pWPTqbw5E9oZdrpsZC6RFad3x2Hjd4742UXC6DZWZNF",
    "6r7VtrFpHMduXHKV1UnBZLPkScnstKBWXnE4cm653nNC",
    "6rFHyb57jkDA2117TGpbZTdubX3sECB7nBRPkBYVPUYz",
    "6rFr1tHyvnKdDetKr8pqo24q8MqdNHjadByYYZrJmMpu",
    "6rHqUs3gzFfkmkYm93MV2avNKwgJadTj8C1uATEj4Tc3",
    "6rnZXrpijYGLfeZ2Wh7N44kdZVrYqqASx7VP8X12dgQV",
    "6sGXACBudoTw2YMpa5LbeKhv6BVirwE5TYTytbk7jLeG",
    "6sQjSdQvVbFWNiMW2vAcoD1cHXbN8fAX4ew4xvavGR3h",
    "6sewgkgJj8gzY89zhiGdSsRgRbkdSNXHwkz66ogH5iU1",
    "6t6NvDG9xsfAopznjYaMYEUMt5Tb6MJRMGp51wv7GK9E",
    "6titn2kj8mQMd8P5bWCFBtwRK6sdrHRGNh4GoBKtMPmF",
    "6tn3hsEPMRupb7tReZmaAyf4SVSmjZQ71823DZDds2PF",
    "6trNCKfr51ciMbwdibXBEz9LWRMXC8KmLeYRLvSDqzvV",
    "6uEf4EY84en7JZeZ4gdczkDoBK7nQQcJF3xpMcc2xRTK",
    "6uiddxs5B4uPAUUgMUz1NWqCVpVAT6QawLSk69mXvWfo",
    "6v3uwSY2wWPWiidPyNqMJxH9FWDFECgtrzDabvfSuxAL",
    "6w6KTfPkQ9r51av9n7keTWCVLEH6XWDQmTpvYc9PaewF",
    "6w7tJUZVaZYRujq7rdQiFwqUCV2AafRSUdZVqkbpF8u1",
    "6wWAd3oiGUaH9gd61FeyHvVmGA7xxNdHiMbxPr5otgz5",
    "6wbg3fJK9jN7kPfjUbXfoTknHgx6AkCfLpsryhij48Tx",
    "6wsdUeFb7Q2G7dAd9xfjRWaDL4KnPc29eR94CB5m6jwj",
    "6wzPHkMgVVc91MfEJKSPgsaE5ypQijA5a1GAPCBitYQj",
    "6x89L72DJ2aqn63CXyY3kbn7UEHKN16iSQ8dqTQ4U3sf",
    "6xe2tqmLGW49KQT961vjYn153Mg7wYcgH4co5mnSzfkM",
    "6y4eXh6suxjxuk5KpgPp38pmnDUVX1SzYRcfRkiH4khH",
    "6zR81ErJh4bww91scUokFWwnJJY72TiARoRKxJHmrGp4",
    "6zceTKBLjd6Ks1rxSVC8mZYzirCRoBsfwfBuEV4cCc2Q",
    "716rv7QvEFag5RodWgnbX6xM1bW1WcTw6gePXfEQpxVj",
    "71gMPfmhALPcwa7zq3uocyr9Q2KkwrrdLSDuh1kq5nT",
    "71phf5DexoDXQkntQcPqCWZ7JAb8XY6YcUuz5TFu7bfe",
    "72BRYr8cnp2Z2MHQgopdXzXnYUXW46PprYRt9yP9R16t",
    "72Ho3hWqwLMZJ2MzLpokLtvNThW6xn1gPWpXen5U29cr",
    "72R26ikTsdb9C2BGaSjtKs6ooxNFnqaiBMcamCrCdGBc",
    "72mzYSBSfbGPTPCv4VWDmGDwFm8tZN3xjJL9EdRSNtPv",
    "73LNUmLrX5584qszcH14P4fDceHJN1WgsthDHoYVAsnZ",
    "73Zqpt98v6BLqjTGC2qg37GHuQJVAMJap2Bayunpa83z",
    "73jcQDDAL8KpnHJe4WhsSUsC6WPpLMHug97t7kYsFxir",
    "759t3XrecEvTXpzracfiiV7dMs3a917iW76Jtnci8AFM",
    "75Kd5LwKMzQDh2czmHfrH45rnocoJ3Efn6mg22UFtPkb",
    "75NLaeCtQ69SkwV1uGUSUM5pS4utjvmMnufJZ4Hum9YF",
    "75s7fGfqyHMhhTbVs7WyXoyhbzzUCJkUWvbTcMsCNdQx",
    "76L3iUuvg8xcTx4iZW8dfHzC6YGVJ6tytPLtgzpoxxzJ",
    "76QNwczSXeUpdhcttzyunFDi3c5C1tMTZVe5VWd93dBN",
    "76SSkX5z88X7XKV8jtRGkGttMR79pS6QMHHdbTVS1za6",
    "77mKr8YcDBPoPsB37aXQRYk6Lhmondii3LGhNrupwsQi",
    "789eEXenXxYi6mvo8eVojuiovdYzDvsJSAq5ZLTjx1JS",
    "78fh3Lhfpk48EQZmPymKJoQVkkUezncR8mHbGA6FDa25",
    "78reJ9Xx1mVFnmJUfhjJPjs7A9Wxrxz2mLdQnd6ScjKZ",
    "7997h7CfN3Yab3VARd6ZTTzsXe6L4Vm4nPadFDj9hkFJ",
    "79TnHYkVZqDCTyi5TVs958KNXNVQioGPBmChFykfqarA",
    "79VSJwPJuZPaE3Za87UMDD9EzAB4xtx79kGC8p77dMTe",
    "79mqshiqa7oZNFAeg4ctMA795WDKiRYRRHT1i1AvSmE",
    "79pZw7cANuaPjT9hsBBtQDGiKsmjjAw94AKcn3je6K7Y",
    "7A8gia84nmJqjmXx4X35EZjap3jFfPG4vADLpFwXJskg",
    "7AjB8jue5hg694RyAtGHeqAYciQtvtrfcHxHwUCSi8eK",
    "7BgCrMmeiTVBS1qqo2e5hi6aANkA4XkFoaGxn6dCJ21q",
    "7Bqr5U9tQrewY2aUYhWGbaktLDMBZr3Yky8rX67kCDLZ",
    "7CCVBnCKeTB6apZMn3knbwsMKncE2U33YNu7tmJvNoZr",
    "7CawTBkhjEtRE7nQAj54oUDxVhpESvDHfdDydQS6Maai",
    "7Cbe7EqZMtbqrzfHowtNPCKVFKwfB2Req2YJSRUo9yxQ",
    "7CgB1S97LuNTHamcntr1K1uhuJMcFTfDmvtSViwhMwYX",
    "7CxtdqojnzBFC7PxT2Yprw3QcSBngXVM8i3ERQ5f8E3E",
    "7DSFXkY7KMZ9ZzrQTvK6Be7kKQJQw8YhsepNceMj2tVf",
    "7DmFJgoyGei1qxQ152oq2NsPb2eWregb1E7rXYtFrhG1",
    "7DrvVbwNWgTScK6UnYXSY3SpXVLdosATPqXpMWZyV1Hi",
    "7E9XuXB8ovwTwKvtbJaywbeDDr9kqQAtox3D5rFuMHES",
    "7ETVLN3ja8XxXsTiSfRZ9mjBG78zdanSvquKuzkU396M",
    "7EXCE6H1sdM5XY1w38UBbVAaFdbFmx5FfMXrSQ2eTeHw",
    "7EqF5pcZuBdB4qs8yYcfpgiUd5hvNmhhoufiLGe2umP3",
    "7F241UzoYpVNGbp1FWDjBVGVTuFhgU2D5va1X2gV1Jne",
    "7F5QHSco3WeoKApjcQja8vGryZVAjEXoh3dkkNdAdTCx",
    "7FETEMvBtKxR5RtJ1H2JyLwbashUk1sBLHttBGdTcw8t",
    "7FJxPgHMLedZJS3wrSkYtgVx3DsWqTiXFA15Bz8RVjto",
    "7FLzXUtxb7SLoxFDAwewtou2ZRhtZznYjJGiweXLxvcU",
    "7FVNDUaerbeCugvzMXpg2YEg34xbM6DHgWWpdZhNvSkn",
    "7FnnZWVwCJj36RKNApseQVu4qL7zgmHsPiwhrf1atAoF",
    "7GD4nV5ANmXf3oEgiPLzbXYa4FPM4U51jWGZrneQGRoa",
    "7GJpsBViNmyT9zkdvew6mM8jmHGSvVHX8axKGc8Y1suA",
    "7HWFx8Q2W4FtGdF8WfS55qL9M6zGpvR6Q3KpZsA55hiV",
    "7JBEpA1SfY9qnQ1BjR1ZuPJ94jekJjhC9ecqmLtbkPhJ",
    "7JLAEB1QHrSaZggGswrzqGH9AeWF3iqpaEXHSt9bvrMx",
    "7JY7dUCEY7ciRrqPwhhU8EGyd46kNkYGVFMD2cLd6mcL",
    "7K8YKDBjVJ9ExVjxvmaD9w6wPShC23xZU3AsjQvUF48K",
    "7Km8QJmUqBDYgo4fr4hHHMk8kUkJmTNz51oPfbUszeVQ",
    "7L6sPVBnUdU2xofAQF8FaRgYTz5DudQJ1cRKEBg3iu2V",
    "7LboFWj4f8PZSZbrGFePYmzem9Srd6FTG8ydvvfSgLD8",
    "7LjR9KUThGVFg3QkkzTj4Tx3Dp3P1c7s9cpz1V4QpsfT",
    "7Lk61f5HJEhsg6bAFL4RFdtYuqchXCzBwd1bA3aqL9BZ",
    "7M4eA7VwjUzKMsjdc7Ztu6BuAg6jBgYgfgdnptk9Z338",
    "7M8N2zNCdHDVScrvvv4H5KRgobkYYeNAs2e45Sz7MdhN",
    "7N6ku6N1jBpQ3g14epEVqj3XtEEh96QPYR21s1PjRk6k",
    "7NAvyvoFCEA2vpkEYvLsqZRjXKvgaDNcjt4ZWNrHHTH6",
    "7NFZJNDmU5Ltn81oAio2Uz8gUek92hvUXKdAh6BG3dPY",
    "7NifwDCkpmc61hXNKh1NzEjnjea7G3kTnkdnrBqxwxpC",
    "7Niv2fJpXhA1u9TGVtoT37sMV7kdjCwGjPLqQyR9R4Xi",
    "7PMH7tDVSUZ8Eh5pYtPdfDuF7QFxaStmBwh5dVwGa5ZL",
    "7PgdwzBQ3bzd5PwPwJCYsZZ5AvXL3riBQnpnazVdu7BM",
    "7Q5bLAmyNKzQdivWFLbQfow3QVMoLVVDXCqKtjaoWWhW",
    "7QCK8kYBSiAe8NzArkNppBd633FwWLZtYGTRY7o1A91n",
    "7QDtvnXu7nY4EXhRHMvVqqPxAZtMmx38b5GWRdNNzCHF",
    "7QLs9tQxZwnje4Ty1agecZ8V97oskfKFHhMy6tehioCt",
    "7QfYZkfvGn44pKW9ghEvWR3MbxLayeDKbaGYovLxfWQE",
    "7QzNC6B24BEfJHpG4VLhT8d7UYtX8LcjW2vkWViyrpgd",
    "7R2uMAiqJb58v9prWrkkP91CrxFNTa8PTjXinboHnZ1N",
    "7RNP5jr3cLWgHTFoVtTg1iUshMqAvoXg6gs7MqKywCkg",
    "7Rd64faiR1ottbMkfRwhpiuLoyGP1oAayqjrmxCrr8oC",
    "7RnN9owjjLnMRyjDc7DzYufNeE4XTxDAg8aCFx7Hf7QU",
    "7RrSNBUmAynwj3NhA2k65mu113BVsocbwEfU7Xt42yTa",
    "7S7HLajvhgCzurYXHSqNyceSvNKG85KK4hxjz5wKaSPs",
    "7SDtGqZ3Ak1fRqRjUhDRat2Vkg2H61z8j2TnwA4ins2",
    "7SjeBXJLUFWHFtDZHUKpwYA1HMJh5tsdsQRWr1bjsq2V",
    "7SoiBK84RaDWiyuW29DMoiSPTZMTBKR8sA4qk7vFM1Th",
    "7Sp1YLr2isZ48d8ck1gGuD9BxLkW8yC2Qsz4RSEuGgLk",
    "7Tdzr8PiSYC9Mtg8MMwjX15NDEmn1jsMcyWchqkWBotL",
    "7Tr6vEqVGmChn1ELeBmKyQvRtAqyre24B2XZwXUnkGeu",
    "7UDhTergTPdZDsAnyVVi1uZvrETdQ9fL1XssCD9ZVSPy",
    "7VQ5rbg4yKT7LNCFMSWX8rqYTb95W1UNzS3Zef2GGqvZ",
    "7VZCwLm76oz2miiJdNX6N3kBVGLFcVu4aXtyTxc1pzsD",
    "7W2dAx9QJPsd6o1HnAbsaFfYefRu33asxMcKpbwLALGi",
    "7W3cAuh4NiTkbiT9pjjHgy7kmSdY58FkXVFgm9q1RunF",
    "7X7TsJdvLhv8jFLAnfs2b8zaEJ33VokiT7wc9hYYg116",
    "7X9Ljx4wEhuL9KWcjDKXdVPJMj3eTj2rcT6s27yc72un",
    "7a1uW9onuoVUA4GqJux9T7KC2SJkgbwq4rjXWvtSBF9z",
    "7aNXAaRBw14mkHpwHVbPUWyKgDkvwDMQj7BeaPt7T9Q2",
    "7b74tLsoAm53Dy31xb6QGowCBwJ2tCjEkbDsVeNrgvNd",
    "7bBDJDAmYvpNn5Z2fggcDTq7H86TWBPrNPxAj4ondeg4",
    "7bRgSpgiDzLJZPQksPvkmK7eMwfAn5RZzaBerorgnhNH",
    "7bdHVp5NRvf7r3BmjizcGhRiCpobn9AKZhuSDWXxgQzc",
    "7cEH4wdEPEW76G5LsLV8XZGKM1dZxeLTbLPk1z1BbZrr",
    "7cEqqofJJS2toEcMpftkTZ5WRjVK1A72ocftxZKmTcid",
    "7cEvypSFdmJWTuuTYNHAH33NQfux2pP5mTmjhsV8jRyR",
    "7cGeFkK7G9UGVmtSEjL8YbX79vcGkGDo2Ttme1VZwijQ",
    "7cRZ5F32jMkoikxagJv55RmgUfXWo9ZaFma8z1E2Eh2u",
    "7cTG4T22JkincRjdDdCWdtx4qrxF6QC6KtuVSYUH7jd2",
    "7cabAHH49bwCRjg6PwCwnEiiHqWLwwF84JxQWfz9aZzu",
    "7d5XubGUhRhNv9eEDMTFDpWmio9mcxWrqK2SkS6NJr9F",
    "7dsTzWwuQrwpho6L1njCanPhRAjwTk7NBANtjzAQo6Sk",
    "7eBK9pVsjnrd3EcMGDWbYhc5svx1z1DTg6vKa5k3pkF4",
    "7eHoU2wvrP9toxCwZRYmjFYdH8C194yf4PurPWAM5eTJ",
    "7eRP37YjYNijAsaz1URKZrxEBTK1ACerYcfSH9xHhSjg",
    "7ehpnhqk9H36SYWyqYRKvr9B3LFdPdAJbFP8phcT1CD9",
    "7fWcJBEvz3wTX1KKqtDv1m9ex7m5a5Es5hHWHQoyTqmN",
    "7fgU3Mx181cXayhsBtyynez3PcxxhP56vg8NG1RdBWND",
    "7fnwPDnrSyok6WRVk46Gs1PgrUbcuReo2Wm5L8cNVSdx",
    "7ftnsnx1x374MAX1vkksmMvRx9UnaVpY6FibXaCiN7q5",
    "7gMjaVF9sYY4TFWPLGXzyHRsPSrafQ7S6LbpNx49kwbt",
    "7gqJYkQ1HyrqaA4xiopK5hES83m5K53wZwUK1YhDib69",
    "7hRczdkbJuw6BiumN1U35a1zkV2bV4ngnjsqhGSBFUY7",
    "7hajC7jhGBk5n8xbYGPGxhBJH2cJ47cabuKgNQNR1SNU",
    "7jbxyCM25T22QXzWsBqKgQaHcmaJeGYecZpVsQGQHh3M",
    "7jz1Vp8vPcGtuLz556BMei9JWvTbN2ToAc1E28TeFhrY",
    "7k8DQaMe332Twh4ii9ShHi1vumYfSg51V2oNQKEPqma2",
    "7kMLTVdsrJvcisqdymcA6gtHkzAxE7djgMgeao2Ljszq",
    "7kRDLaMDNJ5xLcz9CGKmZ5DPTTQwFDwcEBywv2iRWGMm",
    "7kYrBWNj98AURbw8yDtM7Ax94WjvzjzAZGThfdzttu6T",
    "7koPrGSZVR4GXrgAYCXMuWkn8an6BbnheWMZEWHBebp4",
    "7mBTfpsybF772hQVfY9vHdVLhrgMzVAVKt53ptgoNbzH",
    "7mRQA4gk1T2EdR3ddwfFGm36rCD61fA6pgSXE2K5ifjD",
    "7mVo5hQtAeecFrU1PKFm1DiawuMDH6AR6JAa32Qk1A33",
    "7n9mRjJQLM9s9uGzp8g13xiACN56b1pSpXmeubXRFRCH",
    "7nPWP31bo298dxMjdzrDtNNG5KDKjHBzDd2qDfTBvURZ",
    "7nbsMwJakd8Gt2GSviDtsXnAVVvWgtg7ga39TeH38Lso",
    "7ngbw1j1s5SiMdKqQPKwQkPzyfkFWvzezMeoALFQNHpH",
    "7nzYtty3xDnC8cR4Q7f4cAy6MgyzUTAFQN4qHYXTFiAj",
    "7oAprvZPZCjy1LNWUya2Urkb7oYFWWyXsxkZxuTQLB1N",
    "7oMbXDSysTxLf7QSgCRzMk9eYBbcVWFYw1PjA9VMB7Nq",
    "7onyji8y9NNDmQNF5Z4pUpw2xootorcQdwQhJbJxoGYj",
    "7oyoDp6mQnYVepee14GQKby8FAQ5SPxtLG9tiosfKDpt",
    "7p8GnY4iyTog4RSWjGWfEKMkh8ozkdLJ78VTGVs6eVoV",
    "7pNXoXNe3S2amiQTV1kmJjwGhyG7C3JmhmKV9ZEKzzcF",
    "7pNbaYgD3txG1K4f5gZabspmNstdLAHBGPTNMgP4uDmm",
    "7pnC3nivaAFFt4kez4QJxMYYHuTuib3jdngwouExmMWr",
    "7qWqmzExLTaaemWMNoWwUKAyzWhAT1fkyJEpDH128TtY",
    "7qawLd7qyPhcX1SwwY76tdxAUaQZ9kDG5GrMgSkBrYfg",
    "7qwDnr5Mi9peq3S7yRRxtgHopz8YPVUDqvUY1CJL1pR8",
    "7rixJKoLo2USyFqWhsSbTm7bLDbsCxX64x3MSvdHBozn",
    "7rmwqFZg2VZwJqHDHimni59rAqzDFnufpAHpVQxY4nAA",
    "7rvApcSzmg64oXAZHFQky8uUg4NkmJvWsiJonwNzcmxk",
    "7sF5V8pJWYQf8aQQTunyLSz665f3QiTBjd12knW5zRj3",
    "7sHi5bsSp1w9SaW83SDB8m2ZmSexLyXNAwk1NmsahHiT",
    "7sQCKgi86ooDnBYAgMyJ1kLFZQiySu54j7sckssdcmnG",
    "7ta8zPUPPfJXhJJ5bBggA4fXN8QDraJuzfoNHJ5Tdyy",
    "7tttzkxvt8LJtn1poujP4US2erD1QpiohyLmpz76KC8p",
    "7wDYYaaFsz8JCBWLaU4zWfLKetDb1fwGBcZXcwGR36bT",
    "7wMo1f7SMeGDu28cVT5Au6tZZ7uKH7yWDHqAP9ZVz75p",
    "7wuuhxf2BZGUyjd1QH9tSioC7SdD481H2ydKyGQ2a5h4",
    "7xqBbPBt4QFPw4cWmGYvBgN8YFJB54vhg5ussApMVy29",
    "7y4b4L5nTW9MMy9T6tfpyVVGuAfXXSKH78ifyrpZn6qw",
    "7yWcbgEkfHoQnizop3x21tV3PY5LUApafqtHwAZemo3K",
    "7yr61F5xEbs27wuci8v435w51RRvtCurHY3Tro1cAuuz",
    "7zruQqKnNsyYYmdhyPPRuxH4A9m3wpBd7n3zkhjPWhaS",
    "811E1s4dFM5rxivoZbrgGgeGurS3XnUZnWWWbqwEhxn2",
    "81cPz9ADg7sYpikJFZfhVH69GnpMdoipT9ZMVfynJsp9",
    "81e5ab3Cm3566oe55NkyuY39cDApo2YBSikqxBocBQaT",
    "81qCbuaMVPLbZ2ykN8PysuiLmHzDRJA7E3j5MMxLij7a",
    "82Dr2gofq5gPZa8SBoV9xnJrF4nmNNSe5RfHdxZ3mzU1",
    "82n3M156C9u4pTzxoPxbeZM4jW3nRpGTAeHoUfSQj81w",
    "82qmQ6cf862S85ZiQVq1horw4NgoRGvLUCyTftFRrmZP",
    "838L2kR45vp1vD1iWJEoaH2uM9An5qYULnsUJxsY8LVt",
    "83BFLzfqd1dRNVHPYw8FTqgQ2gcdb4MFzYVLmJuKtdhG",
    "83WweR6dmFUrpHCKUsU2SE9HqmtbhxnUCennPncyxPPw",
    "84E38YKTBCdMNaM3XWQ9LpaLVHMhM6yB93VrZsGa4Lyk",
    "84HB1piUpKeAn6AFDZUKR89nRcG5ty5dvvHd4XyVeq6N",
    "84q3G1zSaBJCwNSAW7MkMdCktZPZY9F6MZFfWf46iH1U",
    "86ptZFABGjf4znemuWkKX9sEqVhFgDA5JcBWfp7zM9kt",
    "86wm2V5HZf7vJTx4qumCcMQ84HwU5Sbp8YJrBUzwrzr8",
    "871DFXJHYYHr6BKrwFL2bKfKgrdJWU5BzN991EcKcNQ4",
    "873dUrNzu81vZc93oMw7hy2wgPqTyDUZDoGaBrrmfqGz",
    "884UyS9Qwvin3c2aGqas1DtvwBga6MSPru9gDmQA4M2F",
    "88FbkNCLTyMRxdEEHy9QXKHz6XXQHg4G9uyYB8vJciL6",
    "88LVCH2kDs78895YfYT1mVwauW5yq6H1vtym8GdDPTG3",
    "88MqFc9K9NpepfHx9ZMuq1p5SuayUBRiZRhpiAE753Qh",
    "89RAzd8yHpmyGooqFnTu1rychTdaBkXp5y19BWWNwNoj",
    "89hwJQM1Cne8TZPVkTvRVzrNa8A1tkQ6LtAUL81BKW3D",
    "8A6nF83UXvbeT4naJD7DREwcxWhrLpifumdgQcHZP3Mf",
    "8AnjPxN6i9Nc3gCSHGhCbxC3a8aiKYeLCf9iAEYjdauu",
    "8AshJZiUAdyqY32CgH1919i8SYKR3gmAWHWL6vr6HwdW",
    "8BBZrW1UwW82MSFRqMCRUQ94m5Jb8Jxc7tqNsFbq9Hz3",
    "8BD2Y5sypBqz2q1DLn4dqoDv3m3kTr2RUN8p3KFe7yjB",
    "8BmQHhBSCwFZVvCVBQRZ2iv1JvV7BMBQe6k5JF2p42px",
    "8CC9EnhBmswECZdra9iZM51MwHC3SMWA7qZN1NKNNpZL",
    "8CHy2omtwkhvThdfBegGwoHM5dTJGQDeqHd6WsEiYiQs",
    "8CdoNub1CPKmzwy6aEL85JByaWqdyrRgVMNThgLSLYHD",
    "8DBifAZqbcqUUUiNNYibyE2Rq6uyqca2YVDVqckQzwzC",
    "8DY6CHdPVwff6xKV4Ycz46HZBQLud9rUSY9n9PW5sdKT",
    "8Dte4Ua61qwmF2su7fNGbw5vEgEnF4xLa9rkBbkmEunZ",
    "8EFHoFG5fvLLCdTXeW12dBsSrNuH1B9wMZNeeya9uMjF",
    "8EU4iLxL7viBYRWm3ipagNj4ByjTECPoVWFnJJ9JANyP",
    "8FUuucZLb4JTp8mHLHMB4xh5HRLGuJKj4jZEQNtmtGwm",
    "8FzYMGxKyryhwYkVj5KafdDgUyeRzbHRaWHSo4UoaWr6",
    "8GLMWUJHdhC3kFNF78VbABogh8FFkqHVckdNoCp6MrPv",
    "8GNTxu1Z6BRuqpNBEjDoyU8UMnvGX64itXAGqNwGdo72",
    "8GTFo1p5mEdnoXUnCwZkmEme2CU7yQEEyfJPhmVDdE3s",
    "8J7oxKPNa8ofEK9VgMSwrh8YqSEocXQxrLWdzpfWGJxf",
    "8JWYeLcbwRTrx7cKbNcXNK1KcFKNWqXuhdxnTx38BUe4",
    "8JppVifher2L5Z2S1P2roZ5bz9NwQxfDktPoJeXh4CKx",
    "8KFWKGvy9AmrNvNZhJTSRhC8YESKpqyEgksAijhmXUSk",
    "8KbtnQ2LM6Y3fiQp4ZUSNrDbnjmP6NLnV7GKGmmgTsxh",
    "8LhNLPdsAJRAsQRScegPAFreQAgaKjk1myeegeWY1pvT",
    "8LkPTP1sTSqr4cukP5z7nZqPW8kwnjsRgKwvsHyaMTQk",
    "8Lo71cfthhRuYZ73do1jAS1cftya5ZRghEXi8JdpoAWN",
    "8N7jNCbPhSf4mkYms6xzUSaPS3Yu48NRwy91E5m9TUdy",
    "8N7sFsEnsRzz6Z44yimjvpAwchPgQJrjMhxVt2td5BVM",
    "8NSbLn9nRarjeSMFi24nVTpao9REc6BG8YDoTarRR3jN",
    "8Ncmiy1WB5whsxyjAmM2hjK7JM88A9ho5ibCNAEaxU5X",
    "8NjPbQbgupX4vy8x1r1fuBkLE3K95T54iCYNDBtZppHi",
    "8NnV7xVB7ZNXw12EatbCkcg49H6sdkxizRVrSjveYXEx",
    "8PzkdqURykCap4f7srWMSUoZq52DYnzfJBoZs1qmf6fo",
    "8Q6jAeLin45CiVi8Aojw9HASAQod9dqzc71c4NWEUjoB",
    "8QBHHRpcucFYPR2egeXLWBG3BWY5YpENducNjnTxAoFA",
    "8QGhXpAWjq1VFafawoSBknGaidJHigfonL15wQD539YF",
    "8QfnpkG9HmDTRGWwtDZH4VhF2AuWNtM8ZeQNBQtiR6jP",
    "8QikWTgCnPLRFySMMFfunr2HKRTxkW15kCikD6W7VvKq",
    "8RFPAH9aFbT9B2U8mbnuRx81Tos9rLeyzfopQpncw4QE",
    "8RJvvY9U9Jt8NHXS9A3TNEG3bSVEWqFZZ23wFoz327wc",
    "8RXDC75nmAcrTpV16TjDC7XRMXkfrdEPk5pT9xqVVu5W",
    "8RbFQR5mpTonnzL3zamDnfYnFrH38SCagJXrvh2vZq5p",
    "8RgaTUxNPjSCsgNs6ztQEYTKcdkjzB9Ltnptbi2kFd9M",
    "8RmF92rWZ9cG5btdK5gKs7BkmCpkjGN613JUfkGyGt7e",
    "8SBTxpCwu4EnBBSSD6gT8C5wAmC1Hmj1J9XcQbtU6qqa",
    "8SQrB6YWXuaMkeqiNUo8pz1qUoqPjKikzV8wLHQXX7qw",
    "8SoVoaSYPNTzQFGFJsBGg9Yt8hA3Kmz8wchEv1AsGbgB",
    "8T5u4WcDk3Dbz7ZdewpJfV3tPf3oeQS4xXjjYY7zJeCu",
    "8TPmDjFBZdYJgqj3rEeMNn7CXWpgxPo9Y6HKzpJpXGj6",
    "8Tq4WzuXQF57W745R7sWU8KrrPy2op4kQGpsmHtBUxtV",
    "8TyYbjXHPt7iEyf3bAJEaAiM4VqaaAQaEPFKMkuhtKC8",
    "8UDevguqM3RG68WcgfQbcMJJDHdCRfzHmGBpXYSzpXeq",
    "8Ug2oUtdWyAhPeUJiw9TWFKyHa99yn7yBQceTf2dWo48",
    "8Uo89pvAhgsL6QUtEiBMm8hEEEjKhmnEx62tqtdR2WVE",
    "8UweHcpdFuPcqmcC1rrKPVAJYArKu7VEXuDSg2RsWvLL",
    "8V2TjrHGSQ5yX23J2bzDR2VDDMdfu8ygDptPQuoffYo4",
    "8V73BTPErdqooXfXf3i94QybQTcGiNFvqvsy1kAi3c7v",
    "8VEyq3dvNY9VKh46swHgtG2RuBW5FVGdHsA2hP36kyHr",
    "8WQopH1ScKw8mmGSfFAyufmrJ5dJDS46z6NzJ4Ai7t35",
    "8WQrwuiNquAgEGf7zoVt5gARMx1Xa3LNVATw8jxtxkkk",
    "8WeAo6kBrUFq8zBvrUvtFt39tYqKMTnP18JSsmBCASuE",
    "8WeZCHHFi1JrgGnAPfBW1M9bWbAxkGsf4CNnMCJ3dFRj",
    "8XGN5BAxrvhnY3CZw2ZksA269MvD4NKrG56ec6okXaZJ",
    "8YLgHuYPv3GVyyBtbQ5RUbjwze1dNUxJ1HKh7GCdyF7L",
    "8Ym9H7i9Fm1KzXakKNGvoKDmuEjggYBb9VfuwcmFnb4W",
    "8a679R8hiwNCi4nhUm6Lknv3u9iM9btKyugNgvFXJXaS",
    "8a6rU6qGQMVnhwBTVWZLaVJ6f1DgaXSCwmySDKQDFMNS",
    "8a94xpf9yKK9uuSTCL33xASTko8FruPS1WM1pTbSTv8x",
    "8aFiQckPgMBkBveq5x7NnYyUGajvQYEVBBMhm9jhBNCw",
    "8aSh5rVXGLe6hR5ZoWgMMBq4E2V9RPS2VmtJv5DHP974",
    "8abCbnCfLoL1fzjFBaQry5WSXyKx5g3GAfXhWeUSM2Du",
    "8bqzWF6oSc6jjfGBzXaSVSJU1KUvaCf6xiiGYbxamuPz",
    "8cDq1kLXnuyyuWV8k3X5YpmRvsoenKNCaqSRtvbzyBRB",
    "8cvtJ1fF3fx5jS5eVVtYDQLHeAxdWegH4P8gBYkmPSwK",
    "8dhvFaXhgds1wRT2hAVLG5Z39XLh7N5pCYWwCNu9ZSLy",
    "8eAzpZcqM75pv9ZiFf1gkWJyYQwaVecFg2S1hkYJJ4hF",
    "8enX74SfV8hhkkpse8s62J2szz1mZj7uxQzByh8HvU23",
    "8fEtEHnWek4taMs1FpRCVxm9utXez5VWeketoVAUAaCb",
    "8fWneMtiDQjej5W3k1yWYVy5yUxKMqFn3YXXvDcatXF3",
    "8fiZ79NyXjMkB9iUofchRA8vFF1hudDg6HnCAnUxNFap",
    "8fsdgqAhjdNQ1YLQdHepTx2dVrNcXDUr1sDiDLWeV5ax",
    "8fu9SfpE5inbqapVaUjrDsHvxWCAFVDRVedwmoeKnesw",
    "8gPGXzj2Xd67HyPXv7HHzxS98hnMMPoJrrXqpwKS5XnC",
    "8gh2GCYzZA5JAurLtUeNMreqqW91jBPk74FBfjzfY191",
    "8hL38gLkm7FRNFUFbr92pRs5dgXSYFmRmmeZgGG9jYJ9",
    "8hXZdMBo91FqunQrqzVCCiaExmsoDtN38JQPyqaBFzWt",
    "8hZNpL5Qet4Ht6JDc5FPRj4cHNZzziGRBcYWHW7TMmC9",
    "8hZVYTLmWX5tWufmNYcFi9yCpHT8gNLUeb1MxyGwZv6T",
    "8hZhUwUS9bVdXV48p6Tv21HUb3WYVWNzaBsc747eRUT1",
    "8iRSzhAqALFQ589duiXxw9UwebAak2Rfy5zrhSdMzZKN",
    "8iYmoTrd3utLqc3mk81p3qYq3pa4s5dNmpQcukFLeWdF",
    "8ic6zGrTmZiaBY3SHzwdDa5uLsRgU6ZYj9BWaw6gVgqz",
    "8ijZJdSE2iFhPXShBrWkLK1T5xPQhmzQ78NbQaVoRYPU",
    "8j3LawoN2nGhLs3YeCenbQueKU5YHH1gPXtbWoo2AKyM",
    "8jwstFPhUVTDMjMKhiv2mDkreXK6YYDaFsu9iRBBCHr2",
    "8m6RRbSAMN93RsrMSSdBfHnvvH3a5ExrRUk7abnXCsa3",
    "8m8e4W1nFR8j1Zjb3cRSkzWy398qesoVWyCAj2QgdbzN",
    "8mHWdYpNbGoKsjVAUKzs3mdusYwZcjhtBYB1AcJyod6h",
    "8mYpaBAUPvF6a3PHt7kQ7Wbq2d2eSdqjxZoU9tdMXmKg",
    "8mZnvB6idFE32zsLSBn1fEw8hoFp1ZgsPogEtT9uEa3D",
    "8meQiYMW4gGoGCxqCYwnmDHnVrW7y5qgasWT6Zu45R8w",
    "8nBodmhy6PerD2vTAvj7vQ4ntpwUVcmXrohthUhtd7f",
    "8nCdBBuiuMof2fqULGphsyFcby7vwBbo2su7c1e2U983",
    "8nQ4D8GinfGy6Q3nxTBS6KS76KuShkWW8fZskKicViqh",
    "8nRe4C38tXqTEbov8AtgfBhTNBPsJDZ4TivPt6CPaFia",
    "8nkyC1crY8pwY4aKFx4uf4DSeNuhFvdBfy7tTadTKgx8",
    "8o3tcUYFVwTmDk9482bpCawKiQs3hJ1MZUQcExMiNyBr",
    "8oWjsN8YxBUiGK71QFkVvTjfh4quUemxzbqRNvDGqP8b",
    "8pPDUXgpFDQz5KTEKdsBuv5hCk7w1L18MDWWSp3DBacV",
    "8pqyR5M1FWmTLCxWMRtE6aRcG6CskQupKFrtW4HDtdKb",
    "8pyKwjR2uPSqHzubTfwjsFaBVCL8hgDnhUcaH61kwdfU",
    "8qbSUXNdQMwFz1L1k22f85xfK4pQbghtnyMV7o25u4mF",
    "8qmmjPTHRqV8Vnuxr8XXw8jg86EdfHWgajVcJZMT27xT",
    "8quD7Q9RC7EKWCshkKGkPTZbZ1gsgrEzgqj35tjfC9ak",
    "8rwQZRMHxVR8vwY5p866PJXF3t1jqyRkf8zaCCUf3Ld5",
    "8sPozKJqowtpNXt1o8JW3BXSjw7vM5a3YDETp9R54qnT",
    "8seGKjsfZasCGtzkY28wyWug6aXPHH24ATJhy8o5w5Cg",
    "8smE2Z8ZiyV5m1FXzwMioSv7aeAU2Mu26ero1JKd4HMo",
    "8srkdoav789zTZXDfiTNdaAW3q6xFtB7GKJU5X16kRMS",
    "8tNmDyzATDYNfc3QCSx9zdk9BeSdCrdJYewmxoCJ1Wtf",
    "8tPqmmMAvmcCMMczdVZEW5WyNL35o3hUZrQChJkorzPr",
    "8tRnDPbLfm4cV6J6JpR6VBSFxpFk73HMerHyHxefo8V3",
    "8texmvxAsQkCZuLpUeKnxgMbaTo6dwQrfeDnM4r4248P",
    "8tpwcxnj47qJHj91fDa3SpDJJdz7oc9Ft2f492YDSPHn",
    "8u13rj6Y8npDoigSwHDZDnLHtqxFk1waqeqhrFksRt73",
    "8uYDsvgXn64eNw32Ui4tpNsoCyRSA8fYH1J15bX3To8y",
    "8upFPGqFnJPRy5FeidAAJme2hNCFmqnaPsQoAmdqj3Bz",
    "8upjqXwXq3wamtAP8w5WBjPa8NrfFpHvXuzit3nHfffA",
    "8us7Mm4VpEzNzhqjUs265qMNyu1ZGRppu2MHDDm2if5y",
    "8uwgqPngLcUqByN4e12WepckuSCJELMgUDszd7xiawZo",
    "8v9r2F9qzSdk6QCmnoZwv5HhaXeN8myNE6mxAqr99qRH",
    "8vZHvNst7ftDqLWGLdr7VJGATi7c1FCG5N7Lhbd8ESHj",
    "8vkF6K7NvjRzbdEAsCiVtssJRV2CEgiAGGTet9iUXXJf",
    "8vnE6poTycpZEB7sknjpX3f7LjgN45WynkGKRaesWZ26",
    "8w1GYH886pcNDWLNhx3fS1ZPLaZjqShWTNS1QT3V6uS",
    "8w8VpJedw1pyYeLVmS2YRM5gyokTr76uo7ffAG2aBw8v",
    "8wTjgL31guSZRPdR9zxC6UrgZsUe3W4LqajpNdaudZfZ",
    "8wi7P8aXVZtyB3vsNUFQo7DinBxjujog1XkoifuxyrYn",
    "8xYvwRAmu8c84VWeSPUqrdcqwaFY7YU5ygTJGCM2dnSV",
    "8xeSp6kc5teAo4Ay1hs8LK9vZgb2tDN8SHN7tjRbfpuC",
    "8xfwdeUBH6DSeRiQA1h682j9y1kkxbSwq9GUq3UWfB9f",
    "8xpDSVLCGsn4hqHLWPuwuw3V1fSMQkm3GFXijVzoJWCm",
    "8yGFfhBy9aBDYtG17pHiCYNxJBGTtvDd3VbySfbSfRXx",
    "8ydwXF8PH5QHGtyZSAdgChEqPgjE2wF8u8cA3tuYxA8g",
    "91sZddYsoYTR5EkqncE8FfRBohBSuBSEwWyfzY5vDM3J",
    "924u7nrDyb2Qq1aBZVS8RBTKHjj8vjiN3jXwzHZ5DnDU",
    "92SGjeu55W5zLo87fEJFuaVButka7ypmfn4sJvYpo1pF",
    "93283Ks5sxb8rZbPU5t44Q9D5MMKaYPpwoMJWAWoEwJH",
    "93CosFhkim6Mt4uy4qDs1rpnRC8ChfG858CEstCVunX9",
    "93JbadoygVEDnWAFQXWPWMtKentRciYSR22Jj5Tnt7rJ",
    "93S1c5y7RG4aMPxtCMbgRHTKnquNK9pgBBwrgs5KbbJ",
    "93e2gZpSSgDMwr91MoPSc4jsuSaSfidvhadAXLHLZbbr",
    "943Fev8vjvQJt4AchL5z5c8GFYGqYbA93J3giY4oUvDr",
    "94WQfvWP1BaEofWP1wj4AKy6n3zyhsipwMrW5xcG5qBg",
    "94kjsFSntG4rpupb3X5UScJQ7Pnhd8mRmnou6wGKsp8S",
    "94nKVUcup7pjanQMucdKMJhHVivbRLvbnrnJfAYrnxTn",
    "94x2VYC59QUGs3PWMafcR1XbcHnNV1qJt1ZtZzwSJbSo",
    "95KfHFQrv3f6W8AbygNZALAkbWmcj7hQJZEAbnwKYV6X",
    "95wMhPgYsp4drTH64tk7Rk2woY2rEh7hzfnYDkpavm5p",
    "96JW93nDQpBn71xb77dfY5YbESpLtguetm1mPedY1prt",
    "96XyBKYhHMyrxuUdwvcM99HYVSDvY3P5jvm3WYH4Zp11",
    "96jm4pRWZZQa4F11JZggKA9Gpdb4Jkt6bGB38aD3Jei9",
    "96wFxSEbypDw2Pf2AUAY2Lvrd8tbKHrHDtTaxDLFiKPJ",
    "97XW2GnRe7ewNChPHBUfUvdzQcE2L7vygVc41BH4UhTP",
    "98ijdJPzcWmjQrSYGbuKz5vDkVpngKRqoa9os3Q5ZWXi",
    "98tzGRuqpxUcjXyJhkkcTgtaZFHg8wHM1Q1chKX9dNhy",
    "98vPZKnik5AsQsud2okD7jsN6jfd8RxvzUpafZrzm54j",
    "99A7j5VXTaWMwJdWYdH6A9U7jwME4oYAnbwtuHsRZMTU",
    "99pn9BTJ8MVdyuTwLqPYt4Lew1Fh7gPwoE4oDdBe8FwR",
    "9A2m3S5E3vv133ryu3y9cPtGJJJFZ91zea6wjNBo8fp1",
    "9AFcCJEmk3cvNVFQ5ZgUq2nHiE5R2mxdiUt2gR6YeP5R",
    "9AnuWYNPyhQ5RCpc4VQAwEx2vac3nUtpU7wiADRWfcby",
    "9AvR2yCaJRRzK4dx2oT2rsNsAisty4VUcp11KyKSYqFn",
    "9AxAJ6nf88s6P79fqw56ZnNPiUrE3Lr2QDgZ2N3cpKwo",
    "9AxGtwNtW2RZxCHto3NUQaGC1wCPmJDpBzaKPJnkeTeX",
    "9BpBKYyu9tuy16nM1CAg4Vh9w66LqFcZQxL3zXcBiPs",
    "9BsYsg1sWhaSBVjfF1QjrBA3R3bE87nVy9KsMTJ472Bg",
    "9Byo3fFkVYCVMwv92QcEXKm3vqDfefdWLBpZiVCwrh2u",
    "9BzQjdc3SPcGdm8vBK7s3uXFTrD2s31WgSmkBH1YPBfd",
    "9C2BTT4XSD59Z6QDZ9bUvG3ekCQ4Mbh14pQrRrvgXfAs",
    "9CTmunLn79S7XXH8zKTKtbu1F4nJRxcDFirsQmsjP7Wv",
    "9CxknJmBa3KKRBfXFPchepSm37QaWfhk4NDYAqyqxGmj",
    "9DMgjEFthsuFj4iuzRFoZd618hRhRTQ8HjsRxLGrsv27",
    "9DUtFjfKYhANmjr8M6ejXQVhV6CosDGGDNdGhVkhx9MQ",
    "9DmwyRsmCYSBCi1DiGQ6ybsAzseZMVYKkDXptMJ45EYL",
    "9Eyj81Kii1RkQRAM7JkQ4ihCLmZwCHtPN1eAgyV8qeCw",
    "9FPsK8XZJbYxYrnMdMNxYgaTc8H5SoNzziaXVJGYapSJ",
    "9FvBta85vASkJmTytYzfrCrSwt7Y3ij7uobcnM7t2fBT",
    "9GTFtpDQZ29RmeucuQiHmSUHgEoeF9ofm1FtPnL1BdGn",
    "9H3cHTHCU11jdNpEAfnHDbh91F4PNYgjrtYCe6J9foQx",
    "9H6rZMdbT71Uj6NmxRquA2ttaTVm5YixJorMoCFzHHuA",
    "9HYrFFhiXLZ4EB3th7Y8scF8BQ4tqWw7KFGzCHehMRfM",
    "9HzJ4rmxHMELgHrLAXJhW481sxXtTUwmW5o6SK8ktLJf",
    "9KWkhqKXDrLxqCnTe9ZixyJFmRCRpgfohnfrtZ52iZo7",
    "9KchkkQff8iPdiGDC3jT3YWhhXku9yFrPfAi2Ci9FU8M",
    "9L1J6ENzfczmfBrh3GWzGX33vgi9qFvAMFhSqsfFFiwG",
    "9LUU2yJrZiPz6f6mN8ieVwySStnY7XEDsKYocidgtZEd",
    "9MCky4jHKzMJPismsuyn2hmjA46mJ5GJmMKbGSAqzYgV",
    "9MJ1kwJJ3NXobYc7fhYsUTKhGJZ84kFPn2Ux9En1D7C3",
    "9MuhuyzKyCFLuHQDrzbY82bGskTg5BSU69djtdU4RpYt",
    "9N36aq6h7xbE7w5Boh1tHHHDVTVJdNq8m3rr2SuJ8d71",
    "9NvHiAazaMKo9uECAY1SeNGUxKcTWnYTZXBVcpce31XB",
    "9PwELECQDihZX5qi6b6k9fqccg9uH6Yu4PvwEoK6Ktrq",
    "9QpfQvDm1ZptbLvw6YnUboYXWsKHJufQCSofwxGbthC7",
    "9Qx648GZJrn7TtfLWfLoUMjcLRE481Y9b9NbR56eKPrS",
    "9R56eNS54Xag52c7t67qxFzdSchTP738xX6eA6nRy82R",
    "9RKcsjjke5bV7PXFw4HMthebm8E4b15wiJMnVVHzCwtf",
    "9RWjw9N6b7PP9T6zg7BEdzHtViFf7NvMHGLs6rJSiTun",
    "9RY9mYDTXrjwnnzYVfYWLGDCD2S2ELuuvHAcpy2d1F5j",
    "9Rot17ccjfZkoaWwwno741aohuwPUtJBrbMSo1F5bhh4",
    "9SYNgGn74ahRFGUWQ7vaFrAgv2vQJ1ViUhL9efDVV7BU",
    "9Si73LZicXfCRPPjUA88RCaFT8aMPp3GhngtsFQxgSwa",
    "9SjoB6CQ45RfLbbR4UCgn6aKupx8LxLj55kECdjRv5fi",
    "9Sk9oiF8zThaqwffMSta74AFksEXvNA9kppVEjcRFZ8M",
    "9TTxS1eRbC3xAoVrPkSaT6287GCx6pmjBsPYBXT3My1x",
    "9TiCEQ36eiPzfdVXXYXfBWgmuxqNC58k1RcnK2VjbqZH",
    "9TkdMmKgEWnLecwes7kqcWUvGfFfGL1QTa4whUgSuSYD",
    "9UPqBTmBX4nasdnoPERhXodfPmhT9zcUVNpDarP6fMmF",
    "9UvUNFbcvzxPd3Ddrxz3jhF4AwSiK1xeErsReXsMUfRq",
    "9UwVxPk5DUMyB8LpduVdubptrxBc1KH3wWQgDZMAptAM",
    "9UwZFdDpR44p1oPf3Y8yy8u7W4AerCyRYZEREfVmd2eN",
    "9V1CP5NEZCuBVCgX7ihTXjVq17ToGorh6zpEWCXeEJeb",
    "9VKxeuhS7cG7G5yPZkChkSBCrGxX2h2XaS38gerXB3jY",
    "9WMPD3ctrZMeJVnjksT1jnBDGjBNvzoZRdJ8D2NATcKc",
    "9WYTyKD2Ud1vggK1UkCY5ZZJzK29SDEqFYG7nRvbytVF",
    "9Wi55wXLJey1APCJjPK3UkaTVAyvtYdrxg1eWNFhTBNn",
    "9XP3Mt7J2HJk3zpt83FyvShFKhNmN6VdHKQDAWpcLFky",
    "9XzcEkGaedCJp5TDbhqKXYyTKa2wWzdK3x2y5nMPCLHp",
    "9Y8cipB2kyvuTLt3FxB2KxPqdJKECyV9uyqXqMLSqQdp",
    "9Y9PHd8QvW5s4YYWaz7q33X9eEg2QAAZ67HWwiKVjssM",
    "9YAD7TX5NX3urhdkq2bC51RpT272aza4d9iCmgDE8yRF",
    "9YqEMk9xGNBenCmKNTaDrC9vcZABAEqMsTGENfCZ9DCE",
    "9YvNnUqnKy27f87WBn9NaMf1genSUPop5tz4KGTFoHRg",
    "9ZG4seb7qsdbvrtVYAE9z2WL5cLpcdHgweejPokq578c",
    "9ZMiD3NeaeS5yj8zzyJwBAwhP4WnYXTyu1Qw8KGNBxZe",
    "9a2A1x3D2H1bsEggWWG4r2fuUVekin4yfFrn23C3fbP5",
    "9aA8MYpRgoSdZr88LZYTJhd9hh3Tq8tGiqkMMyQd29pY",
    "9aAjPCoLLAfGqyKaMnyfSNYhCDY6tcr7QoEfneTNyvJE",
    "9aDrbEKADs8ZXUbh7LGBBzmNwnErUEB8SzWCck8CeLBJ",
    "9aVSHtMLRjqdJTGSu341sr9iEpVL5sTzoFYEZFCpg1xt",
    "9abphTLZbBXR11nrRAQx4RszqBFUw4rDUDT4EMzkqFck",
    "9amSq7FNX2sZDWTeDpYJJKTih2n1BreywPZLdAi4hj2w",
    "9b4x3nse59ZRU8yHtBmzh39gCGXVqWJ1QTqA5ZVuzeKm",
    "9bGBD8k2ZmKSBWFBxiusLyCybPYG9zEib8tr8rqGLaU3",
    "9bPuhTF663SRYGK1zyt8hDjahDNuR7E4LC7vM2jZxRy7",
    "9bTmbAUJ3ouSmZatPd3xf83QCVpYxzw9JpAfzPuPhKqE",
    "9bogKg5ejA21GDVQm24DszZ7e5ZcGTXYbehLpfEJQEjn",
    "9bzbkZ86ULEK35t11B2LFaKmcC7iLHQLow1nX9wz4izy",
    "9d53RhPAoqvYcLNie6B4UUGvo9mJTpncFPNhGVN3SvDb",
    "9dTnDyF5zyhTrJ7WUmuzWkcvBrYFvzNb1TrMwebqaj8m",
    "9dujseYwaPJkeKDhjTyYZ9MaW39DdrxDHffA6PykzF1B",
    "9e3ZG5755pnKE3pYRf1asM2bFqc3KgeENjog4MwociLS",
    "9e8aazG2TELp7WmKf2kSaUJwRLPjCgyePs3X5Xtgx8YE",
    "9eAS6SfChaB9iZtKW2viU2TZsYQjGNUHRswxe1SjwGCN",
    "9eX78H9HqAiF2Ps4VTbpughGAmckqh9KgjZZ1477gC3",
    "9ehQ7naVA65jsKevcJdh27RrKwQBvqVhXtiUDkqhEeGr",
    "9foB9EjJ9rWmSdu5tRqk5sGqQr8PrGY72ZQBpmjUSXdw",
    "9frnRX2dZ2W6if7LY8vHYBb2C6BfHiJ9xU48UVZyY1eB",
    "9g5hV35yqiNEospdfktPjpA4ynUEnxEL123vUmfGyMba",
    "9gv5vqKHT7YSzT8WdyjTQsXLLE1JVU4GTC4Pd1wWhaRW",
    "9h36ZusREeDQ9aYm2HgU53oukmLP8EPfX7a1kUb1pVua",
    "9hC7eRY282SdpbR824tpchusoyZxP9P3v1RCKTrPWGQJ",
    "9hWEikYNJYgx5MXNukrqAGtkRX1bqgqMznZbEyJLYyqq",
    "9hrYW6fRbF73tJdxbg7DLcacn9Dy7GRnLAHurPLPjhen",
    "9i1s6JnZoCfZfM7FQVd1KLaUNtUwkpjTj1nvQtFmoWRT",
    "9iYvYBScePbN2DKCBcHriwNyEyp339eLCzvS4srzWVkD",
    "9ie141gDN8XHYy8GhfjMFZs9MUQkqSardbnrfmzcrk4Z",
    "9iynDg5QLpagtzop5cvUYEMBaNQShXXRnSqexKk366kZ",
    "9j5RsGvPQHX8iTUgxeVFSZNJnYEkBudu29rqbiwCrjH9",
    "9jJqBH5jQS66PwbGZc29BwFpLGrTKsYukXN435AvX969",
    "9kGcaV11dniF1dXhVJtptf1MLrXZeUnDquWEckSReBo2",
    "9kLkFnvNyyNvGNg9pfDSRxbGvhuFarP2RQ3GzXn896Xw",
    "9mFBmYJ8gSbPQm8YHvw6ewbmiU9ELuvVCiC3S3y9gNrP",
    "9mSBnDqv2twM9bSZjXZxYGT6DqAzpzPTirUeBGXwgzQ",
    "9mZxVSxkCsPCYUYyeDiWBnQnf1uoae6QCnkWRb2qTNJ3",
    "9mm3CpmX3txJg5baekr3RiqCvJ4TiUQSkUE9Z96znvMh",
    "9mquQohFaC7d8bhvdfXiDDYsKyShG9r75rwP7Baap1V1",
    "9mxfpr8VmEdqHJbogpuxKbe1aAcGszUfPLrHFaj4gW82",
    "9n9m7cMMsfuW4QFV399UVWQheieCEAmGrjUtEbMrA38M",
    "9nLE9yQ3ENbsntWCCpjtPbhQ9tnWVp7BmX4cTAUNzm4b",
    "9nfgmjypPeA2Ee2tsiTwKjgVxYkC8DDdFtBe4fHhwnjv",
    "9np4EQSeQbsAikjXqMVXmGs9XmuNPiRtNQms7XxcomAt",
    "9nxY1VhKQ5oGmJ8Eu7nMKvDZXJescCHg8zoiGxHFYquz",
    "9oEWa3wyk5RkUWG2dPtcA7Qh4CQ2z88Mg9JJThVtChnw",
    "9oTXb7XoVxYBJaThMmyuozHJazy3idb8zo96tRDrM7US",
    "9oTz2YwDDNqAMRQk1DU6tqsuaQgJMaP1Z8BodnTtMRHF",
    "9pF7d3xvH6dxZF2imYL8MDm37FGQWmfAs1kszWARnZWw",
    "9pHMukws6NUpyx4MrGmnVCKVsMYKUuUnEK6CE5DjBsm8",
    "9pUQN6XDYQKr2zM53uoehrpehQQUt4MC5wL5fCeFeoWx",
    "9pVxc6Kg1NBFybfDGzbCThSzqdx4YHLPnKPK8FStazTz",
    "9ptidEQ4U3BqsA6wL1vJSu6kWZEDASHQq8CEPcZ5grbB",
    "9pyJUckhFTYcRrJvLRLLnx4SW2t8JJCpXQveMwvGfPak",
    "9q3tKXmYceSUNCBS2HvoJ8auGjtJuQT6fDBTgnGBnkrS",
    "9qGP6Wa33W4TTLvk79SEqMtbcsX1aToP88K3UsdUV3qQ",
    "9qSES8MYdQFfgEvEGu8zMyipkPdibx4wXvLnReJkhMer",
    "9qafT4i1phvaL7RqhGporFWH8gvAmUH5MP8k76tuLint",
    "9qbYqsfJC52wQc56TxNyTc3sBxka44SVrhnAQDhkKEyw",
    "9qsnFdqwt4vUpWMAyBLLYn2jDN6fT1QHwBaZJ2G3agyK",
    "9rDx3ArMcaqUTLXf6ucnETuKzUR64F46tUTzAwD8cxCo",
    "9rZKhYEjYBmKDBCrEpRAoh8dGxdz1JTJdKJGu6nvVFgu",
    "9sX65QnQrmmjzT3WHHbPXPeQmye1c2jZJL1ejFpsZM68",
    "9tMvwa71ZZJbhFJWwJvLpUtSxvs3ci61UBvu2Dy9TXG6",
    "9tZX7CQMXBYTkZXtQ4WV6apTM2dvorHv3sqGQmrrqnwv",
    "9tbW6G8draw8MqgZhMUPbHjQhcw7p9BcWH2CTgwyeAwd",
    "9ttxQoBFC166CwLiZBkimLSpMqN8kgtxb8Coy9HmA4PE",
    "9uWisH1LkrS4UL3FgVACXxjN2QMkbJnEdPhSpKGR2nWk",
    "9vGu4CbcTBp7jhDBv8hJQtvcgTQLDGvFSCa9Yozk3ZJV",
    "9vJfdnHgEX81FjamrGJf7bLDkHrkFxoseFhvuyKNjUkz",
    "9vK27EVCvP7NQawVj668yNZqzwCLvsXXFNNtVhkzQhcj",
    "9vXshbpUnT3o2GjHvu2exoPknEpevQf6GcNcr7odUB3b",
    "9w2q6sJpRvCeKhtQm1YfjEcgBMAd8622WAFkQ7E5bFqr",
    "9w7qzBjaLiD4APp7cD9Pg3NXYvvck8w6j8KshjQ618rA",
    "9wD2BHG3GDuGjSszLtAcDGGxjsNT7P346HkWDHsUZWJc",
    "9wESMvtqf6kfThqovH4d4CLNevfvENeGHVhJp99owZUc",
    "9whZZxA6NxpKotKv1ygu199DVVoCGBeefFn8prKyrbDP",
    "9xYxGvrR37wFhZoxZ2kCJbNgAxN2qNsRmjYXYxZNa7Gi",
    "9xpX7BQegJyPv6uJgiY8BYMrF3VUYdWjq9QMpgSBaALz",
    "9y6wDmc2a2EEpqhHeFY9Fr1c4GZ3JX9qKqesv3EfrbUQ",
    "9yLC6RXEG4yJ7DtxRysrHv2a1HVAauTDzW7atDjAuMCy",
    "9yrMG9TD1KvGrAXgVxoqvoQxMjJutqmNhCQFxidYv91q",
    "9zAqMTHRuQqpQesNCtgqUuhReLr4JTBa3krS5mA1X6xk",
    "9zawRmn9EYuT7NLmHYtCebAmcZr7evN3JZqoQeAezxWY",
    "A1BoyzsPiWQgmuMU1a44sPLkHu6WjR43VZjp56dSwhke",
    "A1eiAaVJ8ECp71f9J5jPSnCbcPM5yCLFqs1HkBXhjFRM",
    "A2JiE9j5pFr4ZqTGspQ3E82zx6A4C13xNg3KxN7NZyjU",
    "A2Qd5jEYWSL15PeakKTEVoAyzEryd1PqKiCPhHJBRYrw",
    "A2mm9w5yPTTkJEUKqebX2eoJh8GtWWpHjzVSUcVufkTz",
    "A2rPLrTLvQLvkuK8r8R3djNbaGzv4io8zfP5ghPFqpn6",
    "A2s7PGc6xP7Fwc7QHJ7cZrfqYtsuQdP3W4Xs35V16f3n",
    "A33atg1fuJYnkQL4XKHAUnD1Vv2WYH8qhFmNTkais4hm",
    "A3YQZGg4i7hdigW7X9kiJTCKTJ25Tg51CZUhj5LS7Uxf",
    "A3bY5wbF1ThbWR1ZCgGyQAHU5hHA2RguoPoQKWcWkLi2",
    "A3i5DGfuRWDGfXKmMBKMpeWrDvuhGJjxi42tjtxn9KU8",
    "A3mCgwpUUSR5FXd7UZv7xWrzvgLQXN38T2u6zdwtRbzG",
    "A4jAzSS8ScxXV4HfEnTrF1zvY2XKYhRwqTnR9WLoLoy9",
    "A5KYbYpk7Zj6WyTVqz7azRG7g5j6422h7eczstKq8wSP",
    "A5RN9rXLSFqKnFUF7wciiQwsgMxGJ7RDMQdKEt9P4cFv",
    "A5WawuC4Rrji7XJCx2HgYpB848eSt7DzdazHZNbm5R1V",
    "A5YDyDedkk1rWd9p4GX4G3htpNH4S8tr2vW8pNzQ9k8E",
    "A5sf3kSV4426kuE8URmMhEJ32c28b1dEsredCwr8oHxy",
    "A5zx5if4vJeFeDWJdKp59nuJ9oRAHYYXoQgXZU6aNtZm",
    "A6D6Le6cz4jeCJmTrWLcH7CzzLNdtefLfwECc352ZHwE",
    "A6N3vCkzjr9Xpv87Z6RDZWUWqvXZEnnb3mADtFy33MRX",
    "A6R9ffQETFpgKRDiM8znwGu8ppMxtxAvLQfSkwvvVCLe",
    "A74uxdguZi7SXE2DvJQRWt6WXHFL2vreMCzHtBsRFHc4",
    "A7FViEEFPWSbZB2uQtDHwvnZfgXaH5odDTZN7fC7jY5w",
    "A8ASquT4VvSg9EfEBYyE7ZEc7EERpq6GnortfHeuvcof",
    "A8jy2C96o2aNXPQRKseJa1HzGkS5WjCQJdM2K82YcwCm",
    "A8xY6zWznTC58zSieC1PQwU7BgRXCUQJ6QDvKmKyG2pA",
    "AASQ9qnCx7KCwzgC2ySP78GFE7bHVmDNwRqLnkc78aRL",
    "AB22EBYskJ18xE4bE7erFN5Zd8xAgf8XTHGjmrK3PXxa",
    "ABEfEiJDA2ezQLaPhVSmXXUg6C2Tu8LDck6WoP13yJp5",
    "ABKVZ2CCmvk4iqUicUSpGYHb8wfboJSmEKpDCJ9uS6Km",
    "ABxZ11GkhAxYRUFsdxrVx1f4JAoYWKHSYvCREc5GNoG3",
    "AC2KpmibiY4P4c9hFDefcJEU3E5xBFKSBt9GrJgySefj",
    "ACXuvsZi8xgafJMXBrpB1wEM1ev3eysEvXYQkzXkU7vz",
    "AChD2sH9UFsFoEkDyjGreTau2xzbcJ6ULyCEijD2znA6",
    "ACqsLcW2EmdmgBYQdfQf6ChmzUYeDiLakEuw86GHiuC1",
    "AD9B7e5LHbLsNbktSbsPXnCYGJQDNohodm4wSQ4nn8fK",
    "ADxvqJoWH22tMimuTYLwwJrNW476sGJXKL93fdYd8Cba",
    "AE99Wvu25bw4hvi4bfPmkux3wMAMLRh3QkNbKpY2ssVB",
    "AEzBPAfdkEptGqw9NCRSd6WVJUtSsmTfuRPuFjZkbeUe",
    "AFCEx27uP5DDz9wWsxUxUqqZB3S1bG9mmRFS36DxCixo",
    "AFZ7JHgGB7VyxeTAwjd347ht2DxjucBa9aJW6PZxDhCu",
    "AFbziAVBCWR96rBj1aRgqgiW78EJhZLMa3BzXoEdo3Cn",
    "AFpWmFYAG51KAxoTnbEuNCtEWSmWY9SJcBEtpmTxbeA",
    "AGSpRVZnT2iYYUQTG3jTuxdvDayGWJy34JUvjFkiTnjM",
    "AGi8MpKzuAUoW7yc4tUbGoicKgdo7u6ijaMLxtd5Tbvv",
    "AGmVMiRAqHb4W4N9p7XyMP3ARBvvjMCECAonBbYh5Q9s",
    "AGsJ6nuPEkurArck8uwJWbL4EMAUBSgGvsHbuUGqxLKW",
    "AGsKgQvVtrfMGEwhMqHaFPhERYxL8KH4oou7af5nx4wD",
    "AHGksUrQ1YvcmtBvQRoaCk5xPrm2kgMj3uADSx9eWKNY",
    "AHKtK2NjHHkdcp9PWxijRcjjQ4E9oSztKva1fpR7A2av",
    "AHg2pn1AVtY1L8rVkSci7LGEDt6i8ZggGppsQNuUZDwh",
    "AHjukAfSLrzHkSThAWkxEeVdW1wqqAR3wRQXZNaXJBGb",
    "AJShw3BbD454yaTF5G86VvDZuxjUvGZaJYYcXrVTGiXY",
    "AJpadzWdSvnbtKRfxsNiXk7cEtH23GRbsK8uPwsSVjyG",
    "AJsX7SzZwYa33mT1mC1hbsETANcxxTy9RSA7k79fd5uU",
    "AKCM1otc4owKmpHeAJqrgksm5xZcdQJu7LtkyRheAvv8",
    "AL6d7abjJF9gvgiTaPYKkoQYMatUs9C64ThxNQc2kMoa",
    "AL7sxEpgSwZkfcdLT2dk33xA4pMLW8PzuvwRMtg2yBFp",
    "ALXTeXjDwoSWtu8cwM23hZTZU7tRmf8VUjHESVNz4Rtf",
    "ALatCkwidqVGVLRWZTKWoVyf2pqeizyCLtikykiaPU8i",
    "ALzznkNkacPkkAerudzKj8TmHu9g9wDhytPkBPmWKHaA",
    "AMEJF6yMsfBzYsvYVJ8Wm7GDRttjNrNAGdcYZBhRuuZf",
    "AMY6b8VCqRfdF65t6dnkafbZ99UukupMHArmraG5bAu7",
    "AMZq8y1uephGp6hkAZ58aVdPzdob6jK5Gm6zstT3tYLU",
    "AMrYxdm5BM3sSTukdTYzqaUwbHMUEoonhFqDqmhA8u1P",
    "AMvcy7NYkkLXTB9m2CcFgVyShHzMwFfp6DiVpi5wB5Cj",
    "AMz1xdJbNEJ5jBwgdZ8PHYLmqEJPDbePo33H9vPWATMX",
    "AN67fXuNwe9ra5oyhyaeaf5JZAWJNUUVrrGoQXATx9UJ",
    "ANUzWzm1CoJVXN8R5EnLuVQ1MQtcDHkC5Ry9ETYeofFA",
    "ANvjVRMZjXSfgWFbwXMiAMFUGLm3frAuqtNbNZrh24cT",
    "ANwJ3AYouj59Pz9u5xMgh8AUbnJhYf9DQ462Fb218jRQ",
    "AP6KzsCf4rWoNF9sxWCEWcEdzQCwS17j5dc5sjAVVhxV",
    "APgFMZofdiWJoGqNrRSxCw5oTxmsFBD9nDtPGoaBJyo4",
    "APyYt2WWvgPgMTPSfvVJPpDWkxR8zHJVefv6JqJkG4y2",
    "AQRjuehWbrFzra7zqCMrzbkomE9eMWuktHwfK8nDwtVr",
    "ARS8kAu17PTsCftXRvSGdi6U6HULQX1HhP9XkKaLGywG",
    "ARcGMeTZJ8LsXmPNUvNGFaDUmAyzFkSw42J5bGNyy5Uq",
    "ARz6cWjvKk9Trby5MPdMZnsGaoJRyT1ffVm6nvjgQcT1",
    "ASEgxHRt8WFRPc8FN5JWc5LMLGtQ4Skde7PAQ48Uk1dv",
    "ASGhkTEUs5hNkX1uxFaTCeempL4GnvsXMHc5Eh8FKJRb",
    "ASVfCtMEc5Z2Z5H37nNcZEUPf7aYHNj67UC3XjCYsQs2",
    "ASaagMWeSogm8gtnc9Ubu8B5onCJibputSW1Etd85K2D",
    "ASyTnKyrhPvWHpHRZdkAWy8Ncy6Fy8JsTjTM8bSXFufw",
    "ATqoJDXt7DJVWt3n1svw2FJ3MTiH7WdK2qPQKHuggu8R",
    "ATuY8BEL4LUyzGBYJe6MTMD4j8ft2pRDuzWx4m8cCQZQ",
    "AUHAr3PgEBn2oZ3u695WFGybkMpgsRDSH6gwonqEEhLg",
    "AURQcKCT46HcQf9KP2U7fdPWWXFLTBRA2UrvHhNJNT5a",
    "AUemSL1WxdxRRBTVBduZPeeKLyti5c4KByzjpHKX4tNe",
    "AUiv49K4pR9stUT31bLhwxc82W3KmCv3EK8w73Y7w4zF",
    "AUuvE5xEdCrkCtBixEiBtsLNjBx5R7EuKt64dphR2BGa",
    "AVDVtakDq1MgMuYkpgYTz4QZrk8B6veqwLpEh44BE2Pd",
    "AVzBV4EJKoUc3NMqdP2McL6Jcb3vB734QaPDi2GcUfd2",
    "AWRZjjcU2cTEfmPBjdvMqJ5zUwd8bv8NaCgAYzfh9VAa",
    "AWX7cM2pY859TsXifZrkee8urefpLbJFCeaDRUWcMo8n",
    "AWsRUddJsyr3YowKq6iZktEDBrQmFumgudqgNDNukrFr",
    "AX2LixfR7KPxhPhpZia1dPxafoSkxuDKkD5qfZBXBSBN",
    "AXK78vofKR7wnxBiazWbp679xPv3RE2aZzs9XiqFWspp",
    "AXuEQ963dya1USHXG99uHKZ1YvyD7hVAECK7qjhiKfUe",
    "AY5wnK19cpTGZgeZGoUyDo39dBjqNZhhYbJVHZCBs9Pu",
    "AYvQhqdJYNrzxbUtxsFS9V8CTpbFPozf98m3Jn9MRsRZ",
    "AYy46TkHpDcbL4NeRrtGWtrv9xiK1RmHwag6hxsLZA1D",
    "AZHgfwnUdssYz5EimQWnsdXpReKnHiGvX2zuPp1MReX8",
    "AZK2vpndUiUfRgs2cQBtoasxBGyPhqpkwCRgRY1SunUX",
    "AZgv8yKdSpeoGR63MpKZaHQmEjygSzxEEXMpY1hgpTyZ",
    "AaYCuCdZiaz2oGTqcxzb37UVPUS8xz25UKK4JQ2eQ3hK",
    "AacJ3z9hrrKxj8H8MWg9pnDD8MXTWxjAbeDvpQUApeLB",
    "AbDcBLHAHsN3QFgqVsekBUieQYRbVdLRMXXxhRM6wZ3d",
    "AbKRxMunk2uX5fimaaYvxMX8CYwho7rMGPBZhcfmXFj4",
    "Abpojmd3DFji77SzEE6cUtu7a8j8gTsW5DKnU2wA9z98",
    "AcYNCLhdDGnDGCdFqReiHv7bngvJynhivMKWqhWB9AVS",
    "Ad71SCy46wikb3HnCdHoo3exQnJQNCarJmwmc3JTKne5",
    "AdJb3iPGkLnU8Sbc5Sd9W2byVSgiGQo3DZ5npiNzgL88",
    "AdeAnA9WsaYA9Af52LAaaVhQzDkbo9oerP1dmqJ7Nh2z",
    "AdmnYtx61Wv9BCUxcydfJjWie1nZfcTFK434BVvpTU9g",
    "AduHusw5NHubLpwhzWYufSXXFxJuSu2N7WiJeArMUobW",
    "AeSC7jPxaLtJKp2RCQdSMPErGEGc7Bh5hb1pYFaKHGF4",
    "AfCsLJpE6N6NB4XCDVyjPpW8QVMSXtA6RLBWt5CypqqM",
    "AfKth3vpRHP5t1XvwKB4f2Ko19txycEN2hAGsHM553FT",
    "AfTkZGwcPYNkcSZjbik7LC3hysQhfZFx1qeUUk1oeksi",
    "Agh5gjNGdkvVXQPzjC6UHtR4kHcPeou3irwV83dZTHwJ",
    "AgpGdX7CLdUJBiZXHBqCRdj27vYV8WMFtu7saLzuVWSK",
    "AhL6ny6ZekAkL7xCZncfgGJgh92EE4nWgdavB7F9StR5",
    "Ai1AKRRCSkxwuWzqYuZvUTPhuVuJeeStNT15vP18aWyX",
    "Ai2Rz43RPmAn9XP3NvbVAWBLANhSh6BWGcwM9Yi1Ss9L",
    "AiMh82Va7DJs9NTMbDwuWf8ekarJ6sp3B28issrYm7GV",
    "AivZQhaf8nja7oNLcb8xDLheDFx7La3J5xub65ye4eRv",
    "Aj6BGVciRjhLPGgLQxvTBNt5aE1sNni3uuJ5gxiFBXiu",
    "AjJaWbugefEoAEko5Pu38gr71x2ed7d6b5PGxfv88S9u",
    "AjZ4j9srHyRXCM382bFEgahUnvWFds1wmGScCfat6MGh",
    "Ajs4sTmmnBwpaLBFfNv8fFdRvaoTEqqFDdQ7dDJSFjX5",
    "AkYMuLWyLPAyvbMga9rNTgpjvQcwzHu57gypYTKYGner",
    "AkcpAYYEp3JiZTS2f7yHQT1XKqfrG9hYmbosP3f2PPGw",
    "AkriqL7bwWjYPY2WZdWZ4PSAdQjzhGdgxTvGPygX5now",
    "AkvPZYcdKzuBvYVvtZhUn9hrvhTRUFVkBMSHf8FtEjGU",
    "An6x58BwKyz16bq2KH2Yoy8eHrGFsyYsAg5X2WsURvwy",
    "AnPwmexnHZd9aGrU2tfh1hcMxTShmxSm6vmF44QfrHZt",
    "AnXuLEyKpa94Lrd4RLPgi4iHxYoenQqugaRveKsUuG9C",
    "AoFCbkjQjuCjUNnGKSEAtBDJjfoZ8w81LKPaq8QLpH7f",
    "AoJUd7T9ze7atjC5TB6p3hDTdwPMfn9QRfRm4q6nF7E4",
    "AoMbNmC4a7fZ4VwSnANq2axfR5Buy3PNzV5TVA39dQt",
    "Aoc2SjLGumEoiRkGuyna6vWiDhtugi51hfYgGMJSK4XE",
    "AooF67Wdzp7JE4y3f24kxD5uvSqhVgPgCa76VcxhWwVL",
    "Aop6SHAc9t12a1iNvxYTHGGMDNSP7ivYCtEGWZhUFfjb",
    "ApUhQ145gurYU7896HfQuXd1rs1692drzV96tLQWcPsm",
    "AqRscdAoPHStyXcoxSQVTECeNNNQj5XjtduwSEgvezQy",
    "Aqr5gtTApoLHxoT9pTp1Uuvbmc2JCf5Y6Zc3LXonVjEE",
    "ArDGdAVGZJ4BLXBAy8Fuv1DEpW8YcnmNVkUSYWCGQTqC",
    "ArErE57449Cs1AUcqgFE4zoLm9SgfWBCN6tCb54fBJNc",
    "ArpusG2pQKfaYF5FJp8uWum33kmdVmPMpci7H4K7RBPe",
    "ArraaZmUHmoiiWAbiwKd6fQS6yosjNDoRCZkCbuWbzGa",
    "AsCRJ366TNBh2bHJFt14bLo8oLiixgmhYYZpPgG7Rmt8",
    "AsZQ679qwMNuZ428EmkkXLALtCkm8onXJBm3Jeyqy4Ji",
    "AsabBP25HUiHVUuxo9Y9ASYBsjxpqqb9KHu963pbDGWz",
    "AsdrCvvZ9FDn7cFd6q7r88HmcBrABcevWDbBEo9U4tm",
    "AtYcXvQw5YeXSNnaG4mx5mqP8vf8wLiaArM1vB5Eamtv",
    "AtYn7kJ2BBUFH1zcwUVWbeFY36UUu5MnpZWPgAF9mgQj",
    "AtcHt9soirMDJZP5WhkisrzUwPpH3JnUQmCeYZ9igzBD",
    "AtxmjvejxZMuXHNSNQLsez61hk1rM1crNk7PudAYyw8j",
    "Au4cfMBLcsT1qTmrBuXA7knahNYng9XwDCCBnXTNF1kJ",
    "Au9jpfYikRa8Kf4vYaFe6JGT9QDHhW7CQa1nozuvb9HV",
    "AuFFuUisixP2iSnoqjt85BdUUGH7EwcK5TtXb64tRSsn",
    "AuGhfV9QbY7g4Ng6Zb9Q7FiX1xuYPaNGdRAXnBMcgC1Q",
    "AuKiSad6h99ks9S5p3WxTDxnf216dKEqdUxh5YJWKDGF",
    "AuR9YzBEgSqPFPgC8adrsL2SuQCuNm1w8JFuhigyxsFk",
    "AuWnF7uXbcTxHR5cspLJBWYz1bUypgPyenMjUztgEj8s",
    "AvQPuCrmEY5j2zAj9kvU2BhsVpwKaa9nLHZ6gmKao5M1",
    "AvSST5MJhbzzCJjSxWWHZnQq4aW8beDcjym4EVJdjgTG",
    "AvrJXJ34k62QAybFGKn8J98ypcqe3XUEcoVLLZXXiget",
    "AxHQcUrw6UD5gcBTYNQM79YCGxCUxfj6SK8rqNnaVGTG",
    "Axe3uoGKY4E8TCsM7B3ckcHwhWJnNEtkmvBVAvuucrsk",
    "AxgUR8fTdMgWXzdQDAbss11zVzbdQsu7z4gtKhXi4xri",
    "Ay1vRYEsvLuzDCTRaWWTmEybmLDeyP18xUBH9KgGys9f",
    "AyXTTwJMViAgXc1bMX1TsL13FL9bWQXz9PVsoLqdcdae",
    "AyeDdgo5zYzLSKYRRXfA1DNX3pfGPdfMjVzei1qKvSid",
    "Aym4Jns8Xkx8G8BhMrT3CRK8PRZsUwu3NkFvr7i5Qnsc",
    "Ayz8WGb33KCQVY6K2FGUQJNV6T98bwUibnrYSJauC8yF",
    "Azia1MqZ1ByMJamEXJpkcVDaYAPqEWUoepRmKdhgV7AV",
    "B1GF7nfpFB23cGTCDUCrEwak78aMTFFruosfjFRQ22eZ",
    "B1LNqrUX9GBAwpKLJqjZtyNuteY9K31voN9d8Sfb2UoA",
    "B1tZzimE2pYS1srKt8Qoqmun4RK18jNy4q3oq4baqUrn",
    "B1uQ6bNZ4fTJsdfwbVJAHy8PWXnxYLHEmddHoZAeX6nJ",
    "B2dsE4nDXKDMNDTyCB91aZG8d39fGSPjhi2xLCNk9bf",
    "B2ohiiyCwYcgxh1bzKtzgKu2CvRPGcd9RdUrHgps1a5E",
    "B35TzSiScYYYMpSWMA7eXgo8ga7YpUXxDUSwZiMjTeYc",
    "B3SbxYcuVLK6Uy6UXSyvKYwG2X7pj2mYznsR827WgDG6",
    "B3gNKDSU7f5WKHkFonQ17B5VqfcNj3eUo5FbhAHNuwZK",
    "B3hSnkK7sftLTiWA7AeG29E8AdgzNvU9xK2jrGgQWDWH",
    "B45ChtCnSKtktp9FQNkUcNmVs7XyvKpkvxa377JdpFzw",
    "B4mHYYSds3HE3gRNVpfjJBi4Dew84gWfJZ5wpbV1VrrA",
    "B5UnaJhjUgTY1GsLLHBMUjb3KMKiKCdR5Hm86kLTBu1r",
    "B63RS5yhCg5vuE3m7rLXz83EVcueDQCS8you4dThraAz",
    "B65Q9aGDDanuHtsr92NvAqGkfs86g61TqhTQwN8cDJN6",
    "B69Q1eoHivthUNxKF7iNyCJZwcWXsBZPK1KqmeH1iX7V",
    "B6gtt8NFCvn2zdqfrD36KAing3yZfKZhemTPUGH4cW2d",
    "B74QRiNn5HFxB1ev6EXVT4gLdUi18zPfXqxEXzM6aKEH",
    "B7dmEfrZqjmPSLjhfzJr9xbSUWWJnwKuPA7ddB1pjvmA",
    "B8P7oH2JB4aHXrFL89rnWWU2SFscTF8Ve5J6xeFhJ4AL",
    "B8SjDseYTwUrR1y7gTcBmUFjgdZZcj6cxwQ2pVUCvQWj",
    "B8m74pRvf3iJAE4azWxMb1DkGNtp9qyHFSRRdNomVgTJ",
    "B9ePLbSyrHDbrYQ4ezmUQ2WK2FdLvQ2gitj6Sw1fD2mW",
    "B9miewZUqpvDDUiHskjUZhHrDiYVMYFRrHapeRM5Cqj3",
    "B9pArrjK2i9gaHCFbNBhzH5HQVHgvVxA5WRzLRRvSq2M",
    "BAFExG1huqHV5LFLffZNFKgk2gsCauG3PEH58NMi3pr7",
    "BAkhwUks15fT7RNZqgAKrkQkLoMyXBWW5QFw9w4mG9eV",
    "BBH7cL3wnJB5A84oNB3z98rVFkxu2kpXLRnoUKu6q9yD",
    "BBj4iq9bRxu2oZwPW1Hz8hx14Vj2W7CpFAiKb5CeRBM5",
    "BCFUCUJZnHSqv8iYAiYBtHpT3tQTb1pCxPi1FQnUHobo",
    "BCHwKvo2keswVUENWBh79ygQ4BiDpifiZHGDKnFgKmX7",
    "BCmGbSapLgaY7m5UD2D8dVCeFQfaYbC2XFi5SBiGYUhn",
    "BCwLCHAeCiGSXcC3Duk1DPn2YCL9pm62ByFdCpHpC9wx",
    "BCxD6e4oHDwz2h4kS6q9BVYLkGTz8ffaWBAYoTnKvLeu",
    "BDoVEZwMHre6D4Jcd2TDUe8MRo4LzS4hGkzzHFAjc9Ed",
    "BF7wVfw4bU1UpBTXs7suoMQ32QHrGZ2We7oFK2228zGD",
    "BFFmczChNxnNNgo7yM6oZjn6awxZK8L9QeBsToo1AwN6",
    "BFRKyVjFTRLoMYf935ytJfoWk84ZBDNhx2KfkzZqkirv",
    "BFayUfpNur7d3UTUkquNAmrHEGBmdrBLBG6UkauxfnYZ",
    "BGUSXxhQaMG9aj4JoKU9dCMYvaNimd4wzLiKCsv8QKxh",
    "BGYzp9dJiLwY2UZydyABDAjB9Z3kXJZZSssXNdyLpLdQ",
    "BHbBAHrUA4WXW2sY8QNCenqVUgq9no8S9BESqatdntQx",
    "BHmrSGW5sUYodMr7rgURKgaBQZjVoN5pcqbomQrK9Snx",
    "BJ5eRXnzCaezDmSA6oomrZVckSUojgE4K7uEEUcpCGbr",
    "BJAnNURQJBxh4RBz87nbMmnXcYyeDQjywpvUc5ZDCUrA",
    "BJD7yfpcasXEKFg36H7DGLXqy3nE1Ur4XrWvwbDdzk2a",
    "BJEPCgR2w56giEeSsSL5JUeJtnRpDQybyhFUJCZcr6Po",
    "BK4hGXqUo5UAz4BFS6k8sxo2avRWKbpmHzDr1N2Daw5h",
    "BK9mr2SBMXLoUaWo1dyaepRyh2Aw23ke9VnamUrVVmiW",
    "BKRDgtBfgrwEgRR1KgCeKvThCJnH3CYCFvS7SrfNvn6x",
    "BKSwGa3Hpt2bF11nDSzzYG9zBNSmz7eoL3M2oJopGZ1P",
    "BKUHGUuTDUgU8TnC2ySbMqDwwPm8fMEXG5fyb22vbiXy",
    "BKj3U1pUEzUNYYXiBG5grsuUfyZYKUueK7NLuBh4Tu6h",
    "BL4CQ5pWvYN7w2ZDcGMQmz9x7pBda9YodgGGgfcjc82R",
    "BL95u4qJRPJ4HRzdt9xYW7NDsLnmkE3TyFZvBdujNNwJ",
    "BLj7tFn9zthDykcWcYVHnfbc1x1FHWUz9bbawKJNHxXM",
    "BLwHbqxSZdogKkErTGo1mReQKE4hyqoPGPf7aV7xjfRV",
    "BMZ4d5VmSAkE1PKRRdkeHo8Xeak2cFTs1YZSPfDHDEEe",
    "BMy4iqjVubnnjf2jqUtPuTFenCyiKumnZRMzfA6LWup",
    "BN1vWjQ11SYcraJQLH37Y9D3SNtDNsKqqLL3u8ZdtyXZ",
    "BN86C74Z2AwrWrVd5CKidm4DHfY9BGc8tyzb7wwLSTFg",
    "BPZHzkXMii4SmSXfEJyNL1zxcy7zCthpyzR7f5TYmTem",
    "BQdBBWB8jY5JyZvA6BN4bVNhWtkqVUWoesackVDVzwF8",
    "BRMy3vRqgKWCFxs6bta231ebUDx3nezN93sSyxFXTvKQ",
    "BRWx2Dhj7cARTMqvbvosn7W7TfpE4M9jNLkq7KzGoYYU",
    "BRtKxj3BRs1fcREYtKrjvRoxK91cr4QWjbjnxwRFYbGi",
    "BSEKjB5ufiULdaU3WreEg5gm9ZSUVzuc46dpgnz9BFxx",
    "BSan9cLunPdnRpGqFgfEVCtXdNoG3YETMrp76AQTMDEQ",
    "BSdxCQcHbLr8Sea5qH8hAn66Gog97i7JbEBSqjzxG7x3",
    "BTAycv2x6rNfnEi756UVJXxXS9CnQmrMrwJkbJBdLB8X",
    "BTQvAV29hfZPNfwpaY25qFH5y4AN8j3wnHq5xqmcFvcV",
    "BUUR355iwW8fkSQv2qaz8DaqrXFSLQRWL83oZXFYkdS4",
    "BUifmQaHNbSYpZhGPBXsagaqTTgN423vUERfLTMr6ckd",
    "BV6HPhJsQpgYmwMK6SEbhKg8Yav4iS2xxXwinYLHjr9t",
    "BV7pikSY4gvHVWac8mGoS9VNUmPJAQjeS7XsVhWU9uqv",
    "BVEinxys8HDjPWais4QrnT1ESKb5oyyxUQdDkaaY6ey5",
    "BVTiieKf7KoPnZimmtum2B47ug11BbXvMsWY1fBPbzaA",
    "BVcp1QkJn14Vz1yWqayJ1JXEmVkKqiaQHH1Wqmu9ykLx",
    "BVqZL9Dmp6LFWUhZoQ8HiWveqk2SybkjgLEu5SgYwEaJ",
    "BWEEAXpx69AWjiZGRPcwbKLZctwkugJroek79PF9vNcp",
    "BWJr4gEMHPpcvUTEQqfGB6eigQRWyr887rnW2rSHXkH6",
    "BWRNTNhC5TQQK2Knek9XF3eJFwrv4epESyEYZ3oo6u8T",
    "BWv4a22qfyV7esrtzpPvMrWzpKx9SsqTdUaKQGQPLurN",
    "BWwcWFNHtw3XaM4u9iCXd4ViE5r8p8wjEpJPtMabrmr",
    "BX2TUJVj3fvCn1X6ut9t9fYvfBFEidjXaJg5kyffnbEX",
    "BXS8F2tWUj6m5UL1P3KmJYaoszf3E16kkBfzfuMe5GBp",
    "BXUw5cc7TAhuNsz4xHwjWw8r54HFSKDkvGWA5gTuCJLn",
    "BXXDpYqFKGztgaAT6tZcp5zfR6UBUcVESuRKnEYB6FsF",
    "BXta4Xy78wg5KTGnejHBMau6Kmjw7cihXV3iadWm4CGy",
    "BY3r2sDruXYxtd5X5CH8RCdc7MfcaZxCSnY7e9tUA9HD",
    "BYQ6H9Fo7gf2jg9fULiayEx21Fp4Cj9a3d2M3AqzHYq4",
    "BZLBZ6ei8AeG3SA13pqiEcuhd7vWPS2CHm6QroghFy9R",
    "BZU5pS8Hy2J5hjuStCrq8A4VNifA3ifFUVMVVU2tJQhq",
    "BZix8JNJoPiM3e2cimS9cnWKh6Wixe5k8bu7ns8RobtN",
    "Ba3T9ZBRc4nF4fY9EtMd3AyBZYMMUZzqKLoFzYaJDG5Y",
    "BaGG9Jsb7fNrbu8w9dnYktg1H6PfbGXvDUKhHZmU6Q1y",
    "BaL3VZ3weXFH6w2NpUUtzkCuprcq1Dtm8JoiwJ4EhDHw",
    "BaVY2ZxbzorGoKs7SiNzyhcE4iY9X1E532jG83jRumW3",
    "BarUuwfpvZfM3yTkhUird4hi7V9jStERqTVssiSvmRNV",
    "BbF7cM9uPTHcQ8JekgS6kXC5iAACan1MknrjHZyDzwuX",
    "BbPJrUh5Pji2DrLkL4A97xPVwgVDBvv1FcyjZ6HS7bcY",
    "BbZdHu2eT8yJyrj4nAJsMTGPPDPg8i5t4jwnd32NZLE9",
    "Bbcpdc8Ts7yQEGsiCCPq7y2G9bAnLBendUK48wvvJZiZ",
    "Bc6Rrs64u4SGNetjSg6Zozhg5Hmm2KSxNevcGN13uTzC",
    "Bc7oEE7wTUAy1jyiLZHsMN7MiMV1ihtVASNXZwQePius",
    "BcC22JqDRBnJJCWK84RCaQ7QaWsSuD91SwfrB3nKLZsR",
    "BcDGGseQAicWBWcoBgQHuLbfBw7TJ6hY7gmPADPQyQG5",
    "BcY3EpSWfxQG32QfQdYmmdtVeANQdsio1TFU3bYp7H69",
    "BdsSygj2v2ais4PExZEsESoPYLpJQ86WQzCDndim1Bqf",
    "Bey6vBPrDLjJ7pH6MerBF5pJxDLVRJD3FPhLQ7j1266U",
    "BfcGKTJpTBQ7yFXPKCBXAf6mfZrxzaEDRfEmK6cEaJzV",
    "Bfm2G4zXCeMUfcX2LxBQSLuPrCqZ2iLR5cv91pm5yBDx",
    "BfpVYXZa3cdcLRhEoetUthop3JHWJNRvrvF2sTCMKTPQ",
    "Bg61cTqLv3JtMn3KwJ8v6PbBTVucieFFyDvqPdAwqy7o",
    "BgMu4ZCxAwVwZKFi8HgUmU6HjCCiHr4Nqa22svY1tLuV",
    "BhAViAQCNDREBTwPLbBqCXBPAXW1YuSHMCZdzZ3ZhKNY",
    "BhLEQxufGcvb7L1KCdiGXS9LVtvdSSJEBapnrkGwUNuK",
    "BhN5eDazp9FH2fVAEBtJ3cRaso13FUPM6Legep9JdFv6",
    "BhmHVpEiaifZfhXFZgbX72V4tcCqp39oxK8LkjqmeRXL",
    "BhrENQ7uWY2HALAWcHChQh54UZLvjGMChetDzsNcP2c",
    "BhrMVzN3NSZH51woJYYoFRVG3qJgcxDRXJfsLcSb3oPF",
    "BiDBps9w3PoasCYNmyVkP7gVpzb5sKzUdJ9ck4pkmULb",
    "BihQDsAY8ajzuDoVzH69fGmvCxbAJp4t4iAiZzRXB5p4",
    "BipirGKJHwRRxL3PtCfRarHmLXTyLkD9YRnsWK8UiGRa",
    "Bj2WQ2ZZKxGyLxBMZELWy7T1Ec6tvXdQKEYcx48mTMKa",
    "BjqAv28qDEtLh59L48WeXcZT5v7zASnVhvEGm3ScayJr",
    "BkBnZVdbAgDhuZ6S9BseEj1Bx7KcRoqpB41WCmcCHhk9",
    "BkRmU2UXcVSqVdHNGJT6BitMo4hqjHEgrzNXRkAtWCPw",
    "Bkv3hTM3LmngU9Bgs34BNFiUs5podUm6e45A3r5otYtY",
    "Bm3r33cnRvDG22pGYR73ntKtpfujumWwvNRH3S8A3fZT",
    "BmBUWSh6BooM6VYmJDnEFtxCrL8Akz5k75rn9zXx5Xww",
    "BmPCDKfWGhFDPQ2FnjcTxCTujosp4VjmPtDDsuQxRj2Z",
    "BmVs9ZxveMa1Z4aF5Zd1BQ94s2YuzXshfFakFFKhVfNG",
    "BmjxqBTBTpxpdStAGHDB1BLKnPUk3f4pLgnymi74Fidd",
    "BmqiEY32618BNtAhkpC8b8zP5ANVgRuWVHZ95XCpqiGq",
    "BmtZzWLUuqoJKKfnGkJctwSUoZ5P72mBov3b17U6fCzG",
    "BnucUHc8vU366oNp46hQD2wNoJKXfMgH8roCf4sThWCX",
    "BoPwjKCNTg9ReirzMRyga3jjLnF8YuvD1Vqp7sRGRs62",
    "BocDRWdkcDDaMKDxsZZjLgFPUjL5yNoCoR4m7iiLNJF1",
    "BoknJSGtN7vsPSBXvJCxMgUKvSot4fB4fE3ya1mPjsqc",
    "Bor5TD6SgBhfeSmB1cHTSUP2iMDgbHRi7oDKSeQtCd4G",
    "Bpky8PbnL2xLsNSYGkinRLDGZ7t7gNppwL5UUFFp1Maz",
    "Bpmfz27LEYqFfWZ6Ar8ffWZYD9m7J76yta2kYvSWZ7tp",
    "BqguVTE45GeXYPh42Rq2Vp5Nyec6cqbyJA3brwzLWNuy",
    "Bs27PvXaik82mKbocKTKqWLdfzMq7vM5DbAh3VthT5kS",
    "BsAJ58UDiV7vVkhp1wuVxAYBxUn3C8iGxbZJCMrV86Aa",
    "BsFFDHYZ6BMRCymrxdku9PZqdPquiviAwsCXFgfTfdNG",
    "BsHLTvh6bdiYPxV6DaSFJ1w4yAyXZ1aQYdEpMwUessFV",
    "BsR3UJCn2vK81Y8qXog5xo9TBASKtSyc3mvfSnH6C7si",
    "Bsy2LJf9T1DCHH7LqTdRH7qShKW2XxnXcfVwKdkhUe9R",
    "Bt2uRKNCtqdiCQYjo55s7uM3HGDUaSF9a97HDmTJYjiN",
    "Bu4RqUqcCD7viqVVZXmGRLxfm9jiYfwRZbERh7LiM1Kz",
    "BuipjZgN7Jpcz8iuakuymmFdPeNn7FUqddrgbyt77hcH",
    "BunaJKoDUnqceTBnXg1iF3gT3t3HMqJjFg9Um1jvU84N",
    "BwSURDv4D8J2z994bhpymBb5YKGTzN7DeRLzLwJRBMXZ",
    "BwZMHVQ1sKrcbBbkHFPyjC2mbhY8oU3KnG9b3j5hAjc3",
    "BwiAy5GioAsLczRTZbcfw45rw8CUuM2AoJkeEVyhQgBj",
    "BwoAy9GBDSFVHiD6et7RBohJ8s6sxk8NWhwjfJLcs8hx",
    "Bx8zusxSLavQB5ahVuTgaCLChXsH72bJ9Td5RpSSsqwt",
    "BxFQYg9SJhekbA9h3skTkgjeG7zZLMvg5RKrTYt6u5BA",
    "BxPhM1hw38cvCHpn5rKjA91HBjjh9x7Hvq3Abx9nPuDR",
    "Bxhy2VMVMu8o5zEr3LzaQV2YnJHAJXamzqi7NDXapaz8",
    "BxjsyS9PUBUqcHf8oDDXM2CJsVpGGMgfrewdFvKubd2L",
    "By1XPQtBdwUbkPpS6enz6zT6KPRifi9wY1M87JLAtB1w",
    "ByHDeAbSgii7EPbisCa1rFatxgx51VzZzsAR6vCmpHfv",
    "ByHRFf51dd1JM6wttxWJCwndUpDqED69hWUqpRT8Yz6H",
    "ByXMRQBvZnq7iwX8kXbYQfFJPCpyKR2dUxr748Lr19pr",
    "BzHV4fazsxz68eh72CE8bYibNABLd19ZEagKdzmXWheh",
    "BzdpErpFP55oH5VS3JhBptRhByvi92kP1ka7rtrxFESD",
    "C12MTNpQ5qohkwe5q2e9DzkMx81WHSYoiiBjm627WjzJ",
    "C1EYZXnrzmgK5h1bJRCUpfoG4MKVCedAM3ynQv2Vzyzi",
    "C1JXoHQ67b9bDHHnwhQmwQ3M92iLY7ahhZwAHZ47ms2r",
    "C1bxxWeqV5SVFdAbycf8Q3yoNx1tjRyMNfihHUYXkf5m",
    "C1cwJDK7NNBkpx6u9BVkWssTj5gctVZa7nSVg6X8TkK7",
    "C1it23HW6xR6YfEpppmC49fGQmJN1UBChDu3qeeo2uqY",
    "C2AxdN38LpwzY6Gt2xnVZTrALM9wUqZE7fq4NE8UhzqG",
    "C2Be67SzBbcbvYe3DkQ84td5nRqHcYtpeSjjKkhsXHZA",
    "C2jcyddJnWBbGLdDBBV7uDraw28CFH8yapdAdB69EDuz",
    "C2muhqx2i4QnnymLB6tg3xBx5zF72jfMBZDHkw9stmsc",
    "C2oN4MLQGzDkxty4uCWKQZTbRSHtoRkvk56dK1SU9SUR",
    "C3UZjXAt2HxSokcXjCWnDwGTnx231cs6qAb2zSUtH7PY",
    "C3cLcmsdaYGgcjTtUQsFF29GtkR5HmorzDUcpobo1jmS",
    "C4Pkp2T9MHV6hKZGGgaHmVBJnnAr1piC62XKUXXEKZDS",
    "C4tDJb1ax3PU43HR9rH3crFqbMB1nz1Fp27VCEWDG6vj",
    "C666EPWdRJGcvNkYF4A2k16xsmwSNcHCwCUi1rZuzbB2",
    "C6serdt2cCFHR7ofuf7UKuYf4axJ5qFi4K51PWgdzrp3",
    "C7MsPrMf3eME36wpvZBAuN9qXGyyoDLnhG7pLviFkTu8",
    "C85Gr45VKgPubLtrXW5yPAruFC7qRqut1Qh8qywvDxkV",
    "C92LMJLSTVse5cJm6N5bjHq2vxBpJSzoprbdfG2ZA8Ao",
    "C971BjGwTnVw4drgYdFGz4KsPcmjdMeCSvY3vG71VNZk",
    "C9HFupVJcHeyTyU1FSjNQQSbZGKvXejL8mYBu29GJSnb",
    "CA8PsJdgvPYZ3UeSDpAktQV1SdexBZpfAzhQ4YnqepAa",
    "CAFJuvdJWujjC7UdsR6MDgyQQvqdXuKmnNxh76SzoHaq",
    "CAZvz5ueitWDg2XWPJRde7FTu1ZkDcF3muQsFVEuEf2h",
    "CAv84oNmuTXsHFskVcUmqnVzkkfxBLcYTtPoVQBk1WqK",
    "CBAXNviXzpBmh6ATr4ZKyev2h2z3zWH6bkhF6ZJrrxfo",
    "CBEsrX1w7h3ef1Gc8NLybSHvnNbSfQyoM6NXtrdo2BgE",
    "CBn4G41LdzQAKWFFLxCtZod4YRWWn7RCSN4MghbsQPbr",
    "CCJZS4Z7pwiEwByqDqzJfiBAVH1ZKnZ2ZGE6upfEhjyq",
    "CCLGcUi9yZdvhkVC4w44PAyMNgCFX1EqPaWwMTw3UAgD",
    "CCQkYE9n1sbUyxZixx34LUzitBPKQnTV6Vz45xf9rc38",
    "CCVgAW1CesmK8e8qzxGb5sTkniyfyfjbBDKLRhy9uyDJ",
    "CCf5AMuB84GZzBRwqdduBiHD1wPqbjiJiuF4KYRymzor",
    "CCvykpyNHTd9mmfvfcM6RKrNqn6bz6FvrDC5xUBhdbYe",
    "CD6PHwRVYBttLLYjFFwrp5u36TRkefoFbLGRb5MEhEiy",
    "CDF3XpUrEb8zZKnRWp6QBpEZCQFshMwcdyfBzn6gzxNs",
    "CDY18cz3hpGnh3gV4c7gwEYc4WW6PaKmMdypLyULQucC",
    "CDjRrzkhAEx2Ua4YvckLsHmVrr6S8tcNvAESVhrcqQFg",
    "CDoRS7oPHpLZUizZaryF4FmDCtVWinwQeKuJQbiMAaAB",
    "CDqgBQ8vW9Z9z2BjFtviKiTLB3MjaZYJ8M8DCkyFtvRg",
    "CEX9BXb9ThrCRnokR2Q9mEjQEmadSKGHKmvnAtbXwd4Q",
    "CEkKppUFUZ2x27pbw9duptgUQHNgmadnnbVHjYKaUgv9",
    "CFTbdJqETKiEozSVRsynf6QkbEUM9qRS1CodkRbfDbCj",
    "CFTygJBqpBPYus42LzGeTwchxRzmUbQQyieBq9GCRMNd",
    "CFtWb1v9wVsYAnevhqyicyqYrecn7MPCy5sFigNMBVAU",
    "CGdrxcLWktqBTwjAP5wjBf9DJaRtmdB5tUzVKw9SBnYe",
    "CGvZ55RDBw4od2awX3MVLndQ54gEpADzH52xD34egWHn",
    "CH9ST6M9uo8FMUZe1fj3rsEbE47SGT5NNbZF6LFpvyGp",
    "CHPwPDcdpuX9ipwAQwppH5asF7zLdzNGdKBjppYdazRi",
    "CHeGofZF2TB2vcEStKC8ftANdodZiEyRpNQ6yBA1ca9n",
    "CHmPM3LfAo9jfV9NumLuSA6CnNXQh7CUqyJBGvkimZmK",
    "CHqGMHY8F4SzuTRoox3b3udTSQEAz4eBfkr1ztK77VCA",
    "CHyzSjG9Di2ZAaBaRa7GHGCVn2wXSB2bTwzfqzo2YWxb",
    "CJRgskR7e27CHUQfSCwcUN5e6dEELnb4TkRMNEFox5aX",
    "CJTnMcnFZkKQYp3czfCY8K7u5etyHtvnW5cy8AXifDeo",
    "CJfJ37fZr64asu7btNa294YkoeWKE8wbs438ZxmmRoo6",
    "CJvKdDK8BKpyeS8A92YV36b2vroeQ2FqktskRnkQ9oGV",
    "CKRifuBggB98e9XeKU938fy3MZTmBpy3pf8cP4UWuMWk",
    "CKcja5AMcwRuFu2UQj6iDUGH6YZzoHXx8ccrvvUgM5qE",
    "CL2pdU9hE9eQ6bHV3FqQNXbFh8iXoMuBZcK9P5CLztbT",
    "CM9eBbcr14Abquc29nDqVvcFDwEATndMytW4WnY3uyUe",
    "CMWQdL4N625fxSSK1hFNUc8UtfsmocDnPYxXGowfTaWJ",
    "CMgrDrkEQwE4jaLYaLauKBcpuC3N3KTD9LWZSYK9PmiH",
    "CMkbjAjdfHcyCX8tEnoPNJBuCJ2oUtqfshFbMrJJN9NG",
    "CMx8Mb26T8EYjCxwBCPeGuxq2sXpg2xHUB9eEbh54dMb",
    "CNemX5XGJnNFUfprRECe7JQAg69JvCMG5CKA6jsh1qH1",
    "CNw8qmnSdXPEYviBi6VBZUptQVYd8ArV79rb6qYsv8WV",
    "CPveWHUF5bfAMgpWdTA5bbMjU7q5Ho8T4qvhM7qFkhhm",
    "CQF3YJTnc5kzBhmS5tZeZYRWTLkypLdeGsTXacdjUsgo",
    "CQPHmtKciTN6rFFCo4DNTdWdryKzP1KYmQDw95SSkgty",
    "CR7DBtn7qVnKdRf548VZoRgYQMxN7PNJWDTzJmkeftCD",
    "CRJsjuhiA3gUoUwXPooj6V6iamjS7adG9gxJuq1J5G2p",
    "CRVNqH3roWw1XeWqUF3iFdiAgyW1oktMborv9DbU2Nsw",
    "CRdQD1jaMk33ZbEGYGD8F9X92bo2SqtAgNuRNvut4mdW",
    "CRonnDhRQmWmYjgg79WdtSXR574YPFkH5ZRbgKpyZvH4",
    "CSNR2bBppNLgbqh8bZWZmSWsD452KDxSAFiJoN1fR5mz",
    "CSR9nWdTrQWHdBQM7onFkgVddJwX1yQpZx1mv6EvZyfx",
    "CTUjEjXk1PC7MZwNEbAnHo6oyBCvv9SthZckFk7qL1eP",
    "CTWnRSgT6wULpDoutM7kuLYKJnpnqzQufUqXJv7e32Yx",
    "CTY2MwvwLpaQrR7HqJfUoo6Cm2jMaGc93NzwHNVZS5j4",
    "CTZwWG6ZSyysKJsmhtNnPQAboAhrHr3TTRLN2fyAFDF6",
    "CU5LFts4AdfEHKDND6GrgnU3vYdjpekefUuYPrfjXMR1",
    "CUBzAxzDMLqLbAkcU8owPogouArViDQKpz5zh4FtcnTk",
    "CUcL7gkmrgC99XeWdMohE31T7wYYSaScU8FfExqnJVsT",
    "CV9f18WtFWjyYh2VAY7GEYpPhC7E5WH1qxvbkZ2rHtF9",
    "CVN2F8Lo8Kp6YnffgRK5aPHAMhs8znHy4eryZ6H5qXW8",
    "CVgQCrKTNYAYWuJmuQNLvY5HLx41APZg7gTzj8ftJPW4",
    "CVtZhcMPooAGqa56nrJs4Y8e86fZnYjZn6TEz1g1bwyL",
    "CWVXmzdiqgSab8mD4JktJptfByYKrbPVpvDVF9mvfLiG",
    "CWjeg1QqaE8iRmYAuZnPqJVP21daR1yhRUFsvQZTtqup",
    "CWpkcTByXyQSrhAPbAa5QPUaZoj8P8S5b29uBphwsXqp",
    "CWqX6nrYUo47Qftrk7cbzDhSuRQEskLPETdaCyphHmzX",
    "CWvM1rBk6dU9KMoSkjiGtWo5qGsbPtPoVLeWRCfPF3WV",
    "CWxZkDgTCRG76mnzTkvHdNuLRK6rTcEpVQDmZ25uBqqQ",
    "CWyMQ8vdGJ2vmkjxdAvzobmNrRLa4BgQrbAcxxoGMk4M",
    "CXay4ggyifruXGKZ5fYGfy8gf45HpYrBsW4SLNMBXehK",
    "CXetm1zQLV6MzESqcqh4MyewUGRJ4U4mFJ22rydYFmUq",
    "CXk9APsDnzqLyssX9RwfLq56i8hMz4n4QBrJXsfLR32V",
    "CYUNM3h6HK5JuwqZfuPoYTEew8GvgagYqYnyYf5gjayC",
    "CZTUtkUFweUkeaDG7BcHFZKvMicu8J9SgxrUJwB1vowp",
    "CZeQak6vAVnfiNsHrFbsVKwUQ3Po8aegsxuCSm8P4YE5",
    "CZiStYp6NdhuemxT6aNz1Y6kvqMsffiotT53mc29gUdM",
    "CZvRKsN2NC6Fm4r8MhYeeR5RRPTmTmS1fok97Y5m3Lg5",
    "CZy18LEJKV4nxzhZBBsEQo71CWkVVnh3SPy9j6dQp43N",
    "CakfDDM1fL8xPE3ov3ocQAsTt3sQHNqoGmMiJDFysNt7",
    "CavWYk8wTg2Wmbmjp5LS1FpgCSvqjPFJduCAPNid3ZMk",
    "CcBQEhaLwYbJ1PBiHB5GVh1xRN56wLwQ6UYgUdFpKTVA",
    "CcJknWiAynrHSrLBbyHruwD47Cz4dpzgSakgfyG3K1T6",
    "CccnbZ5mKyL1k85C7u713y7tqDvRvQ7EyacNMJaWXNox",
    "CdaPgxFA6iN5zFcKLpjFPUGrkJuwJxpLbakk5CCDEqaG",
    "CepCEAP6Zms3uVcHorbnVy5yiinBHDBeoZaGUYp317uV",
    "CfCTyrP6o6ym61nxMLo6tPnB2zeKTLnURrHBVX18WSMs",
    "CfrDAVESx46PMApX6TD9vFsDrvuymPc95fNyyYrrgafs",
    "CgLeZwXrqr9dgQEmHnYg7DShCZhgx35FrfH5G9BeCG9w",
    "CgRYSjbEDLqnWcXUDkrZgf34BgGtPVfp7nb1jobeBS7b",
    "CgwQgcPMXo4F6nM2SSVQW129cNYRVqzWCv86jnmkad9m",
    "Ch5N3Ss6MrCxENCXuwkQJoAf7nnTd9D6TDaagmKacgyk",
    "Chx67PR9QZ8gUDjFgiZJmd2buoWpgDa2xzHQEAYP3w7a",
    "CiQYwLe9P42pM7nWC7bhVmMjc5mAkjqjJwYF1KUUcDj",
    "CidGZBNcm4mfyaen3iEWgA6ZoViFzKtEfkRypppRJi9y",
    "CidGkgjZdGV2d3GVZYtmN6mkZM9ieTxifYXAuhot7yh8",
    "CidU8v1F3mvKJeaD3WdYPkw2aKefZLhFwnPA7CmGjy9W",
    "Citg6VU8j9rcnqg17m41i36d9j9raHG4iFw2cebaHa9D",
    "Cje74yCtEnTM8inJSUr1cwNHC3avxMbtSAv4uMaqqAN8",
    "CjhRPFhD6DYsr6yGri1wt9WAtszueqHuW961Weu2CFbw",
    "Cjt85NVEsfSMjDheLA9JFTy2UKVCmbzzzt5BzWW7e2qM",
    "CkSqYxv15xvCy9a6BGGmL7RKUmsTZReNEGargtWjLvKz",
    "CkbKzSHVr2amUGvw1bxeA3x4gYKjChZUPU4bFnrdUKen",
    "CmB3K2D47Z9RSW7tpHKx8Btimhg5mDWLrkiUayru9cx7",
    "CmX8nhUAoKJsrBHKR1S26358qxUud3oVWd7qkHsmcX9S",
    "Cmca9s4rkxEbwuj6AB8RAfGdimDSeUUFgzfG3krwckfN",
    "CmtQ59Fh26We1tnsrnKdVD6evsAcEf6n2eqwuPSZYDnR",
    "Cmzq1wEg1KaG7L4ZViWSoUUovc6kqgvEFfXc3buPnyre",
    "CnKQCJ7mEnnPiXkTkWXi8JEAwWRkNBZgpaVDBu3qdDyt",
    "CnMi9wasTTbEiXWJpVF8c8qAbx9h3yWab5U6QuiaMm8n",
    "CncdPcpuixiZfjnrC9tudp6jimeiawGZbn578yxbG8vY",
    "CnzEZERBPczYF75tNh6edysFPBdP5ZFrbqAQ1uGz2Pey",
    "CoQrpetf8BPAoS5mrZwy7e64Cn9dD3mQVzTy4uk8ngnx",
    "CodE4Fdxu2kUzLrjW9ho2TQsxtrzXqioGdM6C8288Zi9",
    "CpGHkLfCyiZZbotkz3guiHPv3tdwjxZZ3yiHPx9RxwQW",
    "Cq4UKpLmDegDnLFZHvpjT3Ft1zf1CTax1dnUCh7RHsre",
    "Cq5gncXtwxZVo1uJ1nfqSCt9cmREuDPWjsL3bTpwV8iv",
    "CqvvNWAWXtFVpMxEjKFe79s14E4hEXNTdMQLBWYpuvCA",
    "CrUU6NPwQar83Vv21CEMwGX5auz4AJdPo2kfwj9RQzTs",
    "CsTAMyweW4NjG9M91Y2VVKH3TrVq5887NV9RNRVT8GLx",
    "CsXD3zWaKTYC3sTFKu7qf1zcErN65oJrE932bRvqEb1G",
    "CsYCNXxTbTtTzcoFd9bp93ybuRSdDk3Ck6qwrpY7FPXd",
    "CsZvG8zQsAuNBb2ULzAe79UPnrCbBAYYFBVAekQyNVKY",
    "Ct7Jwa2iVKuVWpSXagTeCj8CxpsXywyKyBeEA8rkUtZU",
    "CtVk6acTHuF1sqFgxvTBa7LU4YQoNLW1TUR3WmLrStir",
    "Cu86PQVuSYVKpujFPDBCK1BBHNTsoVXmF9QpdS3Q1CcJ",
    "CvG1K4YGEU1onuxTRNF8G2MJnpGTGEv6NhMETFzUX4iX",
    "CvRcJm4ob8gMzimijJZCrT6eq18Bn9n8EQPnx3SqYU62",
    "CvSzTagL3UtpXGTM36KmUszF2NPVdbMMAjtnZMnH7dyw",
    "CvVy6WnHUfx5SBJkur8eLKRF8SQZWeNCnTnonB9cojKm",
    "Cvs4eRhcitQ2jy6pJBpgR3r95ynPMYj9VPRybJBLqMb6",
    "CwLxPq3rnJEUY9QYigDAgNHvMAjpNeihYvBLMePx4SSC",
    "CwPETs8hchHCWrJ38a9ZM6sPuMPBYHdpEg17V7sed9qn",
    "CwrUvqJc5c2JsLTVYj9ryRFejrGQ1cYyLWb8vsgVLR22",
    "CxTTg7cDzxeMoEdRY27dHiUQfqf4VKjTwCaGRru1kUmC",
    "CxUBr28XZ8FcNT4U8ida3dCTcMVpADKgx7t6yZmTjANy",
    "CxmNmNUwLiG8hSnDfar4MPTXvovR4Bv1TL95EpAfdQcS",
    "CyRsRQJhpgLSzgXrT1CKMQjBZdivXwWh3mzEXRCGpF6p",
    "Cyjp4ZmZrQyknDLhdY3skK7URLMKxix2fsVxtpYscEet",
    "CzLZTLVuU6HtEKPmjrEVZ2nb6qZKbPcPueASh8QscRqa",
    "CzbWZ73TV6Z3ousf4GFrQKxoMZmNEVt48cQDhZTrmN3C",
    "CzcLM4eXJZsRv8eSSkK2bv82CzqRPW2b4dmjTHg1DgWZ",
    "CzfLNFNhNjQC2Td1nvQjQ189s6eWK7i5TtpCVUFKRDcS",
    "D1FLHUrpjjZbfcKUegkyYtQbLRuQeL3HQBKUTLpaXzwJ",
    "D22JfJiNwZZJZBQMjjLCvchvkJoFYmMCGKp7B6CGhKwd",
    "D23QRK5rELd8kQvmvyWNsxVK3B8VLd5hwmmKC5VZhUCr",
    "D2x1ThWBzp21ZYgXnNkYqxwRUvaCdu2ppYcrHmMvNjSU",
    "D3EC5yL8joffdEDPVFCM54rqiSFA3Xi2P7ytNUnW7sRx",
    "D3FQin3YCyr9MqsN1Lreo6f3sP2tWvrk2yHst416TKtL",
    "D3mtK2n9m4z69zoWoB4nYKppm4SMruXm4i8FF2o4KUfe",
    "D4BiTuKHM6zp4v6FDoiRvX8icDAMsXah8DQ6WPAX9g5K",
    "D4YYkvaFFpMebMUSV6z6Bg9BPsZRXDc62DXi9AGhinZB",
    "D4eWL78BzorUHffC4nXeVYNiEYwj6uhenNdD5bGgKPAo",
    "D5gU7qUsLYaET6nMYb13ME7WLRoej3mWKh5ss9B5YoFe",
    "D5gexjPRTdgoEVDQFgSmdz3QXCAHXmBPPxcMVjL7kc1A",
    "D61C3gDkdc1dXRV3J64xkQcmm7pe7KAuUydGYdVKVDXz",
    "D6fe7dEMemxjSe84xs7oL6BDELmjVEMwfA48DHtQ2e49",
    "D6pFoF5ukZmCp5EYC4CN7Kgy3epWmZWAPkFuBSqMFcjs",
    "D7CekBwZFC6T1H674udRy8v51tJmKZ6wBHv3tG6rap4k",
    "D7Ds3wtmjPM62AoydbA1qLifNXjHuoDQXbC1kgtgRKp8",
    "D7FNvXMkMVLNNSvRa7b86as8SMoVCk7HWhtcq6BLu9YP",
    "D7FmonRsC44Bap5VEiqMXAXADYRqLRbjVZmzZ6781jer",
    "D7fTTQvoKLPgoBErSSzaYxMFE2Hy6P8i4xrNJXJkCbj8",
    "D7mb3ftpQhyEoBBPsMq2wRMuK2t3DVjzcQyKYy1PfmTR",
    "D8xCPVLXoPFc8rJtHxVm9Zq27tUaGDqdFtYPdX5j6sKJ",
    "D96wSoXvMMdjFbbHUGxgpxVVdcnCvN9DogXoxbzZgVvx",
    "D9Qrgos3DXiLHcmoaXCsCBBCiGVW7WRAJ4nSW9yF4dyi",
    "D9VJ1DM8goa9fGQvzdX81RThPG7uHah6guPFMx3RuNV3",
    "D9edWziKXrvgwPaCkCVMnre348PBCySchQnHe9HDfnF1",
    "D9grSucLf2AAvm9RxQJdLwJtRABEiremeWnBK3ShfKdV",
    "D9wPRJkcoUibHg6Pys4huqi4Nbxg4XuSC5RPrxur9sWD",
    "DAzFouC4Mb8Gqmt1DNH1eFW8guixQ6LHptyQ8ykrbkvX",
    "DBAJZKgAs81AvRYHEtpcmTQUSGEJ5WFqJtdYCXNX1Dn6",
    "DBQeFiqWUnQCpoZHbBFUt5vuqnsL4LawRPwydbfgG9yq",
    "DCL6LdnadLJt9k8PbnFhTXeLSX6o5ged1YGmaKhEk7GR",
    "DCS56QQJLtHASgKcPHXQoBAcA4e7JnuSdY3QDgcRsVBt",
    "DDZ5hDTKDQVAiQByvytsJopb1hcwdXAq9khLNjMwTYXU",
    "DDcF9NcKD8525jFJ8o5rS2a5xnkLxChwLVRMEj3pyRFW",
    "DDnTHNXNhMYmv4uB4cQDHW1coQQ2LHQYwCtJax2p73rG",
    "DEAfYkvByL9tY9o6cFtdErsxM7fTkE64mCfqkg4NEJKC",
    "DEiZUPa4UvwgpipZNPn2eowBjdo9MciwK4sCo7Az3j1U",
    "DFFkds7PUC5EpWpLoW6vYXweBtqv6mm97pf8yXGEQ7Zk",
    "DFNWbinzQCLjoMKxvcAHVQXJ8Vtwx6HXcuKJaP6RuWRE",
    "DFPhjujS1dJ8ZMRGkhVfY1YWMxqJSmXmLA4jnDY1vYXS",
    "DFuHBMQu9o6ZMs9uw5kCaz68Z68pMaLpNbapMUJ393NP",
    "DGG7psD9oegt52tS77q33vpL7UrfNUzdqSH78rnXS8a8",
    "DHg1fm3SL64Y19eZEkarWWbTsQbFuhhQ8KFPgvCdKz2a",
    "DJTSZ73p3zBjEzcg655e6J2MqF8mFVHEWvNxd891d2XH",
    "DJWHv9Ab1v1JgNFjFa8mdy5QDJ2y8b62SJnUgxc9W5n4",
    "DJXVhh8LdgVPdVgsBNeCMHaH6faZHgYgQTjYoQ1GLQKH",
    "DJfny53tmS7MGin4Hc9GvprJVc4YZEHZVepaJJsAFUWh",
    "DJoorkfsRXEj8AdFgBD6Wu6nMukNntY5zztgMnycSEqs",
    "DJw7BXxYxxtG2eBp9cZsuQuPRLHqnDzqNgakX9LQkT2C",
    "DKbkCP6MVKRtJeZLjF4KWjahjyPpqCvtWgoEe6rRQMSx",
    "DKtr1yQu7ETG8T9KKJJKkSgfMi8uDt4CZt8GCNhWzQ21",
    "DLNb19vYwpdsvtgyRPbKfsY6s6qz9pJeKeYyxu3PyvBz",
    "DLNcww2Ps1Zbsr491z4ZxA8hNXvVhRQKE1w5Jix1MdN2",
    "DLPtUpu6PcLkgWP2rwDQwnPX2orgGvbkrjNu8dRL2dvw",
    "DLpzxUgGhMQzQiDWjXtEHvwvqETapHTsbcEsubF2M5W5",
    "DM7skrPrQAaY2qzGYbWZj8yC4yguJVVNov7VfMJv9zo9",
    "DMRosyGvTeLA4Rd9kMa7bhry7vTB8faLftUD6A64bcHB",
    "DMnJ69XoKXZzV1HPQpmNWvJaHTJXgt7r3AAC5wfKo6U7",
    "DMrotDtYZ9U5H3BDwPwtEdP6i8oafqYpUy5bn36v3Zea",
    "DMs6eAuscZ9JnVAXbwah9tC2MN5CS556GLcv3aZRLccr",
    "DNEUu86Jt8LmJXsVygAqge4qSwENdZAiqEmyxrRbJeZr",
    "DP9ff4UUrSvUdn4yXRFWrAzrakxxxzM72FHCwv8T44H6",
    "DPouEWmXzPiUUf1cR98PrBbmBkuXLrYdnY3ryL56nfSh",
    "DRQmM3nVDVpFETV9gxDJfMN2LsisRhxy4RHfCYX3R32T",
    "DRRsVmfoTTX3Gvhza5tPURcitjyhXZ8gcJSgonsxpeZA",
    "DRaLnKV5RY5UCehhXdkSVpcCE1DJZyoachsUatEVtzqL",
    "DRkzMgagnCvkAvzHuhmGPCRjaCn4vobnWxthTSPqNoGa",
    "DSa4ESnWa6R6WbiEKt9ZFfVe4aoXtjXkxqcVbVDktG9Y",
    "DSdti6FNyFthWAXbTZbCHgxdynQ13RCWzXig9kHVjMU",
    "DSnumKhBUkonMzzXSyVHR4yD815fNKY1j9qmTnaBHvcW",
    "DT9zaTr4iYEDoxK37YB2sjMZCMZWyETAhLcVzTaCnUe7",
    "DTBDvadutxfVH6Ch2shQSJWegBwMoFr8Wxg4VyXVfNUS",
    "DTHk3nSeuSMbaoveHUG9L71DtoityvcM8SAgLFgFX6p3",
    "DTZP34SPh5nHezmioQ6VAcPyLu2jGnafSGS3V2eW2PUK",
    "DTwL7NMkc8sGb8bN4cV6RY8bWx2ESDrAVdnHmVLXYiPC",
    "DV6q6awdEKAPwsserR7jdtg4kFsVfjKeFtcVHJdKcEYm",
    "DVZm3HSbRr2kjbfMSJY6F9XRo8ZQf1DreD9PxH81W2jY",
    "DVfLNMY29Ft7M5AMVwQCFuV2KnxHRX43KQkJRnoBhutV",
    "DW6H7hLWJEUUeCmSqhXbpmLoNnzhxkVGrpLLqYUf1Swq",
    "DWLNYWGhA2QLJyrbU2cbjWa6gDDRy8wzFp41cmdM9ca8",
    "DWjDLYp3qsTDe9EGyrRCAa5qL7euFTDgRKZE4H7EfthF",
    "DXYYqt257Eq2ny1hA4xvDGmrXWMSdtUzGMNhPpEVz6B4",
    "DXcqPa5NMCNGBNF7SZJ5Kdb57snS5ykz4yZqJnWL1Axo",
    "DXkH1tWTFtXfXHbp9gUX8JxH2VScnCQRaz39126jykTM",
    "DY5YPxrmXUrbCXuZxfw7ikLtLLLJLfNcTTbdQ4Bzzpvw",
    "DYRwr6bD1g4Ep7pnGSG4ABha23W3gea7ntnSqgEm4m9e",
    "DYVvWjZZDYBAxEfJT5yWUrcyVqVK9k53F3CsXAqcHU3v",
    "DYnCMvykbS7pkCnZGyd6o8KuuF6oCFfu5RrhtU6ePrF",
    "DZ8CDUNvdzfKipT72hhty6CFQsXTbgr5eVTxc4u3B6P5",
    "DZqpFYmQDeBAynnHLqFpPRF7tuo8mtQVz47pvStSbGJV",
    "DZrGVx7bbNQwsVzj2ciDhTnWiTRHLrxpx8MbmE9izff8",
    "DZxpY1B76nVq9Rr3TbJR6jN2EoaUPA46XadYDpt6yViA",
    "DaHPJoxVr5vywod1BxWfEJnzkmgPHqtebwCvcwg9JBjA",
    "DaYBd7ZoZBLvGPD7PjjLwor3PnTzJL3F8BeFFDRgzh4u",
    "DaiwJHPsyhL8NADmPht64DdAtNEgUa1wSd9hSURzR6aK",
    "DakKdPMtu6KmRN3ds3wbjnF11qsefqSfNuuBCYi9h9G1",
    "DawADmK46yCwChhEy32CEsfDJt7tpFj8A389gjvEYqZm",
    "DaxHQCSEwcgptxsUsTJtdDPxcCkg3Gp2e7vGUHzMFquG",
    "Db6ckCXBooFFGuWQJW7c3gM6SiY9ZFbfgyGEWEnHtPin",
    "DbGuTExwg8sbcUqCJgs3s1BqUfFy9jDkdqU4FMoUeqjH",
    "DbUDrMdTCfb79XVpyFRYFyhnxbWtNRJ9tKJSZfFnsR8R",
    "Dban4hcT3nywey4kKKgZjZU2QMKnPee6sFWFuPQrDUrA",
    "Dc7aiDQiogs3HvXNDY9XZqFzhikd6HuRsQsajNE85AS1",
    "DcDAxTi16RREurcbWrq3LjDiuhcvqyWzkS8TK427XMFo",
    "DcHu57mirR7qYBrUCufMw2jYHxAPP7zKiV8r4xDaU1oK",
    "DcMM6pUBrm8pWU15UgxZWEofnzNfhAtjH1Bmh2ahFXAu",
    "DcV1xGvfedk8wMbStwucECriRfyereiFMhmigNsvSoNj",
    "DcpWgDogHLBCXy4t6xfgpjMh51mt5uYQtwhnawZrGuFk",
    "DdTBnNExynwSWFg7o5o4UKJ5XeKdvWvFa2pwnuwehDX",
    "DdsDH8azy7mr6uUJo4AW1wXn6yJkZjsJZ5bVazjE9RKi",
    "Ddzafcdh32fZMKYmrZdejDbGurSAeMgRCjxHGJMzu6vB",
    "DewpFuDbssJ5rdyWyNAwUV4tFY5cbWVZHC9aLJbzNA4n",
    "DfNbMW8ggfi4LUb81wQusmCRRu5QFeVTrr3iJ5vzQQKj",
    "DfcGs1sZBCcXw1dLPqmoKSDkbz5gZK5PwcnY2ipeHPEs",
    "Dfm3TrrxFawh7PkJ8WamJLHgWwA9yLyimnpgfdGxsqcV",
    "DgDRkjALyU81N3XNXVDLkv67vZY3fQgzXyvFaeT6px5f",
    "DgGYaRFpP1cBnU4JEoj7MY7vpgd589fqfSsmd2eVJQtc",
    "DhESqzh1DqEGDwTCVMJnBY6dhPx6ifPYzxbuZYGn1q3y",
    "DhG9LH3TgAtNHopdfifSioQVoLpJQf22BvwjRAU6v8CP",
    "Dhb6XYcfVDaWGhJjSzA994XYQtDSkovqe3Ti2k2iX97B",
    "DhbGskkU9kfRJRW2fF5nsHvZMZM48KcvFGGwjKu6zwDD",
    "Dhd8AYQsyBzsGPnxvpycWjhZ2KJU4JUGXLfr9WcWaJV4",
    "DhfCYEbWZECt8ViJAzU6HYgA46id78ZHzZdZCtjDn8Uj",
    "Dhwr99ofM2CE4qqox76KXArMRQ5Y3C9rK7PxHTDP17x8",
    "DhwvoVjkssxWXZkcK9DXrwmMbJhKNVQG1zKHJCXX273W",
    "DiZUDMfEnsnMhgW1Qj1Bk9aRmS6CyErL3X7xiXiQHnBR",
    "DjGuEAphgzpMb35L9XPeRg86Ba9YgLRxQJ796xt4kJ58",
    "DjkyMGzpvFkdnJ1dthR5djb1wEjHcv6wNisVHvTyJHoe",
    "DjzGCxRKgs29txz2wskBnovhhuVspuoGKfrdp2PXpUCr",
    "Dk3Bk8egG3JZ2QRojEWrYtg9Gk6CGNdZwXBCgTs3Rjpn",
    "DkW5S2fP6eFagwmoskGkVuMQiYehzcoxbyN5VpFyu4LS",
    "Dm4k6rFTFBe6miKMFPDG872bmzqFjMd6E9HXFcPiq3ag",
    "DmKVfeD8xpieXCXDBRPhnNLVUkxQiHFLX1Zy7H1U45vR",
    "DmNzVyvKzUgGsmFLLaQg8VLVzmLFyTkW7wfeFhzzBrFH",
    "DmbBJAAqx1s85FWVkNVq7dLkMytu9tCBQgditYS3RWYN",
    "Dn1T4gH2kcieZ35S6izgDwcBiXVok4hT8iPFtJ634XUY",
    "DnZCH3rRPGi4epCPnYnoqKizb7yyfVi5XHUC94o95FPu",
    "Do1tuBiH1edSKtPGq51XqjgeGgxjVqC4kEqr8RjWsqkw",
    "Do4acUGwvUTPdKbMe6dahtsPNcgvrpxDpV47WmnHSQsK",
    "DoEwR94FRPosHkKiWQAd735BaPKLT4PhRFWYpZijD3Fn",
    "DoaQjnjQwK5jbp8X9ydT9HVL838yqL6WoarsTEP48oFG",
    "DpDfbi1jEeFJwDv22Jqwo4XtZv5stJsEahzstznksTNp",
    "DpUnP9bL8foYqnYMBqGNhq3t3xRFh1BwXzvVe4BaL9JV",
    "DpwUoCuMyh5WrGnw4NxV5CRUCvwMGRgMpjeCbjPCZra",
    "DqBuXdAHX22Tfb2EfGKZbXU4QSUzJXKEkgz34PqgjKyt",
    "Dqtu1Um2e7wcZ8VxKH4zjB2eJdZ4okrBZTxPCKAM5VLv",
    "Dr14bmfdbWak2Qwc7i6zc3rPGAt1Rc93GhhNohAUJvhg",
    "Ds2Grydn9Qe1sm8GCBedeng5JgUKozH6UuZq6SFtg6EM",
    "DsMcUb8ZJnYYn5sPWcxyA6aHxsyrYBqiEgcLG3dajJC8",
    "Dsr5yzsxvVC3CcvQw7BTWNACwwcwt6zdLuVPP3dhzM63",
    "Dtc3pLNvTWEAPoECDMAsxH3B2suHJLdE8XFLNYoaWGCN",
    "DtvZp87CNSjQ4JcD9KddhinkFwSaK2ATa35Jw1ME9tPD",
    "Duiv53HvKnjFAwT8pB1VUieu1GV51N287JGkyMWJczem",
    "DupENpgGzq9vok58aJeyVqD3RTWdxSJAvaNkEctSAAFa",
    "Dv8x4XNoMcXN6HH4Ybav5yz5RSeyiw85dJeAbPMbtygE",
    "Dx4EdZEZHHnWr5F5QyDrMBiSeKHRZKptJ8GvgsctpzGz",
    "DxADwKC2Hvri2yf16w6n7bn5VtG2uAWYyDG1Q9KQn3pF",
    "DxqDsTvYWKGKaNwd78UPTDhn7obGmaiiSRVorNXritVj",
    "Dz2MyUvzTVZW2iu1rALyccUw1qk6WAxbbc8A4apUjvJr",
    "DzRXv6HE4Fb66BtT8hATPcgyUjb2nMjgwMbH2RvEC7ht",
    "Dzme7SDWDtbfQAWw6Ggbv6Ewp6tkcG9Jz8bCu5T8NwCe",
    "E158o7t6U7qfAvYquGt5QY6WCkPESZaXR9h86U4zQDTj",
    "E1Eps37hvTXGB6tb2nnWdALtQ6B6TRmDmCojg95mJjtf",
    "E1NMHkb9SyuY6WYi3zV3uSzXepihq5wPBkzDuy33ZgTi",
    "E1aC6SQ1RcKyaZFfdQWKG4RZ3amnArFzmSz76fY2j4BS",
    "E1fprCvqTDaRRdVXqes9XsRG2Y9JJ5nWGvuWKqfhFihi",
    "E2JBCcDDMoj1ATpNtSgsdwgxegFMxAz7LL7Rp1L5Z9hU",
    "E2MsGvRjQJLELNMa3KC4v8hD2U6rYydTapGkXADEpF6a",
    "E2YPXpRfFM39fyEJhZwrdqpU9f4u1cuc8FLbuaFw7Z4g",
    "E2z8xSoigCAfYCCriLmmwfewLz8S7ioAcJCqGsMjQzij",
    "E3KSgHdb1EmgJt288T7fj1P5URArjnkRHprGTvhai9nF",
    "E3QnLDRvKsQiqdzWB19UPuRvMCm67qDkSq1FZQVpMArN",
    "E3VVukB86DXdT7PJ3kA2rLAqewXrxvymfVttF4LNABux",
    "E3eGQzGMerPL1YHyCPjQ9fjSXdgE3i6B4EC3E8Bj6UPa",
    "E4KQMpmfBb8Xn1RsnuCted2RnDuk84HM3goG5w9RkrBv",
    "E4ZZ2b8xwRYTXrAVZgUGU82pCCUs7eN3uUKcfHLkTiGS",
    "E5E9HHhMWGXTx5NAb2RhRxQX1AJR7byCXXmM3U4gsFis",
    "E5EUCWFu19Exg77Uwe9h3aPFAfLnM4wTq7aCNcpAxpfc",
    "E5GwjogHKKKVeNQ33AF29qSqhrQfgaCFPQh52n54kt7B",
    "E5SUR81kuUkeVdx6WwAp2SYqhuWU92kQPf9qieFuL2xD",
    "E5TD3oTX9rEwtWhpnaaLFvDhYWBVCbWiarBBFA62Hm2f",
    "E6c494SYaw8KappNuqQFGvriUJPtNNVLeeUqy4QvSmf9",
    "E6dkDjnVL1NUzHvsWeXihndDt5Hop5JrX7Z1wYmNScAn",
    "E6kR1oiKUBFuEP5gth2cghTrhNaU5w5j2PX2o2d3AjBR",
    "E7KDjHPsEgiNHQjK8DvJbhmh52xGtZZbg4eZpHaWWqfA",
    "E7fn58Q3bmt5TK7Rg4wERLE5Xr7As8n1wwzftFRwBNsB",
    "E7vyuxqfR79QfJZKECudf3u2MwnBnbFTfuqKc78Q1hh5",
    "E8MyxUSgUHdkvw93MGyCy2SUfU9CYWfnuT2WSc9K5aFy",
    "E9FCP6sXfm8sns15QSezqDPWS4Ne2fxSW451Zs5cyujW",
    "E9kuSq1DqcghBGiC3HvaixMeMGW2eCzjHzHonqtLW18m",
    "EAviTUTZcrxYUhWFfSGCTxQc9xc45QWXRRmPSg6JgjoY",
    "EBZNFLSYifSqeRgENcZJGq6fDVUg2nAxn1kXY4Z2aTD2",
    "EBvXUvwmzpzhLeJjGu4WrsQC77y1nzgTVAh7dR8yh4S2",
    "EBxNUE68w9iwZGoeoJtVRFThKiVfuH8tbCxofh27ZQVe",
    "ECEP4q1BLyDppvb4Tq3WyfMCLCcfgkVZPCir916M2k42",
    "ECt1zL1iJVGYzJgYF9bzb2gbSGmuKnL9sdXNBmftXseC",
    "ECt7UYFJvAotwnoZ4PmZeVMacsWLVQo2DeHU5RAxPhEQ",
    "ECuhJkqgiCiYzshM4NinvodCuT7ybXunykL6wSf8gy9o",
    "EDqsSQsUh1GpLsyZ8B8v1j17dSpJUPjs2cpcRhSP6eoT",
    "EDzgUvq94uNtQuEVJR22EhjeYbyYb8YNFhWQjbc98sjk",
    "EE9gDY6uQntqwWxdR3pk3MYAV3xEeyXTvTjhpiSsENZL",
    "EE9uVjaAkPVDAPU9udgW6JqkqSxSe8AWPwyAvwqMsfad",
    "EF16RScPWvXX9mwSL9E5G45ZEAYBA8qn3YMhgwXXJZin",
    "EFZk4iMH7mhofhJXwctBKs2sMgKEHDcJmetsUpsV2ULz",
    "EFxhJkPycmKNCWtrC5RbCYoYF3EBQpKCT1u6UxhQem5r",
    "EGEAvaiZKoCehHDVnVdnpetg14ZRahpraiHTKymaZB6m",
    "EGPzdZRshqNDg85G3bCdffkmLiUaKzk2Qfu27hHTYpzj",
    "EGRNTvt6zezFJUUg3aAo9FrtxU3jj9VkNBFvRJqiiXpo",
    "EGm2PGSNkJqgv3X9nMZPmgAq3edgGJ3yNDtw6cuA6nd5",
    "EGz2xBgeAx8T5LYEFTgaA9JipgbUx5GvSFEHitcjbTfq",
    "EH2XvS7bFVakDaLkcKcPmwuw612NLqyJXgaTeKxAet1n",
    "EH8cUbcgMGqajMK5LSQd6pwCJYWSm5CWooT2tXiProkP",
    "EHDV8xzFn6CKmEpgQ8jxjhu3t3mWU4a3HmmknbXi5D3i",
    "EHGUpLrrivCVXPgPP5oPSwtPipMThV2vDaaPg8PSn3hR",
    "EHWwwBNXCzH2JnzCwDaAY8Ydyd9RmTvRwrf9pAKHocME",
    "EHkHzMRjPnBZ86WRmBqrQRooGzLfsD8gS44VGUaLg4SM",
    "EHpSk4bzDRpuPu3EnMKbzVPp5XcoJZVvMYe7rccgt9M7",
    "EJ7npHL3BF2nHM7JrLXS4WLAbGuydAS1dUEdWsQN3yNY",
    "EJGHP5Eq9sqmEyKhpmwHmYF7vThs4mwzjsQ6wW9WXj58",
    "EJQqrXnE56jwJj4FWHj9zPkJv3sXuX6ZmRbpa5DyQAkQ",
    "EJSwd97WX4mFoFJFS9DygQPxfEi57QaoPTypmotJbUWQ",
    "EJYXdN2A1nhiL9zF7VGTSLEsGJLGfJieNuQdDn3xqKJa",
    "EJqjtusGjVHcEcT1SNpRTXEpQiK7bUbt66ZqTPo2Tdh7",
    "EJvNt54PzAeZrV7NVgRe1K9TyfVX3o5xVvNysc32vJHB",
    "EJycP2nV7QwcNMpGsZ3B4cng2Cmqme2wVcKjw7oeaFiY",
    "EK1rWngvuU7rqrCyoRvpwoRCMcmLfVNCpsyNf6yCYsdk",
    "EKUfEecdSRNCtNY9NymLZQwqBijYnaWmxeCzGMZbLZdc",
    "EKYMrX8zEaZ6eRgpyRfJfqFqee2YenBQ4UGt4AD7nNfQ",
    "EKyXurEzTfsuowjmzJE9KBkEWbFZRdvycdbheYuBeCQE",
    "EL3JR9rhd98DE4SwuLnjS2vN1yPakSGDrt2qQGRAGraM",
    "EL52pqgz2HroJiXRU9gzPXp8U2nwh9iNWC56L9oUpiHu",
    "EL8Z3VGqEEKwYizzkFw9FG3EoUPBndwiAMmxK8XQZL4y",
    "ELa1pt4RogEcVLFJo1FGdejw2PQ4Rp6ot4VGQ8tWPKJ5",
    "EMZGLonGrAZkawcrrUjp6PCPYYGkR3Swa3uLL9Kiynrp",
    "EMfrkN6Um8wsFs8cbx2sCb1ZneHTS5aN2PmnDJ1BY34v",
    "EMwa1LTTKrvf2e5MqFtpTYhJgK8zLiE2JKhcjLgtpbkC",
    "ENsjAKKo7YAZUZr8tZ6Dw7xtYbWZJ7ZZ35d8Ftn6MFXx",
    "EP7DdRPxHNPq1aSvmh8ir9ohS4dMxXYiC95GvecWrDtG",
    "EPFQg7aydxTvfpMpuFsw1ckH66rjrXFqxEnYYcC7h3mD",
    "EPGxw3nUmgcUapBBFPs8DES8v3UPD6yWJeLESQhHBaJh",
    "EPR2bdpGwTiTFMwsvjz56CjJgZD58L76FiiLgYk2QeyL",
    "EPkzXDVbWF4XvPLSVttRQuy7VAZjf56FUobjUsQJbmPw",
    "EQR1Gd1gtt6hzk57RBPjQFcwgpvGAUqKDSESRVe2ZzWG",
    "EQcH3kbbQWR4M7GtpMfgUoLSd3UVWGsXbPT8wyjEceuo",
    "ERSV2xDXDamhMrxnjNxZ7sU7yW9Dkz58Hm9dnCcVvJ3P",
    "ES2MKgLiDcC51Mwss1eWmc3EUUg3i2LsT4Hzamnxu2bu",
    "ES4E12UZVjE477gQcFPKzWuPRvBeeQSAXzbnfd77LCLc",
    "ESDQw8aj26aisBSthWn12RkCfDWVGTMn6yCMf6B3vq1j",
    "ET1rAwDgr4a9xZT8gnbPJrfjtRiqrHhfwNm6fyy49FwL",
    "ETBb4FZPn75vRS8oKP6MkchDiR81geNpAwswXpg9Q3NV",
    "ETxjvzkpEAUQZTaJiHUhqUmV8AoadquieyMmH4eed8CX",
    "EUNtHnE4QBPP5QZoWmgZrHBUnBDXsiq6njLoqJjc4Xgw",
    "EUWvYbDShVv8tDs961pTLCucyZQp1DAEDXxVphobxN5T",
    "EUazyPzrPU1kjZifgPqoKmXnLYwA51AuNJ9YRNkSduL6",
    "EUuS4wyjmTqKfz6J1wv5QnihY5jGWNZp2dCfyHFNkYpW",
    "EV3K35XVFVWtLWLyjBSjVpD4SVUS32szmJogYvuBGyuj",
    "EVFVPk4xccpwsXmJg541EzGksJG4tJqZPBck7SYyHESr",
    "EVWHpG94KTMZPMWyRVdJpqjxNFDvgRtwWe5K2FKuCT3A",
    "EVX49Xu7vRJJobWYDovwH2EP6PGvZYrZEtfiMgwq5s5w",
    "EVXfuyAXX9wTFp38DLdt4pmzMktWDkvD8TnmGkf6XqGE",
    "EVjT468HjginpkDnuPM847JGVDb7awEvrZ3wQy9oWh61",
    "EVzpHNwzgt1UyX7gm8JNA9sHKaCsH3kWYEtjkEfhQtnV",
    "EW6b2EyjXLms2o1v4C3Mynfnixt6PTagwFieGdg9DSWD",
    "EWgPYUbWd3bBrQMv4294ZtYKT38ZAGxdXuEY7xpvphHv",
    "EWjeg7tmMe9TNA8y2mSaK3zpTNmt8ZPMDsRvfQ1CmyYS",
    "EXmoFEa3Hkek19jkZVp6Gg1YmhiumgpfvEcWYpcgSZCZ",
    "EXxmAswZqd9QTBeWKkHCfpiWseRFmyKm2pMvCtqojKEV",
    "EY4GTAucCri4KNB5qY66sCM4sfDvbpQLPFgCAj3FQoRV",
    "EYMnps1KATMeHeyFQq3RNZFBFtrCE1tmvphRz33VeyNV",
    "EYbr3AVJgzTsthyNLwALUdSCnJVzjTuPLuTHYp5rpsv3",
    "EZ6fvp4xBmAevDycZ83UWp84sLsuFJRRKvQtdoyKSbRT",
    "EZSnutyM9swY2r62ZgZgGPkzPQfmadce9G3XMV6QcFxt",
    "EaU8os9jX4iFR3Nuu1THT7BWENoG68V4JNB2nW3dDF1L",
    "EbRkPqXAT6fD82dz9oeYu9TbybyxzYzgKTxxMgBGXjhq",
    "Ebe2rTPmgu2roRRKtF5fJcgyMpFv69dcMyqVy6S8u6Fw",
    "EbjrozMwex6gX8jXAYp4raxinE2Rnkvh7HBxWpPbEwf6",
    "Ebpiz662taq78RZtgzTjT6Ar1wUjMMsX6EvJ6LRv9ZQq",
    "Ec9zpUHU6hUMxaopzpFV8embT8DREVcDP35CxSrJqjFg",
    "Ecy3fAo7ShBRDCkGqfgrUF2wipoFjbXCrXYkBHQxvUmU",
    "EdKL7FeMMCm2MiChWep62y1p2oUHYDMGYXDtRaEVbr3n",
    "EdnC95tS1ErnH6YyUZGWtpfNrkWaYeavH9wNQUqoedh6",
    "EeE5q6N6Y3miHXQWxJrCsMqpZbzAsVTbDzZanUe9GBdS",
    "EeU31LKFy3umdWwiwQD82RuckBS9BkT1qQ6DpijUjsZh",
    "EeURR229UHZUvKCLfvbq9XRM1CxUxbCioG6ibjqhzq8w",
    "EekwwmRXdKw8fNhnJt6GSHZWfxodi7tscbWbA7TbX27P",
    "Eg6p4AfA7sdpocvwGNxy7onhhbusnXjgMY3D884tzo1h",
    "Eh58N5wVUatJtaLjYkaLJpykYWS3E6UYaQ9nx3xm46JM",
    "Eh5oAgPZd3Z97uXcUmQzmeyfw98bJRF4pqMGnwFVz5jw",
    "EhMdVuNxq1UCitJ2KK2Tn7fTFJGGSJrQ7jxTX51UzdYj",
    "EhdvbV24fpjTvdo7CHxLGGZ5Ex3Y5j9uZtKhTm1wnP3P",
    "EhhVKvtKKBRLbBdc4B7DkkgHfvVMatiDKuhZqH458vRx",
    "EicgDuN8w9NHcswt86qJEDzJteUnxeywQ7Zg2TxL5gmL",
    "EimEkHGrd9bFfwuo7t7JaZKHrVeqJKDCcBfVtLhk46bg",
    "EjGS3XwChJzsaNNMuNmBxz7RZ4zTQdLvWVmW61nVAH2J",
    "EjTaaNangLc8QwB76ugmm47ZHLdR4jqNKbd5WpFaNAh5",
    "EjtCRtHNSDdhcDTbGiEdVULQWpP4ppS2c3oah2q8k84Z",
    "EkFgK3pjMhR9uvqpGwASCxTJRRi98aaCrN4N7aE8QggS",
    "EkFiLAvDNa6QTEuChvtUH8PCeZztNucqZ4vtEAFYHGfK",
    "EkhkBs2QL93bZyxehxuwATM6UtnxdZdJ5NyTC9xmU9t7",
    "EmR1defuen2Y1XqsFGfYjLsGjF7GJiq3gsvnhVt9JGCA",
    "EnWuuH7bbsAZCSeNfBuoicZbC3fTUtFJvSucC6X5xgx2",
    "EnYsh7PU48aPogN9NcRvrk12gJCKmgvXVEd6vvQGfTDG",
    "Eo9ntHXk5bV7T74MU9ThXAqRkhceD76Cf4SgygqAPepb",
    "EoYGrhR6sW7eySzY7Wf8Du57sr4v1EpAgw9sadMXXHq8",
    "Eokd4UuW9ixmGSe7UTJpwGsA2cxE2fxbDgq9diD9HzLv",
    "EoyjFvY9RBQpyRNx1Uc7a84bsC9QAn5A8XwS8d5vGy83",
    "Ep2XeVnyxQpjwnqwQ3zX3toERyfVjUP9zH33ysvXWVbN",
    "EpM2GiBMuqxSJnQ83Y6LskECgiXX9EPZtQsz4gyxQ5ve",
    "Eq4Pkhf8ABnEehxJTjaB5AohJW8JeYWrKxia5y9X5gz",
    "EqNNFqTWp4j8HN1mW3fUYfNJBZnR6VynkP7Eee1waHZd",
    "EqSSAfBnEAAcxyWDk9mbBWhcABUg4oahap7GE6fcYR5V",
    "EqxWMHHMSTjGy9ryAQmKfYKy5X5Wwvt7Mfg2AFsksA9u",
    "Er3MUZRx8vp2wJ2fp6vvUmVH6vuBdJVoWAuQbjTYVsPE",
    "Er8EHcD8MTpb4wKgmUfbcNNtveVpnkFsCReK4MnoHzBp",
    "ErGmXgBK4ZjVLenexHJX8NPfvC6Y1GuQVu2GSQbtaC9K",
    "ErU8PPiiHnNakje2eASqjTMZ9M7kU165nDMfbUFNpQMz",
    "ErWCWp8D4i5DWwrzBMzmx2WQ83s7T1Mz4jxdsTmoCMpn",
    "ErvgNhy2YRfrNkSnMYrcnjaCxCvM7LZ5PAoaJLqSXxRp",
    "Es6EnMhfoVStfRMVjux2adaYKDsCH4wA5YavmUoW7rRM",
    "EsD2oPN8DQtWydRspDo5Xw5w2oStSjvUWfUFWqXJKssi",
    "EsKdBJ6vKfksVwd5jkJHoTGC8jMdFzoMJc9JaWLiuQ2E",
    "EsjswBtKytqhq6oUsKh1Vg2oAeATLWqF4DhWsdp65ZJ4",
    "EspvHKghskKe3rR51izrTZ6CUCDrvMZ6jxJLe3b5vLin",
    "EtbaAo9By3QVQjV9A33xUWWp9A69bFUaNjfKUfgJyF4T",
    "Etwkj2NWQZoH91SHmYqghoB1JJaSM5LGgttagCb4AZUH",
    "EuCyjHjqzbtvFWZuhk3ZsfCWJzRhsMUBH7ypvX9aPLHZ",
    "EuD2WQsjYoG4LSYNH2AEsdpX7XerS5RiKbyH4kHc3ekN",
    "EuRYbYQVTCdhx6ZgdrFHjixLYnCm8LCgNvGHkJWVxEdH",
    "EvBKSGDx4vGqx2fHBrcqzsr7G74wvAyon8tLUep2KKBw",
    "EvRddiSoMzAg2nqqfbgaoRXJxAWBCvrxXgMpMUCgcs8R",
    "EvjDetsRw3N31ovh9nW7rHkMyWzUE2TzPuxxuCUpvvUA",
    "Ew5rAYTujRbWzctKCQLzmjWd1ABehMzBXS1p4esCNP6Q",
    "Ew8b6XRq2fXEbn3BVwQhQBAXPtybKmPq91HG2WBbz1T3",
    "EwNfsZkXyYjx7BaJLHTPbZdqNEY69k2PhCjcEekUycPM",
    "EwcrUcZKyBR4VMH8vfiY6k8bZxm5aymzxEU2TjWtGMhn",
    "EwsYy5Vyv7hHw2okwRQnEyEKaWMEsA6ECiyZg6G9K1TZ",
    "EwxZyWUgJGTbhZXZP6zxWWLqP3koSdnhGWdAa16dKmbq",
    "ExAgn3ro86A5Ng8CGC2mDS3LwubHUqPX5sfjjffy58bY",
    "ExAmpRJkTFSm1TQabYP5jbfZUd58m2GWrhDvZH8r6Hp4",
    "ExBEcPhRRkLiCyWWG6avyh6CVxQeVo7c84ARcc5Rhp8N",
    "ExVMaZCi3pH8LPMtqrkMusDmQTD613g4fZCDxoqDjKEq",
    "EyA7wFZ8upbQrskSFdfwvBAFxvUQ5svaa7aU14EqB9Si",
    "EyuXHymBkRpyHdhQaHQkk618oQ35k9yaw7V7SAff2aev",
    "F13NzETRqpFPGoNFtm4txDEDJJHvSxcUwF7pAAtrZRDc",
    "F1ATafvEy7N25A3hyQAwUoGVXsqea2jSUzESEEAkojMv",
    "F1H3FnspmUNxHcbsJdZ8VoF8345tqddRw6BXxr1YcjrF",
    "F1Le7Twd1rw7EzTBEZAw8dSc1MKcRFAMevXkpB7kKMdV",
    "F1eoekVDDzzGcNmC9vVhRXZdqLVSHgbmwjh15tKBGQ45",
    "F1fA2W7iqCcs3bmN17wE24E39tH4cVvXBSs5PM4tLRJj",
    "F1yv2NT5sY84TYV4rdroAUNAvq3936wQ3cpNbvpT4zLU",
    "F26mvjW1LMU7nJzMThuu5dfBGw8FSJ9UvDc13xNn26ob",
    "F2DLMJBCqdJooc431f7HPfiTVp4L7zb1DtRy3vqkJyfv",
    "F3YXP59dRtvegWo329q8n3xmwCCRqoeVf1ddyF8LNPQY",
    "F3ZesgSj74rbBUzcsEs6ggDx1mFbR6yoNQWLWQ31Kg9z",
    "F4XHv1zK3SNQDN1Kp3b2nwvSv89X7J1jxdnuKriTdXp4",
    "F521rZEZkhhMvVYrXxG3muK3w156TDs72pZYyyoFar2J",
    "F5U4225x59Krq44VysKqyZ1c2nLHe6mQ3J1Si6JT3wpG",
    "F5ZCb7qr2oKhRX6EtEWLa73eoq3wFBujf6mn6TfaYio8",
    "F5hBqruo89xbtkXcPgJhecXYn6SuU9NGnsYTdbimWBq4",
    "F5kXvgoyAu1owdMfqDWjJbTvvqMRFvWFJ8LGQHwUkp3L",
    "F6BfcDV1K4PPMRGtMKfBcy5Q7T9jAzJCfhh2jNPADmcN",
    "F6BhNu3zeWYwdaqpTyJt2PNzCyaULDVpBBozeQH8UWcU",
    "F6zRdTUezpgzgFr7jz8zpwtxWNHrXXQr9GfeEwJcn8GU",
    "F75tTMy6u9QBbFhPivyD3AdQDVGw3zDotzLR4cLwA6jB",
    "F7FgkSdY4RDLy1ZCynB124CdK6KQAvdVrVVFUpYbbmBs",
    "F7RmfjSM3wgbZS4SgYgJYXLvpSbPey4nNJT5sYc28hWm",
    "F7m1Soekyaovgm7o9fscKKy2pRtbDhEdpE5mmLUgyaGb",
    "F7qNHJxnrTrYW64XCkPzyBs8ZNJaPRDHeATdmrJejhE1",
    "F82DbXXLh7NpcpRcFFF69DL9cFSifyM1NUpxUNBd2oTX",
    "F8PdYg9WF6hehF8nNatPupfgZkJFFAT6h3NF6zozSaLk",
    "F8WiL6nRSbyEFmFCEyonKeL4xv31TQ39w2d8WvrN3K62",
    "F8uJhaMKAXPtBhXKsUaiJUwWopsjYSXcAsWRbsPSKmki",
    "F8vs8yfyMQM4aDS4JaYgMCjLEMzPsHrNzYw94GEh4u7r",
    "F8zMwNZLtmSXksHV1bGFYkrMwYehq4bXCjZB1Lh9ZEGp",
    "F94hhsTmnQkeB1Xac1cVZJiKHJKuD4wbZnxedSw3r1dt",
    "F9H6Lm54iy5qjzNFPAcE5UuXkwjoNAkNMYPKC3jKFqag",
    "F9UDP17GxsTWHpvVVPiVtwzy1JTdiLAB2GB13TQEGsyi",
    "F9Ykb8gFuhje9wJFCoNfNP8Q2AiX7K5pHGHCcLhUuwBA",
    "FAWNpntooArkJ3NJWgy2AQfHm7Gjmr5kpsLwNVHok99o",
    "FAb3znnm65obrwr9X1PLuEfrbDLZWDuAg1RWD3iVGNqu",
    "FBDhSfW3Y8iLc8XQkkvMJRn9TGGyBu7DDuoKy2vaVn1x",
    "FBJvUW5gTFmWziKwZSa87cPsX6ahuiZFXzLpgTjrJ5fc",
    "FBSmHvcWeshDwMwXefNJeNJPNm9jeC8H3GRfeR6dYxAZ",
    "FBWdrsVSPY3U4qjqkKjZowxECT5Bb5fDCMLh2rsDDWkh",
    "FBjGzVMfTunBbyGextnBSNu1kouDtTQFteCk6SfrGFH6",
    "FDEgUpmf2tzarXhtyYL4rYQr1hN2Qm9RgYZ6NQkoYqQQ",
    "FDFYFufjsxoWswTcnFraohQ2dtYfSy5uKfaaJeXXDpRS",
    "FDdMk2UJX49xxB8ZnCKxJZPn9nodzUBDhPMK7mY5Y5HF",
    "FDrDGLbakQynUgRJ3f37T7mYYK71FpYuPDFt2HKpGG5K",
    "FE5GSSKrL4YAoQkarPBDyCg81dYGoarUBPx4BtVkUULx",
    "FEF1SnjtRhi4qAuL1nrUFPCQqngBoCRn5dQscT5E5nT4",
    "FEk1VG75a56iFE9bxSpr9S3fCZBex5ZQnxC3VuFAWvKX",
    "FF5LiFfdEvoi9poatBXdRX8RRwFrE8KXujpSakZnw88e",
    "FFGnVm46gTHtHzrTRaAxz1dKwVGuigkHfjuKrtRiukpk",
    "FFnwi3CcvMTvFkw1kyHMwgnA6RUU5maA2NpfJ5hY8fT",
    "FFtZayd6KnV4mq95BjPHCswpf2JNnREucAnXQNQF5Yx3",
    "FGnM2kGHuP5q9NisK4eZKJSRxaij4KoUFFJ2ZgUA5cTC",
    "FGwhmS2Q5DcSxuVrzTDcnhuBEm1Qs3x37SAVmHvg8vrK",
    "FGyhmRnfURX5em6Reo5pfmPaenkaDwPgTBiF25MVW7ud",
    "FHf3jTFVk6eVYsoBncTeXwii2pz5zQTh7aa8upWBxR68",
    "FHmCY27WTGVohbtQoXFyHWyHCYwJqk6k4RPT2RfTbeVY",
    "FHq211GkPqp7yqy94LvxYSFKQwX5T4KCn7W9t7fNHJML",
    "FJD3YEfsnvxoVz5P5g7CVTWMqTgaE9MGQt2e8TX8AxW1",
    "FJKMHrRBaq5hmaGdeCMj4JqdyMnvZu9HnsBQnKKSeJ8G",
    "FJQeaxYAnwqDXfaYjZUpGLdKGKrLH1GWKMX7zKasq3gD",
    "FJmZfaswwVPLZZWojrpU97ajNiRRjDqh3KfAeAjRTwqL",
    "FJn1bMR17e9byoi4KFyrox14ZYbdwgbTytUxpzSscBbH",
    "FKB848vLMrvGKUN9yKrNJ4sbwytA3CBgWc3kvMaUeQCo",
    "FKfy5ZdfL7PgGA22oEsMU1THtVWD3Tc7itJBKYEPbuWZ",
    "FKzAAmmmKD32N9sWr86iKb62YdLq1x2H15xyyi39LLD4",
    "FLPZEfn7xWBWhf1bH47MCRkuaUC9bmu7RZAHjdGRfCFb",
    "FPCXsyane6uTzd4HykqaUBr13im31h8J4EVzmghbrUVm",
    "FPcRUrUCTjRWrocwhdpvV5rmWRQ5wHtGUrg27EY76yty",
    "FPcozb1VQKS1ogmcW41CFoBnoDLAnS6tErrgBy9AWaBG",
    "FQDi9qEoL2jZoerzKNjP9HgVurhyb7BY1KnTA1nkYtDE",
    "FQzuEMHH523faUMVMrCxsn1shyUs7tq7kcf9Lx4bYMqh",
    "FRB8FqcUCimVnyqyNJdA9NyDazCESvkJUH2g5m1vsVhg",
    "FRVnQbzttHPHZnEHcLZo83TsHEKxk9CuQ4QHmkMkR5gA",
    "FRbds2v4RXVqwr7cxMenMoXsZdUHfHmPHfgJMB2Apkj9",
    "FRdu66aFsRXGCRCosxax87FcnH9187FzFeRdMe48mFdk",
    "FRpqV5rAdqhKCUt5Ac7aemhJhPPUn5NX2JvRgPRoF8vj",
    "FSMRjSHa9Rpjjt3dMuSpmrExJBPQKDwkxjzNy7nvJagb",
    "FSPMXfYhjL6c8eSfLzcQiHFuXawfsUBrsbgx5HxhHn1d",
    "FSixgvZdzmsMnUYN31JvAoUTFCNXN57a38vepfgsQDfj",
    "FSsjRJnYajqijkh7ZvfTzgBXRNEX64iNqER2gn9HeGtY",
    "FT5n3sAwoBcwZjowv5WMfZgw6WRVxPu1VEeNjFBKjvGH",
    "FTha3WeHyUhvtnZiTU77JYr2NfqWjX8efDU1XM2creWY",
    "FURCUTh4iJRRL4qzrwihWUZki19uB6MfVvE7omitvA5x",
    "FUb9bNNfqX9m7V94Yrm3Jv9jMGX6GjrSnYau5rCki4Hn",
    "FUvJUsxVNnMfFEsZWv58mPMWaRVmomNej7Z5xk88XzeE",
    "FVCCLQN6ntHQ9LTvNKA4rbZHPU7z6S3K9MY7cyjSfbaT",
    "FVQR3gJQQFaqxqmeHPgxVZv5bGFfHRTJc9Y1yzmFTKeR",
    "FVcHmd2eHcMCx7mvVxnKfXVZVqiQ4VEuGMDjn4UYDdu5",
    "FW8fiqEeynRfdf4WfZvdj5HDVFNJmMebuLyvDypdCY1S",
    "FWDS92JvGBrEecwg6TCxP5aKUMYamd1AoTvEuMpBTAu5",
    "FWLmdhaaoLcsSNcHfFmwvGkK7YAKQ6gkzgsw1fvFyMyL",
    "FWQsSK1KazaXCkBiYH6ctBZ4RfMDEu5hBff8frNefb3J",
    "FWU32qkfWB6goShcCvL6Xg3qbn9kYiDjc9ACuAKtANk5",
    "FX36zp6WmLrSjhLVmsy45ibn4gBSbvjq9QD85ZjmKVGx",
    "FXCvmLcBdmx2mzvdLPthDM6wDaSZ5GydAbit6RwyxFLA",
    "FXD9NyAz3jjjc8sKyJuoPvCrbz4uJuQ5Vg2gKifHkWY1",
    "FXym1WWdmiHiyNuqigmRYKqxznBMjEEKwV5ebrVxm7yY",
    "FY6QwKQBHEo8nNDLndJtyU4LAWyu4UxM7shYzsYvUoRz",
    "FYMU6fz4zK4cexjTJUUKnLFzCwG1dYjjEqNT1yuyAGgu",
    "FYUL3nktLQs4LdH1D5ywyTKZ75zrCYG7oxYHfPMpQcuF",
    "FYoDAJKbva32iQfNDjGbK4y1nWFB2edMHptf4mxspi1h",
    "FYyDsRF1ex5giR54FauZWTfEhCjUH3oB1pdkpjkjHsfF",
    "FZZpRi15nSFrnY2JX8fzCPegGMeEeX2HFCzCRDW2KmX8",
    "Fa1T1VP8RiFJG3onq4U5WVimGYaviuMBJJ95mFPA656q",
    "FaA1hFLdLEddH2DmLJqTJbvKWrQ6bU53V59LWVuSub5i",
    "Fae8i1Dq25d6ufPwQ2NSL6asHTT1sHqxAcYb2Lf1Y4jv",
    "Fb4JcmME7vowyiDpz2Udr5DwWH1wdGSgBXq1HfzVTVQq",
    "FbJtJ5ndQgHtktWJ2NDN9DZgtKbDbP3cS1Nc7gyhA7ap",
    "FbP4AUjNtYN5EuzqnKq9jjJgtNsHSkYnQNhnBAKVN1Gb",
    "FbekJiyWzDQTkWwfmEtKhJ4jj548ydEHkjMTkinjetWy",
    "FbiFpHVK7RzCHfubHSceQBaL5wdWEavYBJcgFLdvJES3",
    "Fc9UErormQYVKKKWaaQxUJ5pheUoSVRPjUmdbDi2srj5",
    "FcHhvg3ppdws1BCkPS2QYX15HNaEsfWkK2q8HiC56qHc",
    "FcLf1KxGzKY8ZNEGXm9p6b5fZGv5qoozBP37scMP3egt",
    "FcNG56LVLQjFctACLwMGjxEa136h2qYX7z5nBHoYQAad",
    "Fcrf9wcnUSpzq1tc39f4EuMUhVZ4mnvXHYdaugBJTtWT",
    "Fd3ygX5syxzzfQVfu7gcwJepiHbEwRnvz97DCdpytAAR",
    "FdrZy2BVoEov8bwrvhdkEhW8odoPKJsa3P8n1ZvwTJgZ",
    "FdubU6hJodcc1ysRag22zyJWdUMKy6LnLTNM1hX3m9vE",
    "FeGFrwFRPjhiNHzuMH9V8RAwSs5ErgJjL8dgXYCfCM6s",
    "FeM1dvGbngjoLGuhpBGStJEoxYJKuhkTtXMxvtJHJdh4",
    "FekyTn5yGubpAoa6HQUxyapffWVX7gyEmDJMLjtDAvmk",
    "FfQ8dFv66SPQXMpUzgkP4SAxuJFbgmE5TgYVD2DvLP16",
    "FfS9RjEUPnVvdqbuizSWqAYZwn8tixSytp3C49Hu5Efj",
    "FfeuAmiXYDxF3S1Xoe3ZgXGEJDYNpLkYuQVKAaXho4ui",
    "FfnnUe8DzGzntWLqc6VpgbW9viY7WRbUHPdHTrfwxSsU",
    "FfqS9ftoUUWcdAoZrxFTC4cDVqvP8bhKYXV23XkNJm5W",
    "FgMfNhNp2kRdp8uYCsYwWsmzaYnabxhGJtdTnkSyAuUp",
    "FgSZGH622ycdwvD8qeAdkK9wjuqoBzWkspdK1iB6HgNQ",
    "FgURtv8j3V5QCNsgGb3xv4i2dAGdnPGa6Yt7nAA6rS7Q",
    "FghzhhuHoofx36QVTXw6xUz9eHR4MhMiTNEemSJcDscV",
    "FguvwbJ4JTHMFhLpUp5yDwwgeGaQaB6a2ftKwZPJCe1z",
    "Fh2HobsDCWqegrL4Rfnp8bjYjiqW3bePed81nN9bVHu2",
    "FhF9QThe8o61yNoRoWVVonoxtFMGfhJzH8UKgLTL8BGK",
    "FhKvtozAHtENq6Mwj8BDYAp8rvxJfNgbcFc6goPyf7PV",
    "FhNJHNxJF93HK3DXa6BSC3pzwxZcUEfHXWRbDWCpvfTJ",
    "Fhu1wYgb1UnF2BrRNXkXQx2QByirVLSQYBRaz5dAV817",
    "Fi36MjPE7NKHupvyE32TGc475HmLwTJxchJDnTUyhArf",
    "FiHmKYynmZNYEozkbtbmwbeuFZVATddQbWkCgyLW8RNe",
    "FibmeyUB3vf9vcAkHWNhcpcMYsuTLJtDxZcWsHGkL1ZJ",
    "FiwwzMA7KBxyg2XM9UmBdHrkK7AT4Nzuk3zcQmXwqUnD",
    "Fj9pZS8QtFxQ9ebT5dNoR25HmpjcxMFGhg13gFD9yL4d",
    "FjGL3yVrb7VwLwMJzyjmQ6gpcbDeotm9xLPYAizQWufk",
    "FjPo2GLnTZufUyHzGgmzEUe9aDeJpJCMPgx7oaMkoFgw",
    "FjTPYWG8PW57M1WjEAeEoNsn8SuPzs8HFrXMmLrfX8co",
    "FkdXXtxQzt2SczzjE8RQCaC9yzrZwGKrjFUW8q2ykwai",
    "FkoYBTefZWWUbWyqNDg7w95Ui3eyFpEvmxekL2b8LX5i",
    "Fkpzi8jqyQCPYsXCdyUxD23YihnkJskChmh5fdeKMfTx",
    "FmSEc5TTzh3FczEQ4Uh6iRKF2J6FQS5SFLrUtUtHcE2T",
    "FmyQytcGAZMH4jJmYJttcvstXjdTAaRzQR4WqCFDF8z",
    "FnkhLd69TzDaHafEx7Nuptqtqm3xageEANUcTUqwESKo",
    "FnmG6YaR1oEm9PQ5Vx36PZXB7P5fhKj64w8kRUFHzT79",
    "FnmWQpruGnh1JFnwqp5z2LCBq9GMhTSbAQA7AnQCJnVS",
    "FnuRbiqB3n8SLF6UPuA7qUkFUMKpzbSr4VTVfYbBEkmU",
    "Fo1cRqLqfvdaL7idbJWUNytvat4DA7AKy6GeKYSsMbnU",
    "Fo8Vh5YABvLE7Fcz1n2ERY7xPBo1zNGLPwNwXxSg5mtj",
    "FoHoyHkwp96VLLGLprN2Xpe8caHBbXU4GddibgiEefTi",
    "FojH8eb6JJh4XiRGNffUVD2iQrQ4zCHs5W2qHsFXwSH8",
    "FoqE7QroDH6RwsaP3H3V8XrXtG4XDADR3EzLtoVHnEps",
    "FpBb5myxDrHppGXtZUt5yRS9kEUpnmhWxBXaeNwVoBqN",
    "FpLG9ijcEhva2n8G3nzS1fxYgUffhZX33xMLJejuUQnv",
    "FptDCMC4EkWQCzrwLR7ut2nzzqGB3gb6g58ET5GqiWWC",
    "Fq24DXqvUC7o7QExCz54bYMkffJuxzCzChPTkJXW36be",
    "Fq5ytASvqWrZ1q6TS4rWHeKLxkBTLuguPZVhyAfoWTi9",
    "FqZUwKe5kBsyMXBvxoFKvwV3g6w9QioP9tzd2taoKsLQ",
    "Fqdmn658Q762xToL4R9R1FEJQcTkKRbP2X5DBUuLkQyz",
    "Fqm6AdrpwGsB2zcu2dTD7YZfW2xEbpV5TUY55jwyHjBr",
    "Fqr4shYNZJWd1j5J5zGweFayyJTXPa19BDBJ9R4Y1rRC",
    "FrWkCLAhcbNL9x2iVb1Ycsmq7gpbaiEXr4sTKqCLAxJn",
    "Fre284rjmg3LKU5UcFntNKwAS3pYSimrYmz1DcpcWGcH",
    "Frmh8G2WavQbXxp41sV4UPWcfYJK4a1MMTt28cG4ma9a",
    "Fs3a6ZJfsbfUHy9fhMy1qpCASw7AyNkvUHfkPa5veDeG",
    "FsnMz42fQqGsVHsYhRw3EY5Ha42b8N5WyWhxdN4f6URv",
    "FsoidkcX9TnffWawka2kXXoYMfi3TRJuHFCwzU5H1ijg",
    "FspjkX9Xop8sBb1oZo5QcH8DdDmNGMe9ZTkELWV8oDT1",
    "Fspk1X56dPYRcYtgFjf16v7ExyVgzp8TVudEtDo8T73z",
    "FtX5ckdqrfWEe1UBypr6P8pvmfwotAjW7CuwcYGMFyFK",
    "FtYJdxihWZUcBK6ejciMQ4awKwBH828c1c2eNK7H5qvq",
    "FtkUxZ2sbBJ4YHumH4G9LBFzuFEH9QYv7DiJwKzqDEDc",
    "Fun1ysmbEaCCgZRKuhqjKqp7EUGwqWKc691QKeFbecxC",
    "Fuvm8ykZyeoCVoJgZHJLeedaDGcybjzCtgFZgKtveoym",
    "FvUgvwgDPYbNrzMensxJ4r7XVHqt4vAovX47tXbjwwcr",
    "FvnEXTvTysoNxkA7ppkb2jjYjZNk5VDcVsmvhqLjsoer",
    "FwbuZyuABygkxzpxMvqwU9i8hnmG6BC6Zpe8wLyERrN2",
    "FxB9uyhxKaa9SYAU7wEgnHoDv9t8ygGDzragaS98KMbj",
    "FxMLbx9v9ux1rmbfjq8HcN9yzPPpdySg681jgLBHcteE",
    "Fxb72GENbSJHKwu6q3ogCvVHLenw1kefebmxQ7Swcgq2",
    "FxrTYqSH23ieyVGtm49NdZGPuQUWnYrC14TPPP692HQi",
    "FyTnsGbQMTYvpnQ9DsaWNyc2VmaeDGxk8UrkMsBkcgYp",
    "FycjCFZ7iYPUJzza25aCdMGwDuSeNqvFQiRZQo6gBKYu",
    "FyhqoWpyZWAW72nYLHsinkjsPXuTPDPjTPkTa8dykWcr",
    "FyzJuY2FizWAR39wimQZAd2ZYKvLgYFaTRnCEL88GrXY",
    "Fz8i6BmJmcvgtsWqn6Nsd7YsZouCSXnqk344dXJGnQHX",
    "FzoSGqBL5TgJAFwTuPNSjeGNawWzubYndATjJfkEYzj4",
    "G1GvEx6QZ7nDKJxZU8sGTSZBeZ97MPerRBTkR5RvFrFC",
    "G1HG9zkaEnUmVgGfcoQNSuEwayqq7sSye5HjzavpEtuw",
    "G1Vp5L3JfqENT1h6SoZfHt3SP8h2xB7WdeMGtqFw9pXx",
    "G1i2tCGhkRCyMH8dzGmTzVmnbqGmGYN7PzWmxs5Q8H8R",
    "G26cGXcbwg6Km9Qij7a9QENwFHVVT6pEqU6o96YLCRKs",
    "G2iFUPVfBHUdEzPhRFivTnMTCfoM4Acrm3oFfQw55RUh",
    "G2rhvdme23jvKKofr9KBJzRvcRfiibgKLaNSH6MyVHHf",
    "G2s1g1cGaKhufyCKaMHGn3D1aBGLebAi1qs96dphqWCx",
    "G2yFDihot4h4tuWpxBSpKe96tbz6Zn915CszuHACPzqa",
    "G2zN1A29SXY4xvbRJ8XSEHZJNyW8Ryjsq3QAkYTAhf29",
    "G3BRLuEWzEqZ5Mtwspxv2BtK24wc2PENK5E4ydCyBZhD",
    "G3CNEqMkMQuLSj4PrpuCxGxA5QG9T4a5TJMw8C77QbFZ",
    "G3TdbY4N3VcfscpSQ1VCkUXnE526weMBbgkCCWpSwjPt",
    "G3XzxYju7qUqodXW3EAXpBXA8LWhAoRuSmpko9CT4EkZ",
    "G3hkzbtmJVbG28yAbzXmfoL4dbuPV3xQ5MQT3FQSv6Fb",
    "G4HDGr9J2nGjsjgV4x82DVQ6fpKCVy5JnUyDcZFDoay3",
    "G4Q9HZSPEdJXjgxrHhntXTbMqW93gu1DQU6iSuGquGA2",
    "G4kB9jB8Eihq1z2TzUB293t6RbfytBmnjcwPPxZaAnwS",
    "G5UY93ygpjU2kkTJZjX94rNXLtVr1KodpHuGWt8Cqa5W",
    "G6GXMMpH27pyJ6Ff1w3r2ELg1MG8PGAaSNApN664YGpx",
    "G6furiPrLiZb98QfCYHyHybshWjVRBFrWe2po7VLM4P6",
    "G6vtahw8j9A7gxYD1MRYz89sbgbP3hoEu7rD4ZWhHhHq",
    "G78mpUyGQEXuUkoV3YL9TbfMjeXp1FCLaWTf1tKofAoG",
    "G7DFuG41cMQBNMjG2Hhk3quzPUUfB6MdDcKuArkeobmM",
    "G7mnuTeYPuhipVFXKbybvfNpcW7dkG1y9TRLo2pYN1hx",
    "G7pNgEsp4C1dcNzKeFz15CqA5EgkD3QLzhzAXyEbdVuT",
    "G7sqwcfQkWKr9MkE2yfRAx7mZJ1HG9hXwYLYheCNF661",
    "G8ErnXS9nABNcyDuLypQxUXC297gB3sG7AUGwhm8HBUD",
    "G8jy7H9YphCeXSM4mgpcFCLKkjcsAuwowcYSNMqvmQGo",
    "G8nsVok55rjGY2Gww1uUn2XmNA2seHfXyHHNcZGEkFx1",
    "G94hk63WDAN9AAxp1UeWKaDtUxUjJRLXrh7gammkWwEs",
    "G9XwAq1zxBAqwii3vPUhwuMSvGs4pBzj81oVewqck2bs",
    "G9d2xk1xiDbxBnNWroEkwvczqnVGR4XVVMJjgnfAArAt",
    "G9dEhbBKWx1LoYdsewbAvmKWXeaK2ycFx6r93xRKM48x",
    "G9mzrnTzJZjVfyWdAJriqhDySdn5seUrEtgVvhiCjFi6",
    "G9ramiocLgoWJs4TxE2vdUAjCjgYgo7ykGxio8KLJSvm",
    "GAZLZS6pD9GidssVGnqXLBG1rFnX4XfFfgrEGS1cJsju",
    "GBDQZHHf2A95d3o5sot9njDka86mPBfj92XqYhTFR16r",
    "GBt1Do13C6GgReTahLBmpu52VCpSabkuLAErydVpMi5Z",
    "GCTJ6eAwuEk4LGgsi6419iDQWGWzUrKpnwCKScqtPALv",
    "GCVp16DXJCuHYyMXKXRqFmFSpKaH7YSo8byytJrqxAtH",
    "GCystmqCpiPd5jmG2ff7BohLd9m8EJmtT8vKFnVTkCtZ",
    "GDTFHqXeMaSqbLa7eyReczsCUFh9QS1UFF8Kv7XsyLqd",
    "GE3ffEuyxe2jaq7ZiH7zh2qRvhN3AzJTyB4CNbQoXggM",
    "GE4KaJ9x7H2mEanjvyvKfm6nZVaJ4TUWYCAoYFJPkdxZ",
    "GEB55evJ4Yfk97Akp4c6rQFZ8zeDyQC1uzDi88ECDy4g",
    "GENGcM7jwraPGkDfWUvrWKgET1Ht3fJXA1cCi2Vm41Qw",
    "GEQMqCVu3xpk6yKc9cypAxcza7CXprunSE7nD7vqaNKc",
    "GEgNczKrSyXjzGit2bbaStM9MuxSecuxVrdw92pekLEV",
    "GEmXxREgSF2cmoDRvNuPKj3V8CRMemCgDkB2BRzSkm4k",
    "GEuNnzAANdv1eAD8hSU2PGFAfYVob3YCcqytcutQ8soC",
    "GFCQcus75TQcEkpnkN1BqmHrVaYpyU3ZDWsMmFBbABf7",
    "GFoswS8NYhQWk8DXSkSYwCsmJWqxQyHTrGWyY6zPhy6q",
    "GGCMuE54YQQQ1uTbmJ8U9mykvgL99dsvtTzxoZVRWb7c",
    "GGQCz7qUGKeSfxgUShBV6btpLq4um3XG9DQAjCjTVa3h",
    "GGsjwu1WFRb1dt5FHe4j4XUHAT1Zgh3CVYNXAxwcixni",
    "GHCfKdkgvDKiTExCDetDzQR8eKpLy9Y112at7fXdYZCR",
    "GHCq726nQFS6iCdK4KQQKRdXA3L36qmC8AFiUJuSXbM2",
    "GHFmLqG5QEbeRPSiiybcmWtdcwBHGJfEgx6xVKW4gdhQ",
    "GHG2gzrBfVeK3KaL6MGLmtHPc5tNjDjPAJzXjqkjXii2",
    "GHfUdFfbFMwMtJy7AnJ4NvBZWeSVck35gWPWdLceqhuu",
    "GHzywjqwuYAreaUwQTNNNcecSXZVstELhbM86rQ3Ew37",
    "GJVChc3NuN1iJ3GE1VRM2Sba6B33eP4rL8AeDamcwqpX",
    "GJonrjkqdE4xzJiHFFhtUMcr4EMg7XKrcYjyq7nvLrhw",
    "GKLNNuwXoKy3cXSSsQPHHeykWyWyEGhLjC7y7fZHNUDm",
    "GKea7a7SMJhkNr5KCUtJmyxMcLQUMrH5L2zZuuMpQ7M8",
    "GL2pnCeeynpQv8LYw3GECmtHERcQ6pD7BdwpuqbfXeim",
    "GLG8FYU89Vd9JPaQCQXJdF9sq9D3jiJbE6qy8JjkkHHD",
    "GLGpgC69wLu6mX19bePf9NxTBVXjaGEqZTtVE8GXHmMq",
    "GLJDGi9oJvxxyb22e8qNhhMUnbPB1Q7yKyTh2uMXkikn",
    "GLUrNfMfy9m3FvFMUJ8Ht2GcUBGKJBCYMyMqgpBYM9ew",
    "GLZUG9WXmJyfVnoXJqLkAHpfDQaE3vFCoHLex4WmAGiN",
    "GLcdCHAfjFuHLb7yhAJP7WkZr6Fy9odfeGUtaQPk9m91",
    "GMcCd1Ew9uv2EfBfC6x2RWnz14p2pWgESwUf4XhVLEcU",
    "GMp5qQR8DJXMipkN1TZ3AixaJ7HFCfJG3obaiAij83vX",
    "GNQZCVNZwUkEYe1DStYhfJYRVt7yTti7fHR8yHF2dgK7",
    "GNYJcgdeK55UZeGoPpvSDHW9LRsh7gPUGfYs7d8CNezL",
    "GP1CQpntSWyUCfUT6hJ9hvjUWtqWDaA56feNXPFNNDWH",
    "GQquxC53FaESK5cmZPyCMxyYU8XQM1wP9ij1miA98rzA",
    "GQtYR3cKA834rf1Md7fEXH2ffm116EfqwKb7Rr2z7z7R",
    "GR74GG4CoEs2mWGn2CVC8c8J5DxRjSLsRBUh4tDyF91A",
    "GRMB4gGvGQXRpZMDefcRhCSCfw3pGXbjLA3Qna4zRo9q",
    "GRWYtsSuLwSBoLfsKA7BFcKDexQfVhnxVeRQU8K6C3aR",
    "GRimmB34EDQZhYLgPjeqFeWzQ9WTN4iwSocJeXrqQb5E",
    "GS7kaXt1FrvLsVcAwP2Yq8tyq7NftxAG7zVjYsnW3Pgf",
    "GTrBwxnfMhecrLbZ1npjVR4LHjq3R1ZFV49zqhVyZKLB",
    "GU4WKNjB2BfBf8i38ittxxkovPKZo9EUWHeezXP9sBwG",
    "GUcesYQjFS5i7xQPBme74sBKqfxbvc7GxRHNsBYkhVVQ",
    "GUcgJsuDWQXKvpYfEhR9FPb8vTCTgVnFcMiVy3d5A3bB",
    "GV4wZe8PTwHbxXjYC9R1ENLj3umScMwEonQerygwdWJ3",
    "GV9a4sqHYLrkSMoNEPUx5DeJSfqUY2ae9qHRYuj29yKA",
    "GVEBLiWXCeQdXf6wNNWPwrwyn7UgSkkmKrTcqQvSb5rN",
    "GVnHmUwcQSaQFXVXqiXbcnThNrYKTXhrQrZu7UCdMmGq",
    "GWxgWPPdNKtrnTBSeAM3cxVg585NNfctdGqHnUWMwn1J",
    "GXHnDzAVV25k3sk45HRF6cjRqnakFKAwirGjtxHbzFVF",
    "GXjyVEKQnd5vN9ccNpLW4MnGHfkabu57BetBKA1TQaDS",
    "GYcZTYnZquP5UVpniRCB24xK5xUNfRaEhUgaNmVYQXsU",
    "GZ81tPrYFh5bvnBgMfda4ysTRapi8f8iDiSUuLr23Cqx",
    "GZA1wa1FmZXDtU8dhaxdaggdUJ1SS5DdMeDHaPz9zGgD",
    "GZZhaY6Zpy6D947ZFryriG76qzGen61LSrwUdkqtwsbf",
    "GZhz9JQgttmkgKg4VRZ5kmo8BQKDMqggtyHvAFFaRA1B",
    "GZswXxvqnM9nmkEeeSDwziMTHnwbNg83FYEh9evEgYew",
    "GaN4F1vCEAJ7dxfStUKctLhTvHoSTQ7C1dB2cG28kwsh",
    "GaftqJznnyRJPeMZD9m2KD1AUn1UdjrSnAQg8uTUJw3n",
    "GatyamBWLF1Ns8tmUhUhYeKnVJyZzi8XLQv6KgXaDaVu",
    "Gb8JhLJXYHxFHPrgaMhFDXBohncvQf5N4MSV1gRaeFRi",
    "GbfwuCPbpoVt4LG3wrHHJoqpKG5kAGaT3Ho9z1LjhPrK",
    "Gbot4zEKNhpiEx1EcfJ2Vyq7sL55fi69XvpepSYaMUrB",
    "GcKALiYuBcAwVjrP1Zz3VRw5Rvk69ocH5bHQniDZDVym",
    "GczqDinFr2ULc67X8exaKXxa9cvaRmdDiHmMHMhb3w99",
    "GeCs4VN5JzrbqbuefVCNWpWYnZTqYzgScGS36VztruoW",
    "GeMqfUFPLkwgdEtxEuHyL6RRuVdcmKbseWidyAUtbkcV",
    "Gfh1gVM1WPa5N9KUavYUCH8jiR32tJebjTzqJwmahFkx",
    "GfntTdUuUF6NmGpNtBKY8KF1jSBh5YuBWA9k2z71XUyJ",
    "Gfo2WJ5AohjAPNfsm6iBqPhac9UnJWFttBgu2SgHBEkE",
    "Gg4yPSvXeyxMo82dfxq3PYjs69JGiZVgreHB2LM9Ki5P",
    "Gg8XEFZHodqt4ZRXLHq9BhNjLWhNFkrTr6oLdrDvPxgf",
    "GgDJsHWVXXcwriZvfKV5DeKLAntdDqpk5KwPHf1ZBKLc",
    "GgHYyLoHydnUXuzGEg4r1GB24rJEAve1tEZ33ZQ4JUUr",
    "GgTzomp62vYfd1atqXK2WRwu4puUjsg3eDAQimgHgTeb",
    "GhPp9y6gWo5wyLbhmaa4apxnJEmWTLqFrcYVPTM8VKip",
    "GhQHHp3txPumaRoFLy56KJ9XMSnWikVxuaESEUF3ieDo",
    "GiAdfH5akCrz2hqmokqN8UqNs7WPf4K9y2rFZfVuW9vc",
    "GiEBfcHvacSRY8xiyzPg4YUoS843doK3pa4Su8fRDd8n",
    "GiMWrLeMvyTVEensXMoeEC3hwj7dprsfTF5JFUbGRYMm",
    "GiQVLkYBEF1kDPi4BQhLhYBX3UQCVHrBYiXLTG5caGGR",
    "GieKVHDvdo4hKQoM7NhgSNAZvyZvKvKSAdu16wmngm11",
    "GjGFwm1HGpaoKm9um7KrWcwBmSTCTWXEe4rANoiXqpCb",
    "GjKBbrXXQYPkN6AvzQcxHU214aQYADcmTMbr9ZYwV5Lk",
    "GjxaS3vK2tyfH78xpd2PfNQ5HyfDN8Re8gNh96GciM29",
    "Gk9B1jMjJHD7e5EgntZ2mY5LvFFtjwNVUaGxE7aDEGaP",
    "GkUEG8WFLimihG4DeTJJfFbykXKG8VT49jTmKMyPdfDn",
    "GkmmtsqhWPgHUQqa4vHB98cSoiuWEnmrr1Jt1nJo7wQ1",
    "GmDW1dJ1RUQumcadiaxMQLnByJZ55eeNYLvY5T5V2xg4",
    "GnEFvTV39PjMC9By6sceRicqhr5W6ET2q82qQcV4FvEq",
    "GoDr9iGYd2vW5D6Pj2MaNEAWD3bK4NK1iYQBMvStg3oc",
    "GoPFJ3JMZC7APvnGC5fcDmBYPG3xeEH4qLNrVigsjBqq",
    "GoRivX5JqwGeS3ocF4FewLk767J4tCmdUwq3kd1ijfNV",
    "GocNQGD2hmNyVuDDjchYAT5eJHs7wJYMjnBSbYAtNkww",
    "Gp7PFoF4hARwi8EwNezJuGmDkrmesx137oDdqW4SVCwx",
    "Gp9x9WZE1pFhBHQWiLPF6mQNSqVuQRyqAFjtQWrzLXsD",
    "GpKcNywh5y6Tycgn52n5cHx4QgBWF1cRtvdPJZg91guW",
    "GpXY2cGbwjCJi25GpE57Q4NA6KvB5hrPW7RcVYBeWR4b",
    "GqSZaMtSw2mSx6zLyaWCwz2y8az1rRH6qtmhcy68p8NS",
    "Gqu1wXmCaETAFuhc1cJpehqBMXc5nJP8uLaGXtAuTzZU",
    "GrGyeDj72uJs3uZS5QXzg5UBv8hSBQpESk68Gvu84ao8",
    "GrMZaQwweCji97y9yjaHok7q6GuamMB8f8XBWAWcTU87",
    "GrcN8RoG8kyGRmDKb6jZ5PcCbHs1NKGT1AtvXCHqF8hd",
    "Grq2yYggfxyiWxjwDc88fQuW8XHH6axAqZqbCWvQTZgE",
    "GryviYAFTwM22KZvNXaUZBkWhF8HD3MyUrWBJSRB9Cx5",
    "GsBZ189dCzpZTvC1LEe8vYPxwLD3mLiymkrtELvt1CS9",
    "GsRBpJUGgZjtfJAoTZEKuDqzPJW3nyMvg5XxWGK2EJhb",
    "GsmyASTMm66pTXhgQxVwoPuK8Jcj7LvNfDDNb3xp5idz",
    "GtEbjAssJM34KMbteXXWKctJeWV2Zx6Y9pmcA6kQedPF",
    "GtRj4oX7jH8ipfV1Mi7M9FBdgN8PqCHKNPiRhYQyYohq",
    "GtVbzCvB3fXQYGTtDzHiwQZBYtBbLVowkhu8cqgntZZ8",
    "GtWY3GZR1tKtEQFg2H33iuCtd1gdMsebjADZEHywL8B6",
    "Gu4ZmPBnutC2misJXSQRXBTHtY2Qn5r31RoTnm617iR8",
    "GuGYYhBa5cMF4Vk7eXv6SWKWquewQXeBdSb1g3mG27UR",
    "GubnUaKz4nQ7QS7eoz5YmKjo6Q8sg7ERGGLiJkdDtdSX",
    "GuggeF1oFJSbxgimBcYf3ZgMCBnc1mb2FpwWto9Uykrn",
    "GusTEQc2p9VBP4tXzDgdo4vwjBXbcTWo8VaVgquMP1Dz",
    "GuyFpizXD5Qk5CcU7zDB1FikXtNSXFSt2FXwAHKUpA8J",
    "GvKs36yDXZaLQEwXiRF8vTpuGSzK9kRnMigfBBz3x3Kd",
    "GvPnj69qo9MRpWH9inAbxj4EDWUuvgS3vzfYi8roRPTL",
    "GvSZQw7zpTwvV6UzSrPbpCW3dJQQDuubhh6swvjcgv5x",
    "GvfAc2Di4YiXkMoQEMwsEmhzqtZzyngLp9ucJHqwej66",
    "Gw94JHMCEtbRh51eDtK61wHkK8yjEAkfVmjuTXo1EeVS",
    "GwPkbApTD8XffZt8FLio6qogy8Bvgr2onXpEq7ntpLeS",
    "GwqNXzcvmTvNuGPsPAGjz4YbfRoTUAoqA6dzbzAen2HX",
    "Gwvoqe9TFMrXZZkGMGqQJ1EQwwEAr1CAvfQ9SzUKm1FR",
    "Gx2TaNW3wh7GULosWxCCDfYDDtguvwVUYvgKzSy7g1bw",
    "GxVX4j1czMav9zGERdtDGnbBNHjG1HBhHuju9Kn5FGzN",
    "GxgHyjgTQnTgaeSnisf9b57CKtM9CK6AEWxfxesD6yV3",
    "GxgVfy6aXQkLFTHaHtSzAdAUfg1MBfgn4amTTRb3ZAzH",
    "Gxvz2d9emPjfs9NbdxSsWdyAu8Rca1THJyLG6F35yM2y",
    "Gy3SF1qLuDkAqZUBGy5LBNnTteVaX19fxtcKQsajzGBN",
    "Gy7arXxJoYXonCn3ALpdmqrMyPNMqT9QZ5QXfWd4ZaFe",
    "GzYVjkSKJ9Vc4F6g2ZQyB799TkhFS2eC7MwBNMxLMQmS",
    "GzszNWRMtTQLYwnp3gLdKxJTCmTfrHadQZQvCSj7NG73",
    "H14BcPcoYaYMEFjBXmXqNGU7xPWzU1YB6d5is47Yau6R",
    "H17fbCC34n5whttvz5FFjascQHAxDnzG1XPLLofyokp3",
    "H1NBspDiuCGKt1Yb6MQV2sdYCQAJw9xaCF1BNHAiK3pW",
    "H2qWUaBS4SFrTLYmQN3W96Ek83GtX1wYvAABahuodwoc",
    "H35kUdcMdSKztmpF2eZDvQae4TEUHhLn5MLUwfZngTyH",
    "H39w9uQQy4f73GzevhCYD1A2dyTnuvNyPtfEew8RD3E1",
    "H3LqGV3q6TqmNLe8yv2B5kNXwbxrvuuBxo2Sm6Pg8mfU",
    "H3Lw3XTh5my7ahhvEkXQ7oHVCQFdPMv4BQfWXoK8gMzr",
    "H3k4imPnvhiKKVcNTCvu9aaTzLN46ZJ1cgd5C3rcCgic",
    "H47ibD4CJLiSn9NbWvnEy3as1UBxQScPro68JTRqD8yc",
    "H4T2Qvgf3HvQdzvaMdFqVRMu14Uarjvmf8pTuG5zG2iV",
    "H4f7njDXuzeeWQ8kRxT3BMPcLcQRDj6VxL6oXm7FbKE",
    "H575FfuXMk6taEcGRR5SSypHxbeFX6Vu14hx8RutJLt8",
    "H5QJjWVsecY9ySVtjAkT4mYaGm655gQiACrjVeQohwo6",
    "H5eKCMSD38isLmRoECfTUwyEYa9TRYgcHw3PEBjzAQDi",
    "H5eo39MRrabGu1o52ovPDTQhGczXfVckoyfWSNttn1hS",
    "H6DXWtz59auv9uZhTcVBy1Sj2wXdNUpiRXAActsX6czG",
    "H6TduzSrkg1TBqLtVTwbL29KAa76oh1X5QmUEDk5js8U",
    "H71r7T186dPzJEGxBakD49vEbSRPvuF7hzY9ZWXW3YQk",
    "H726b66Up7Y1CDWcpkRUGoHqXn7DimWtuHSSFd9XGBwz",
    "H7YcSteLViQQevMey7qB6odAqCzXJRkUhVQQ9gqmxsau",
    "H7vx42ycws7jEAzCmmjKBPavGaLTVBdkDiw1SQAA2yzu",
    "H7wn7wDJGQfNQYNd8jLeM9zSnLknLUHEW1nkV3SLmfrY",
    "H88LG4Gn4xVKHJ1UY6XNMaS43vPrbusV8o6U1L48vZFz",
    "H89PnCRD6tcyqxzKNdtyTAAtQhs7utGNKFFR6zTwyTAq",
    "H8AYyagvtLajgLwhU64rWuN8MhkzZ1APXLdDUiQz6LdH",
    "H8Q6P5GmjikM2zHG4fHjo494BoYdKhyExBXMFQyEomBj",
    "H8RC6e8iD7HrHh2iiPRajemudCGTDScbMm3xyryf7Fti",
    "H8TC4a3GtR5F5poGL8nKCnykMkJmW8TXSfiozsg33xGS",
    "H8idHiXSPk19fUd9BDWGcMDaSv6igKybcgxuvS8GNTeA",
    "H8ud4RsNJURxtCa8xSsejNNMKQY2LWo55dx5a6HPe9xk",
    "H993SSx4gW5jMVF5cdTcTFZhj2VfAVHEUmCNF2d1i26u",
    "H9VVgASkFYdQ4xKSoCCzUr5dRqTfqtJjwGHrUtjj2oT9",
    "H9uYddn7BmujDmguLXyf4qgVEWwmPJAumP7kHXorEbVW",
    "HAvC4mynE8VBvZu6G4ZJwnCPG5Wzdrf76qcx7wiRzRZW",
    "HBGALFxESqspghvYGjyoVFw2QrDaP6DCYL2hstv2qr2G",
    "HBM87EYhDexNFFdi355RPGmXUxozbu9isbkpwJkVmGKk",
    "HBd3178MS8twYTosGdxP1wfaQePEE8jyQNS3bSvnqPwo",
    "HByswVUxDyTuLiTrG5o1zum9W9CvGjW5zAECtY9ccAVz",
    "HCP6HTLbBzNSNYBzwYk8Vx8eZ1PxDxeSUAtBeJNZWZ6Y",
    "HCnZ648ktLjuhCk1qSBzcZYFVBsYJrQWcRFV4nsf6gYT",
    "HCvZAYmXpS815n8fysDhS2YWaJJ3jvFBQ7jXXqwWx13Y",
    "HD8TS1jFM6EqxhSEcqVKaJzhnATMJVrQDPoBNgd9xTLt",
    "HESVyXoFGWWtQ9X6KMHWAzTNVTPfd2zQiR5bGY6AN6u7",
    "HEZNpf3YBm3sWoqRZV4ChB4nBjFjt4xnLfwEctGJ119e",
    "HF4uxB3854AZxXHK4ShAMU6qqKPnRFsADadFVqiMp2Lb",
    "HFNUxWRcBDpgE3uPbZFPLJHFBiYhF6Ps8gv6x7W3nwgB",
    "HFpbPXFb49sStWM7bd85e8iTcjzSE7qpxp1QvDq1ybP",
    "HGMkZmWRPmM14L3Fj7ANeGPvDvRnMbPPPhUSERdvPmHw",
    "HGNBgs6BGRL7nCGXn4zgspjNoeobuB4bEWPTf9DgTKZe",
    "HGQwmn2s3JueKuxcHgxZf6zE589SJzBSyQu6grxuvYty",
    "HGYmKpDRjjBxQw9UprfFTDBRt7cU6g4Qk3yYfXjXNrwu",
    "HGjWrERrAysJpzRLkKep4Hhuny3uSKcVKQZqD7txRYfv",
    "HHEb8riV7uwAuTR8KbpfXoDGeQeyWiRPhHUqPRtrdJ8X",
    "HJ9D4mcwJBvrXdBj7gcYgjtRTiuUShDF8deHGoMrEP6o",
    "HJZ3xn5NXN3uk634u245NJyw8pjZMncrsGctoxCDck5n",
    "HJzhfPdNgAcbRpMbynxwUrVPNJ99emLC9RL2pzoyfQEX",
    "HKDo638ndEizJmM5zYaWTXFb7jpuY1b7dT5KqETtGMm3",
    "HKRcUY7ZUxLzJbtM5wdQuH2c8ouW61uNtSHCxWnoHhvd",
    "HKnPyQma6ByoFYst4bArUJQfLMpPSuuoBqTRrTpHegBq",
    "HL1me9c17bNqPPVrVQCKsv8YLZjGUyGfRTM4sKPVNd5m",
    "HLGhHgZcNsA3cWH5SXsYGWj2Q788Ud6mLgbHKadW5Hws",
    "HLT7katmKruuXGLtJwPTL4dHAfHV4DpCj9iirXJ9rEBv",
    "HLZVRDjWGt1q7oVdZv6MFeCeFuFXYcu3ed5WpbENndcv",
    "HLzpLAq1UdqZ9bd88bxAc58q5BkDUSF27MhPLqN6cYMt",
    "HMJ9BZf7GynU5p1GdPSuKBrSkyEnJEtUbLCyztTbjv3B",
    "HMQfSYMcCAFL4q9huew7rp4e6vVT4cb9HaQQ3gMCwCXb",
    "HMXWEe2d9Y3wPfMvg1bgPpxehKz9bKaoL7UfU5y2ZSJM",
    "HNFcWjbvsDJ5FRvqxNasi2KuUS3NUV4s6sh9se4idHtT",
    "HNR2nKccASuAY9fzmSbdWZrCtdrBDCtdYBJ4wL12Ui4k",
    "HNccZP2NA8pWJdGiQCYF6PeB5W1rnorChyUTyokvTttt",
    "HNqpssBZLeBTpb2odsSZqArsmCC3Tffmb2Joe6dwcvP9",
    "HPCVpy94DRUCjjqruqp4oPRjaKAATkRHt6w7nzJfJBuo",
    "HPc75oF2g1Zw7kC3BfH9GX6hFcfP2MqN4yxarmMX8of1",
    "HQ5wc42b8ynKYHKqyF92P88L7s6hBH2ovtTYKyQLBSDu",
    "HQDTz9bE4RmNf2zUYpmzRkDBqmurURWmKP3dANBUyTX5",
    "HQXDdG65Hww74fzRDcMTMqePDu2a8Rh8gvmmne2svqAN",
    "HQutPu17jvmEaaUpGiBL6EvxNGgjeGyfHnK8EcqW1cK9",
    "HRZucVTSqozWFnLe68oYoLM352VR3DizV1JDwSktW1rM",
    "HRgqCZnrpHRuc3b2uEH9vsrA9KwBU1cZyeJtDQ824qfG",
    "HRh2m1epYHAkoVoJfcwey3oiCg3FdEReSdzoHHusS1Lr",
    "HRmBcSoVYfS1sqMgJCt6qVJ9yBNL3bQcVC58qekCdirn",
    "HRofKdLCg9YDjh7hn9iLiQVHYnvjx3G7LS9bvkiz7UYL",
    "HSivMscj7veE3Cs5eXyyoaTxXf1WBDQPSd3Rgoo3WfzP",
    "HT8yUJi25RoamXjpx41UwiiVxFEgMeKCMocd1mFWbyma",
    "HTAkyqU6ETQ5EQR5YvwaRqCivckmepksd2vfbz5CsaBU",
    "HThvWb3qwQMXGoRoxNaoAgFBXQZCcr5uaX17vr3okLyT",
    "HTxCPGNBU7eym4QxMryrytQimZnJ34XPKAuGu5gHhifs",
    "HUQYT9nB91yp4ZPmoWZgXL8CSbNvw53HjrEiFAEEYg9Z",
    "HUr2H4zfPwkbPQaaSpxJxE9WyjBM7mih18AcBK5KFGHw",
    "HVMXP66BTrLKSXFriB7zSXFMpxZawHX5KdJc4B8yzzVa",
    "HVSmVkoC3Svo7ztuUw2xVGNpkgx9vUPXQ9w7ZR1ZJZTV",
    "HVYGMaVUaraLBXdxQDUMcukzxA8uP4VtLExb2jszJviK",
    "HVc4r6xRVpAfME2zcpmJLnMFweeBwB4Z9iNfm4KM1qS4",
    "HVgeoXbtpENdE4VzHz1gbR19Z9xsS718AK3x7vxBNGHV",
    "HWDDZ8voZcRtwKZvoKHWHNPCrs4kcgyqix53CLaar1St",
    "HWFn5cpTCi18zcmMfQXyoCLmXWSAaQHfVvBwKf26X1nC",
    "HWV19KfqQZsdr522gwxeC2MmYgQh9RvzeiTKtESLU6BT",
    "HWY2PQJmMQe9BvwmgP57rJR3Xx57WtH5nLXwFU3hhDra",
    "HWYFDYYSfmc9Jf2ieeaZumzSXGzpNKhrAM7ci9itKj7D",
    "HWnJrvfc7NNVT9kkrGrBqUQdjWyqkS41Q8g9HXac6nWa",
    "HXEB6EDDMwZdXubaCex4NGmYZmekDM6fc49yfhfyr9aU",
    "HXk7FMfxQUdcKvnLNi4xaSoHeq86RVGeM8ic2hL4NSy8",
    "HXpAUe3i9nceB15QyV9vZmQdfXNe5gu2NnMrojP24wHC",
    "HYWQUN6epVW4aLQc3ysQeNe2k1A5A8Q3hPuTwrDL2tgJ",
    "HYrCs9PiZYoEQoFdThFPKGhw6X5vatjtRAC1grnwx6s8",
    "HYup81HVkUMLryYnAe9BWjb4RAcwrwaiSWhqE1ARVBDZ",
    "HZCx5v4RGRB5fcuTjUsoamhqQXcDHuXNVdakuvK9weWD",
    "HZPLmbKYuHKJsSPAWE7Y4uwei6jNKUZymC4CCMGkUtEB",
    "HZbtuckqgiD5sC4rMSuJzYmK34CCtKHAEKT4pJFZJNmG",
    "Ha1cLV2hgJT3a89Z9pr42PwZ2Cxri9P9JHsKmKmYbgE4",
    "Ha8gtZpqWaFNrvmzhkFhRGVhBbNYkvBMeHsoputZgbE1",
    "HaXacVjxjn9Ad5AiXj1SzD18korBZ4UUdD9ECmA9hWcS",
    "HausDJ2GNs8Fz4xybwGft6ABjtDKzyoY3fVFKT3XJPrC",
    "HaxwQJEJYEvmpitoE233uU9HGgCZaBRFYoKycmEBJ3JZ",
    "HbAgZg4EszbcgGoRHEd3QmdPtof37EMbz2cMMxtGWS2L",
    "HbKhxE3P7zDet5zXhud1rwpthrUzZKX1dFwgChTWVGxM",
    "HbcwNhj8jMvtSo6QcZj8Gcn9KLW9vg34UVrdaDEjBRoM",
    "Hc4DokwYpcGeW1eYPo11pCpQJAnsanF4sGtjfwZC96QN",
    "HcFUNPsppC1QxgFxnaJPMQN8zpzsuVy7B129Xq4XppG5",
    "HckH57mPVP9kxe75bmEM1LndYB9CQzdveeDCpYFN4H6q",
    "Hdn8GXEfPkDdn9NRfW5cRZ1XyrvXBDh1eXicyz92a1U9",
    "He7Tc9LKRqW7dgWkXsiyCBbYpbtfkaH8jTc2m24pzhkv",
    "HfayKvqLGxYiiekNg1cEK3oSEW3axudi1GaqmoSxEhYR",
    "HgTjuucJiAn19Qqjqtdfah1Bv5qeBzSDGJ9BRrzD6uPH",
    "HgnaBhaJbmvchnjmCyoqRi78bKJ6W914GbA2pCk2FU6o",
    "Hgzyk3SXxjiGxkaBjXQLfRfBbJaiyTE1fhGiwitmgFju",
    "Hh1FxgNDwj2v1CWC7YHgDVohdYijWVFoAXgC6y4L3ft8",
    "HhKTyv2SW7y634v8jkLAZxENcYPKRr9sK5rQRqmwPB6d",
    "HhPzPB27KRhuDAQ1b3zGoPTRTJv7yDX73Qei1Wh3mSok",
    "HhUct7we2rdxjZ6rj1v8WS9wXnC6LqBQ7Kkwvs6Uu99V",
    "HhWKNbroNWMbhsNvDbKknWac8Uwm9BXqTMKhropHs7xU",
    "HhmFnx45iqCnhYQLEeYfYguMoPu4Zqx7kgRFYzhhAQpP",
    "Hi3ynMMYkaM6KEwUJt5fW8TdTM8TkiAL5b1o4KXCtCL7",
    "HixjfX9VW7mKfJTE8dSxn7jWb1vSZcDfMXMxaHvRD1j2",
    "HjTQyxfrP6wqWV565aCG1JAz6qrqWyzsrRBTon1xVRXe",
    "Hjo5ztaXECTwbCC4wFw19NqF8LcDdoNfTgJHJgYVfgXb",
    "Hjo7kPDBFZDgkjjFNr3h2VFT2vyDRf7HvopG3qukHFAP",
    "HjtCduccZzk5MeUZEhyg4u5uewkNDk3WrN8KfU3DRCjt",
    "HkP8Yv5wK8zJQ9c3jBgJ5veAScFm1XXGQhXxtn5MoHmD",
    "HkRjRB8BYZdAQKVMq6BwMB8mZ8KEECY5bsxfz7NXAx96",
    "Ho5ymnxBc4vNSfrchtYLch1A5VQDRfK3cX1r18BwCvq6",
    "HoWezbT9nopSjWnr9JaJWwwiejR2HMwK2ae9kCvxscSi",
    "HokGkZrEzkmTzeGyG9hf8prBv9hcr1B38gBq5pgLbvpz",
    "Hp2hVWELZ4Jw57Xh2XSkkgfCPG1e7QrDpUs1wd7Zceq4",
    "HpBLL7wveJ4dZYrqqJbv7F3Y89C8itJTC6tx8i1gvMdp",
    "Hpg6Hrs2CVgoe2WmjL79huuqZ4zuPBocTEYmkHxMoV9k",
    "HprfBST2r2DdfbCBkudRkx5aJuFrhqFLFKzisVK2GDQi",
    "HpwQWqeDr4v3qWBMbiMogTGZaRQn8W64eTM8xfXCQcCv",
    "Hq3cndZhHB5a1ropPEDAZEY85anLSD7TNdYZut98J2s8",
    "HqCqYdpkq3aajavGDuPLhXWmoSNZmQ1rxKxHpQCQcoac",
    "HqQgPYGBWEhgJ81davZ5perPSPFuLZ2C5drnn8MjbNc6",
    "Hr716FgfgVTmogC4yHdPhGGLngPLfLrpL69P72xPhrX7",
    "HrA5Jxx4huYUg1p2izxQThtXmFksqnLjh2Go3Mdq8Ln2",
    "HrFzJaXj3D1fF6T8EmMGFTVCRSPE3bs54T3XTG3LA2ow",
    "HrQ52e1QoQGwNsi3gsEAkBMacWAGKeUvfiAEHLyco5vf",
    "HrjfqtxaXRrs41jS4iEvGBXQkkRn7ekaEKPgkW7pRf8u",
    "HrvYLmafpfGgATxbYRdV7cwiDVjqC9mRQVLX1QRu1uj2",
    "HsJ2ynGRSYC1vBgRc14A91JY2UC8esrVvbcmSTgq8Sah",
    "HsMjTUoiUytpL9g4QLmyr9Xxc1nV9wAvzDrkigjof5TC",
    "HstJj9AUAXutkGHQ7XvzMm4Kv9CeTrE8oH7E9gMuVhq4",
    "HtUquWLfBEvWMdxYJYq6SVyEyLYFaP2uyLxKSHb6irGS",
    "HuELUyeEqANbiahvJTiSFV5xQb2Nw7b9GFZSJe4GggNw",
    "HuQGDcKij86Cn4bPVCkgJDdRpRvZyb6CFLUbuRH2Ltqn",
    "HuSutUMpN6LwE3PD9vCxf8Xn87VMddury6bqNYqFZV2v",
    "Huet8N9XQjMaZVfFJVNhBcVVaTFtqgsCaqvRe9q4XnBE",
    "Hvf4ULjMSeN3mFDfyCSbA9wmyGQto7mKyEZLP2uPuw4U",
    "HwUUWWVPXhTuRCgGUrFkKAfbsdF9A4LZeqVv671oCNvL",
    "HwsxmTq9amrkffyVtXCoWbTS9p97Sm833wAbBy1fymSG",
    "Hwy6uUqRNCbKEPiyBi4KdzvcMNHYQxv9iykaSyojqtCp",
    "Hx5LvBzWmat1Newzi82hs9qFi5Qp9WzWee8P9xmot7B",
    "HyJBoAxByav5bVbjapK5P5UWySRyVwmfbFmCTtaMMRif",
    "HywSQsLftrwWPhyPanE7DNJyn4vyUbrteSFZs86xcjut",
    "Hyy4iBhf5iRvba7JyNuiUFesmAwc1986NA9Q5LUgm6dE",
    "Hz23odzgkMBfgdGwSHe8iaxnj4TDDPHUk6DNystGi7Ti",
    "HzBodpHjaM8Eqi8YQLcdnFBPsuZGxgHoFqVrNNFmsTnD",
    "HzUPeWPEtVMUDpwWCF6oD9TRScXRRQ9yB3RU2HYdbSQW",
    "HzYg572gJnKm9zVQQW29JTbm657ek3wua8PbnqiDDD82",
    "HzjS5bfXiJEjS6Jm7eyH3BLmS26hwHDSBYUKSCpggHdM",
    "J1bJhEqYNDJEvauYfLJfPnmfkjoz2rSLKng9mviAF5vm",
    "J1fLardVyaXfysozbn2cJtxp4mNGEfDjcGbvueTzZ5wk",
    "J1y2HLgHh5SFjLDSnRNq4TdJ8NeoTPPzCC4uXgzcSbSj",
    "J2FY2pBaySvtJsy8NTDQ2gjEWnNDuhGSqEQGsxqPvDrV",
    "J2LEC4iJqcrQCn9MAg9pboRwqZRbmaw92VYZzqTuZCFK",
    "J2wbqWiWvnGniujkLUyU6jUEE99Wtuow6P1FBokfVH9u",
    "J3Jk2DmfwGRPmfqykJXeFxqczuDHpWmAFsYtDJXY8kCT",
    "J3PGsj2q99s9upDgLKL8YuJaH2ZMMZVrrNjbxXbfYx4H",
    "J3zY1QFoRH28H6hhY4QvbVqS477n5bRceCGqmXhyMBtK",
    "J4B1QZ1i1GiiJ7bXmdPC4YhSFnRendekvNA7ArX4grbs",
    "J4WJ5VhY5AWxh8TqnTvyEjTb5Qku5jWSRutNYY2Mtej8",
    "J62hhmoQP6BuhpaH5nDPve1yRAug87AW3UrRn1ftXTGF",
    "J71XRKDPu2PSGjNNWsttve6eTqHjd4nPLMZeYXdZ1e4F",
    "J72r9ZLK7537Jg1qUNo157qCPqMR46RTrxBgWW2T7mC7",
    "J7CNEztueGfB68xCnANoup2hRYWEAGZZ2MX8evWJ8Mpb",
    "J7Dm8ukKLu5qR8ppxwcnCLT8Htqrq9R6QLw8c4sYwE7a",
    "J7u13F94jDJTgvsvQ6rjkyunNk1YJTdNMXPpnu3H52MC",
    "J7umxHD8gftiGjcwDUwwKL2fwptkcCj5c9zWthcoXy9C",
    "J7z8VS9MohLdFUWQoksBxNW3BghE1j6HMTcbyJEjS6Q6",
    "J8DGemiMvcDyqR7uqQUhMqKpmZZw2cwGnWMpUQ28dhSN",
    "J8N3NkDnNaf6tfKNtmTSR9rnkTep7i9MjttWjEtS1XAJ",
    "J9hoUZTg1JjHmTgTchUm9Dt5qdmS9QWoBaWDM3RERzLQ",
    "JA6szXyXULqQ3FV5NAgArNrbkm8Lti3y1YH2Lp4xFzrY",
    "JA9iCUaE6xuej8pFwZHbNcV4TuyjY5a1SNkXYLLCDRDZ",
    "JAmHbsGD5UvUkJrnjL8rDE4XcNcU4YGmj2afmubmADLf",
    "JAsVCPC5j1XHovVwc6BC1M4usCYf3fJBPUcpxRixTHcJ",
    "JAxgikrXNzdHeNwhLU8XwEbtCTTvANw2tFqjKgCeTjaA",
    "JB7AYroHEvh7UgiXPtNYAgBHsqN8wm995neYqnF46BS2",
    "JBSjYjjDYTz1AaYenochDuR43YiMyiE7LWhLQ8FrMxZH",
    "JBUosUUhr1AHP9fKYNB27XASxu9fnv24e7FyH8VLvB3U",
    "JBWeVY692SKax6ff9STBJpfUjf2gxtqD6YZMmgUkBWFq",
    "JBaMwEUhWew2czsu45ixiSqVHmVdxxwx8obdMjoLN8HV",
    "JByfwEpJMnnwP12894q7g8BZyi6h7r3x9Rzc97AcJiHe",
    "JC7fomsqutgmoFjLsrTjVNcUMySkxXajf5jUirp9DPR9",
    "JC9HaTbQqPCzLYqyh4bpSWky88LewNBAW5YBaVnLDxWg",
    "JCRCAj9kzWy6BfzXUeDnjGA2o6zP3kjffxg7dA1WpvEm",
    "JCSk6x9LsjgnP7hseHxunbAzUEk4tXtV1DyBeqAEHR3B",
    "JCWhcTJiTDHCk7pHU935YygWSYXPqUgfpLASEgfuM7Aa",
    "JCcTYdQKrZaoJDyUoEp1RY4ASVCPu2tHcq7pYeASmcht",
    "JCkivZnBkpcnt4mtTpnKGwFXKS4YsRmxbQszSQNbvcnS",
    "JCubnDbDaa7FCQjpWXpgQKaMuUam4YyLa5hNrU8fXRwM",
    "JD1tqsstEXcRGtjTv1TLzrAM2zLw7N9S7KFtGbfDD2VX",
    "JEGWnTbTWhyc5znwCyWibaTLQrebyMTZrBXjTzGYrmkK",
    "JJMb7bwdPbUm6YjdSHGdfQTBiSqkWbhcpppsonzELfF",
    "JM8fA5jmAsdziL59Jc5HSqQDPRcE2JHeYW14gU887fK",
    "KJgp3fdRc6k4aNfq9RewhhfWUjgYHFwL5SQzjWWQm9L",
    "KTA8J8hpRzJpXKn8ejWD4A5YoYRguUbkAXcdgfoEAkT",
    "KurPzV4Adqt9qsWiuQ8F2drMiLTc7Yqe9knNtZ2viq8",
    "L9TnQtWFH42rv1X9dXGBb8MoxVa4SH3NpJ2hBwgq2vG",
    "MkMSdfcqdR7qceh9KsD1kDnL2DrBWGzinsBz3cHBfYW",
    "NUDSGJe2sRD1HfgyJ17NqeaKsodNqZv3jaEj3Dawvxv",
    "PAdib4AZr9yfVNT6jQHy1Ygy73niz1LGFVGEBCHNVw2",
    "PKsXaAV3ZJ9H9EGUEmtoCVGW3KVBiBfBg5w1epMVTcT",
    "PRFyTmXUzC2wiMLrzLBfUysKE6bidjBYUUkrfktC8hi",
    "Pqvm4xtDMVbiZbVjxhtq8qAmtxryTMywVUuJgvQqmee",
    "SBzWt9SjSeeGtgVGMRhJLGBTXSo5PhJokB6zD1aZhFH",
    "SDePYZExoBqBmB3un2rXPYnkrcQc83VLUpx5NDdCDTt",
    "SbBs9T5gz1pvGdz3E8CJKB5zB99gDPXAJS9XX2RNQfJ",
    "THWkR1euG4M2anm6vqNgDsmEkAeRzS8FuCLf3Yjskxq",
    "ULSmYyAqiHRWGW7sA8G9uU1a2bszZpaoukV9g9wr5Yj",
    "UN8s8fp2Z2kFXP7YNmVXXBAy3zdhsSAvTsNvPz5tmTV",
    "UVez8YMtBwe6ddABvvQve6sFEt8DFQtsWvHQjeDVWVT",
    "Ui46DVmAgBQu3GLBrzWXFTphBKt2eKMTro4ChJciqZQ",
    "Vniuq4cyUBvUkH6ZgEG7AdBioTvhoRsG3gmDtAWyfSc",
    "W1DW3V4ju2cG7NgugKKvR4kRYtzE4ioBd8wehuiz9ch",
    "Wo2VS9AJ4YFBo9EDwtSkBAJ1MPhZd6knD3FszkFwgvY",
    "Wpea6AtfbsngthdfKPpNWUJa1eaWAzuKheJjXXa3eEi",
    "WsCNV6rQsJ3egW6MtLxMmQq3zZ44EVsCfmc4SCHhJBK",
    "X9raqwe6txKmN5ctymdBGtTa9oGMUhbbLxftJz47tft",
    "XPeNQ3H8ctovQDnyaHPHcqcCFz31fjqkAmWdP6cd7E4",
    "XVqWHU6E3rEQaupMgHk8HcVUt2wNdsT2HRxJGRySWwM",
    "XfX7HqnKEBNbCDo3JraagPvbnuXuTNzYZptx1ZKb1eu",
    "Y3QmmzkEpye7ihZAbmdGzx74M6E2zvRXDSjhBjrc4vz",
    "YYG6AMBj3KnPRi1iYVMTR1bpHwYWe5qARnUHvThzzHe",
    "YaqPfXAEmp3DPfxsuvrrNEbxZdjZfnthpyRZjPFFmEj",
    "Ydsg6y3YXL5uLorak4i2CiMWAb1hp9Lotku9oCVgxcy",
    "ZbHhM2WABTJt9mSZ4q57XyQqgU772LKiQoEuR6s5Ru9",
    "ZbZZ4xKyKZLsoMUppp8BTdRC7Qo4vTCY8CtTdsipa3J",
    "a5sCRGKXgzozSbnYeahr2yxhKF6bq56FZvuHqwugqfL",
    "a7rf98ACMGhUC8NhVYFXzSP55VfqpA9ypJYHDL9xhJU",
    "aUtUD2siAKVFfCwBk9jSnkiNR6Vpn1oTnLZZhNDoWAV",
    "aXme5shwSaqPt6F4j5YjW6XtmLv149q1uCsLQoNynLu",
    "aYLZbtvEhLdnb2exSsqKEFsj4mBQhj2xniVYMHhNnPT",
    "baa2NdW4nmFf4Dq6kTkgCqT2rYpPZotnUUYwjLY5RtJ",
    "bkGQe42MX3iGeCQz2h2SQzZLvP2DS5yZwSiQHQPchBR",
    "byoCpQ5Yej8GMRygLvsJ3AzB7m5yz8Rv9uVMQWnALQY",
    "cQ8Uj6ja3bwXjfs8pbiQK3hPJWSornamEzCMa6r74B3",
    "dAMCDNKPVDVFDc1rcCFyL5vY8rbD7ewfJcgB8aRRm1f",
    "dGGVdaARqpzWE6kiKEDkoNBaNEKNFYUqgDeMqRU4TPb",
    "eLk6rtnMHFypRiPG7pFrjpFrbah5Wsa6bpeESr7WpZZ",
    "ePZ1kRFRT9N4AoJX9NkcptadNgqu7Ffh5LQzhEdQka7",
    "eSztb3VYgUMdhJnhT3eyU336ZSEjmG2tw1cs5xsa7Nj",
    "eVQjUAbUFBRSoE5ggGmTKFZATKQCVHTSWxbMxjWUeCj",
    "ebey28QtxJo2Lwg7mGXQGpWWeppgBynJyPGgG9vbxxi",
    "edtFk8sAyHuYhtJUnSGeUQfY8CrYaYCsV2vvg4qdg9m",
    "fyJhPVn7GFmxcjWCVBtv1397VYG3e2MfLrJegJruLmG",
    "fzxNNevqzrpib6FvKfN6Ht5At1XZgzxbzL9H2RjaJRf",
    "gCG37WcxJfasesT59ahzZ8xNQymiLzDLhp7zy8QbRx2",
    "gpizbfK5rSbNeSh4f7CHQNQLNqqYHbKycakHFXRAh24",
    "gsdnVBo3n5rpnBBbFDKS4AGR7h7EPCti6TjaSuniACt",
    "gu9FfygARVUAqwuQ5pM8wroa7LfLT3FferSAz3Esxod",
    "gwfFCXXYfBgqbxMMppYEu6758ikUYKEGPd8EUweiNzu",
    "hduSMk2PbHsFzqs5o6VBwABgCUBb7XqieMq5PX7EM6H",
    "i1NyxAmBiHQXvuTwWDHr4ffJU22qNTo5Ti3GZLqMAeZ",
    "i3bob9CJdDLQJF3QL9A9U24S2sLRRfcRSecgMQPzdbp",
    "iG6pQfuznANnEpF5ZXd8QHMh5x7VWhXfyYf4NtQCHQA",
    "iMKRC8GjUYbCgTs49NS8WeXjHaZm61F2zm7XRifBnK3",
    "iPobXKgNW13AGFKTg9g8Ssiuc7HpLbEpoXfWYA3dguy",
    "igR673fCpqh8mWSjhMvCv4d2HsFmVBK3iVuDMM4NQwG",
    "jeNGKr6uc1aaU9Yote3uam5F7rHHktm6A69mk3iLhkc",
    "kHSkXcAZ2mRfMm1oez7Xvki3DVwxju7Kzeb4GhmUBp3",
    "kZgHDsjBN8MK8LP8x5w7436W66m5mLJPynfg4ZRLJ9M",
    "km5RuiP3BQ5Wa1H4j4HVbUx7JnvP6uyChJf6UMjxmCY",
    "mRn9Yvy2N4eFHjipgEiJZrWaxTcw9BzQcHxmripgR5T",
    "n9APkozkkvu5XJVUXjtnwU7g5YRnhf5pkfbKQrrtjYZ",
    "nBCB8GskobBuTtJwu9MMPVj5J3XJWtDkuaNgFRASi8T",
    "nGHQa4qY3z99QJsWP2H8w7P73Wi8HvWSqhh5G3nGvWG",
    "nr1jtzWPRCv1dg7wSerUvRKWRvMepQj2kKhJMRFF1Vf",
    "oAHkckiHr2DEHmKft6MLsrrkgC8Ug49re46ioop4wvC",
    "oq3tTT8CfTrhLMdrSU19SDwGHw3tGzty5vesTyMJkWz",
    "oy7x66qMqohLGsQwrsc61ZwZyVTUFkbyfkR28tQrjeP",
    "p1KJU2MmRim4x8Ee6x9DHDDu6Du5JzmiD8h3Uv5YYmf",
    "p7hh4KQhjUrautH14BPMY3NcVacFf33rw1eX5FxM64K",
    "pPZrBM2b9DHNdu88t3m2x9qea5ax73d1CGxCRyg7P9b",
    "pZ92WhnFxfRu1m3djvMZqbvnaHeqXufcimgTkVZraxv",
    "pbSZoe9u1zxhzqwACDBxXaNtg7Mm8otSs4SJN7PB9tu",
    "pmRMsz5omx2ARctDa9c7g4RxQrAvDeNr5xYrpKxgejQ",
    "pxbQTksVmoJhLLvt97R8csGabvx2NDRWeKEmmzfPxno",
    "qAdiDmBg2KVNJAzV11p1jjQxY5wbwM6AbjNUQUAeMRZ",
    "qGBQ28TepLjefVVH6LsSvQDuN2LUYTfGdhbyeJzKGds",
    "qq1d1shB8fXqPPF4gywWniu87TFBFZ6PBahj96qRgF5",
    "r19QEFt14a6aSmXbv6us62nK7KVxRj6nWDqbrXHcVBc",
    "r9pUWjYyR2HM8rRzkLu8R4HbbtvgscoSvBBqKoBcZxR",
    "rMMyEYmJ7zajdr3u2iVBQCRkbPP5TJeWjXvtAHarkcP",
    "rSvKDn1FaUcE4pquZxrtMSUGFCXhKGxbKdeTaUZarQi",
    "rVPa71ZJS9DSPLdehwzoT92655g96GaQ1FKzQL6YNez",
    "s5w31AJ5nCAkdjBPbCpbeqMyAcbMf9sSM2M6sDPsh5f",
    "sa2pqZsvF9f1EsUKHUxZE7TbJHuF3Z98njuSCkWYtVw",
    "syFgbA6WcTTAjSZyybWhsSkKNCkoUm8DZ4wqYqbDvQk",
    "ticbiKKaPX1Mn6pkfCjnvC7tQiY44kGKfTP1B8mPhQV",
    "tqGMfejfL95P2P6UyBr8HxSXz7kNz8dERoTBcfzD3M6",
    "vTEBrst9CUfFazn23MEDisE9Wb97yFx8tmuCkg1Me8G",
    "vqdkUSbxXYvbA3PpKYaRkWi3Pvj1qZ3qY77EaHoXUAt",
    "wGFAKYhdz363U5NBLKVth5MePQAAztoWt1E8XkNQaVa",
    "wPVVt4Q3Mg7N9zuF8WPC4i5CpwTTfuESLeBVcKjkGTU",
    "wW5fNjGQSfMrDdX4ug8kLwFsucuLB9k2j7iskfm1G4L",
    "wyvpA2Z5pbt1W6SkEZz44cXRdVmFmmqR7RF1CNH6yK1",
    "xUDzoY5TKpH55PCrzKLCMHMZy8T3LqrPAyEQufVJWVE",
    "xYfeXKFCHF788eg9xFCsgRjqyBh9ijzxXkjeMsuopVP",
    "xkzs8yzQRmiNYqf5zKZvbL1cUGoDdU48WBukphbrVzf",
    "y3EUhF41tuifwZHkRnPBA5AFQwE1MGaEdsAveTVUED8",
    "y7TGER6noDLjdnaDqcvDzpa5e8WAcwyHBYUR8jTm3tX",
    "yVaxDn54Se1kGLuJq8g2ZkbLey6Li6cT4FVRWZbrzVf",
    "zXwvwDvjZ2vT75vxoRYsMcaMTZWaL4tHc2i2pNUzHKs",
    "zuFTGniuw7UrezCfampcDabpnt2XuxEgLtPsbaNAnEz"
]

},{}],2:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = require("bn.js");
const suteki_mints_json_1 = __importDefault(require("./suteki-mints.json"));
const _544ZHb9RNiZbBdfW8TdYMp7tUAbHESs8LtDNR2SVqrC8_mint_accounts_json_1 = __importDefault(require("./544ZHb9RNiZbBdfW8TdYMp7tUAbHESs8LtDNR2SVqrC8_mint_accounts.json"));
const button = document.getElementById('button');
const modal = document.querySelector('.modal1');
const choice_modal = document.querySelector('.modal2');
const phantom = document.getElementById('Phantom');
const Solflare = document.getElementById('Solflare');
const wallet_box = document.querySelector('.public-key-box');
const wallet_text = document.querySelector('.public-key-value');
const wallet_disconnect = document.querySelector('#disconnect-button');
const main_box = document.querySelector('.image-box');
const return_button = document.querySelector('#quit');
const body = document.querySelector('body');
const info_bar = document.querySelector('.info-bar');
const sol_choice = document.querySelector('#pay-sol-button');
const sushi_choice = document.querySelector('#pay-sushi-button');
const weapon_choice = document.querySelector('#pay-weapon-button');
const quit2 = document.querySelector('#quit2');
const quit3 = document.querySelector('#quit3');
const modal3 = document.querySelector('.modal3');
const airdrop_counter = document.querySelector('.counter');
const weapon_box = document.querySelector('.weapon_box');
const weapon_box_close = document.querySelector('.close');
const blob = document.getElementById("blob");
var balance1 = 0;
var balance2 = 0;
var chosen = null;
var curr_mint = null;
var curr_rank = null;
var owner = '';
var selected_weapon = '';
var wep_count = 0;
var wallet_type = '';
const sol_dict = {
    "Oyabun (Family Boss)": 0.2,
    "Kyodai (Big Brother)": 0.4,
    "Shatei (Little Brother)": 0.5,
    "Chui (Lieutenant)": 0.3,
};
const sushi_dict = {
    "Oyabun (Family Boss)": 2000,
    "Kyodai (Big Brother)": 4000,
    "Shatei (Little Brother)": 5000,
    "Chui (Lieutenant)": 3000,
};
const loader = document.createElement('div');
loader.classList.add('loader');
document.body.onpointermove = event => {
    const { clientX, clientY } = event;
    blob.animate({
        left: `${clientX}px`,
        top: `${clientY}px`,
    }, { duration: 1000, fill: "forwards" });
};
const popupContents = [
    "Refreshing is you best friend!!",
    "Did not get an airdrop? open a ticket in our discord!",
    "Encountered a bug? Notify us in our Discord!",
    "Not sure if your NFT updated? clear cache and keep refreshing!"
];
function showPopup() {
    const randomIndex = Math.floor(Math.random() * popupContents.length);
    const content = popupContents[randomIndex];
    const popup = document.getElementById("popup");
    popup.querySelector("p").textContent = content;
    popup.style.display = "block";
    setTimeout(function () {
        popup.style.display = "none";
    }, 10000); // hide popup after 10 seconds
}
setInterval(showPopup, 100000); // show popup every 3 minutes
return_button.addEventListener('click', function (e) {
    modal.style.display = 'none';
    button.style.display = 'flex';
    loader.style.display = 'none';
    info_bar.style.display = 'none';
});
quit2.addEventListener('click', function (e) {
    choice_modal.style.display = 'none';
    chosen = null;
    //console.log(chosen);
});
function dim(is_transaction) {
    // show the overlay
    var overlay = document.getElementById('overlay');
    var temp_loader = document.getElementById('temp-loader');
    var hint_text = document.getElementById('hint-text');
    overlay.style.display = 'block';
    temp_loader.style.display = 'flex';
    if (is_transaction) {
        hint_text.style.display = 'block';
    }
}
function undim() {
    // show the overlay
    var overlay = document.getElementById('overlay');
    var temp_loader = document.getElementById('temp-loader');
    var hint_text = document.getElementById('hint-text');
    overlay.style.display = 'none';
    temp_loader.style.display = 'none';
    hint_text.style.display = 'none';
}
function create_sol_transaction(address, owner, rank) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fetch('https://saisei-server.com/get_hash_info', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            },
            mode: 'cors',
        })
            .then(response => response.json())
            .then((data) => __awaiter(this, void 0, void 0, function* () {
            //console.log(data);
            const to_pk = new web3_js_1.PublicKey('pDhcgHW36JSG2TqKtVhAx9HauFZK3pcFkVE9kLRXCHb');
            //console.log(data);
            const lamports = sol_dict[rank] * (1000000000);
            const transaction_inst = web3_js_1.SystemProgram.transfer({
                fromPubkey: new web3_js_1.PublicKey(owner),
                toPubkey: to_pk,
                lamports: lamports,
            });
            const transaction = new web3_js_1.Transaction().add(transaction_inst);
            transaction.recentBlockhash = data[0];
            transaction.lastValidBlockHeight = data[1];
            transaction.feePayer = new web3_js_1.PublicKey(owner);
            dim(true);
            var sig = null;
            if (wallet_type === 'phantom') {
                sig = yield window.solana.signAndSendTransaction(transaction);
            }
            else {
                const signed = yield window.solflare.signTransaction(transaction);
                const temp = signed.serialize({ requireAllSignatures: true, verifySignatures: true });
                const transactionBase64 = Buffer.from(temp).toString('base64');
                yield fetch('https://saisei-server.com/submit_solflare_transaction', {
                    method: "POST",
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        serialized_transaction: transactionBase64
                    }),
                })
                    .then(response => response.json())
                    .then(data => {
                    sig = data;
                    console.log(sig);
                });
            }
            //console.log(sig);
            var status_data = 'succeeded';
            yield fetch('https://saisei-server.com/check_transaction', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    signature: wallet_type === 'phantom' ? sig.signature : sig,
                    mint: address,
                    sol: true,
                }),
            })
                .then(response => response.json())
                .then(data => {
                //console.log(data)
                status_data = data;
            });
            if (status_data != 'succeeded') {
                showAlert('Failed to finalize transaction', 'red');
                undim();
            }
            else {
                setTimeout(() => {
                    chosen.remove();
                    choice_modal.style.display = 'none';
                    chosen = null;
                }, 300);
                setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    balance1 = yield get_sol_balance();
                    const part1 = `<img id="sol" src="./assets/sol.png"><p id="first-text"> Balance: ${(balance1 / (1000000000)).toString().substring(0, 5)}</p>`;
                    const part2 = `<img id="sushi" src="./assets/sushi.png"><p id="second-text"> Balance: ${balance2.toString().substring(0, 8)}</p><img src="./assets/q.png" id="faq">`;
                    info_bar.innerHTML = part1 + part2;
                }), 30000);
                showAlert('Successfully confirmed transaction', 'teal');
                undim();
            }
            //console.log('after confirming transaction')
        }))
            .catch(error => {
            undim();
            showAlert('Failed to finalize transaction', 'red');
            console.log(error);
        });
    });
}
function create_sushi_transaction(address, owner, rank) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fetch('https://saisei-server.com/get_hash_info', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            },
            mode: 'cors',
        })
            .then(response => response.json())
            .then((data) => __awaiter(this, void 0, void 0, function* () {
            //console.log(data);
            //console.log(selected_weapon);
            yield fetch('https://saisei-server.com/get_wep_sushi_transaction', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                mode: 'cors',
                body: JSON.stringify({
                    owner_address: owner,
                    rank: rank,
                    wep: selected_weapon,
                    wallet: wallet_type,
                })
            }).then(response => response.json())
                .then((data) => __awaiter(this, void 0, void 0, function* () {
                //console.log(data);
                const transactionBuffer = Buffer.from(data, 'base64');
                const tx = web3_js_1.Transaction.from(transactionBuffer);
                //console.log(tx);
                dim(true);
                var sig = null;
                if (wallet_type === 'phantom') {
                    sig = yield window.solana.signAndSendTransaction(tx);
                }
                else {
                    const signed = yield window.solflare.signTransaction(tx);
                    const temp = signed.serialize({ requireAllSignatures: true, verifySignatures: true });
                    const transactionBase64 = Buffer.from(temp).toString('base64');
                    yield fetch('https://saisei-server.com/submit_solflare_transaction', {
                        method: "POST",
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            serialized_transaction: transactionBase64
                        }),
                    })
                        .then(response => response.json())
                        .then(data => {
                        sig = data;
                        console.log(sig);
                    });
                }
                var status_data = 'succeeded';
                yield fetch('https://saisei-server.com/check_transaction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        signature: wallet_type === 'phantom' ? sig.signature : sig,
                        mint: address,
                        sol: false,
                    }),
                })
                    .then(response => response.json())
                    .then(data => {
                    //console.log(data)
                    status_data = data;
                });
                if (status_data != 'succeeded') {
                    showAlert('Failed to finalize transaction', 'red');
                    undim();
                }
                else {
                    setTimeout(() => {
                        const temp = document.getElementById(selected_weapon);
                        temp.remove();
                        chosen.remove();
                        choice_modal.style.display = 'none';
                        chosen = null;
                    }, 300);
                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        balance1 = yield get_sol_balance();
                        const part1 = `<img id="sol" src="./assets/sol.png"><p id="first-text"> Balance: ${(balance1 / (1000000000)).toString().substring(0, 5)}</p>`;
                        const part2 = `<img id="sushi" src="./assets/sushi.png"><p id="second-text"> Balance: ${balance2.toString().substring(0, 8)}</p><img src="./assets/q.png" id="faq">`;
                        info_bar.innerHTML = part1 + part2;
                    }), 30000);
                    showAlert('Successfully confirmed transaction', 'teal');
                    undim();
                }
            }));
        }))
            .catch(error => {
            undim();
            showAlert('Failed to finalize transaction', 'red');
            console.log(error);
        });
    });
}
function disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            button.style.display = 'none';
            loader.style.display = 'flex';
            wallet_box.style.display = 'none';
            main_box.style.display = 'none';
            info_bar.style.display = 'none';
            main_box.textContent = '';
            main_box.innerHTML = '';
            while (main_box.lastElementChild) {
                main_box.removeChild(main_box.lastElementChild);
            }
            if (wallet_type === 'phantom') {
                yield window.solana.disconnect();
            }
            else {
                yield window.solflare.disconnect();
            }
            setTimeout(() => {
                loader.style.display = 'none';
                button.style.display = 'flex';
            }, 3000);
            showAlert('Wallet disconnected', 'teal');
        }
        catch (err) {
            //console.log(err);
            showAlert('Error while disconnecting wallet', 'red');
        }
    });
}
//const metaplex = new Metaplex(connection);
//custom alert message
function showAlert(message, color) {
    var customAlert = document.querySelector('.custom-alert');
    var customAlertMessage = document.querySelector('#custom-alert-message');
    customAlertMessage.textContent = message;
    customAlert.style.backgroundColor = color == 'teal' ? 'teal' : '#550505';
    customAlert.style.display = 'block';
    setTimeout(function () {
        customAlert.style.display = 'none';
    }, 3000);
}
function get_sol_balance() {
    return __awaiter(this, void 0, void 0, function* () {
        var res = 0;
        yield fetch('https://saisei-server.com/get_balance', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            mode: 'cors',
            body: JSON.stringify({
                address: owner,
            })
        })
            .then(response => response.json())
            .then(data => {
            res = data;
            //console.log(data);
        })
            .catch(error => {
            res = 0;
        });
        return res;
    });
}
;
function get_sushi_balance() {
    return __awaiter(this, void 0, void 0, function* () {
        var res = 0;
        yield fetch('https://saisei-server.com/get_sushi', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            mode: 'cors',
            body: JSON.stringify({
                address: owner,
            })
        })
            .then(response => response.json())
            .then(data => {
            res = data;
        })
            .catch(error => {
            res = 0;
            // handle errors
        });
        return res;
    });
}
;
function get_airdrops() {
    return __awaiter(this, void 0, void 0, function* () {
        var res = 0;
        yield fetch('https://saisei-server.com/get_airdrop_weapons', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            },
            mode: 'cors',
        })
            .then(response => response.json())
            .then(data => {
            //console.log('weapons:')
            //console.log(data)
            res = data;
        })
            .catch(error => {
            //console.log(error)
        });
        return res;
    });
}
get_airdrops().then(data => { airdrop_counter.innerHTML = `Airdrops Left: ${data}`; });
airdrop_counter.innerHTML = `Airdrops Left:`;
const publicKeyFromBn = (feePayer) => {
    const bigNumber = new bn_js_1.BN(feePayer._bn, 16);
    const decoded = { _bn: bigNumber };
    return new web3_js_1.PublicKey(decoded);
};
//connecting to phantom
function connect_wallet() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            while (main_box.lastElementChild) {
                main_box.removeChild(main_box.lastElementChild);
            }
            if (wallet_type === 'phantom') {
                if (!window.solana || !window.solana.isPhantom) {
                    // Phantom is not installed
                    //console.log('lmao')
                    showAlert('Phantom wallet extension not installed!', 'red');
                    button.style.display = 'flex';
                    loader.style.display = 'none';
                    return;
                }
            }
            if (wallet_type === 'solflare') {
                if (!window.solflare || !window.solflare.isSolflare) {
                    // Phantom is not installed
                    //console.log('lmao')
                    showAlert('Solflare wallet extension not installed!', 'red');
                    button.style.display = 'flex';
                    loader.style.display = 'none';
                    return;
                }
            }
        }
        catch (e) {
            showAlert(e, 'red');
        }
        try {
            var obj = null;
            if (wallet_type === 'phantom') {
                yield window.solana.connect().then((obje) => {
                    obj = obje;
                    showAlert("Connected to Phantom wallet", 'teal');
                });
            }
            else {
                yield window.solflare.connect().then((obje) => {
                    owner = window.solflare.publicKey.toString();
                    showAlert("Connected to Solflare wallet", 'teal');
                });
            }
            loader.style.display = 'none';
            main_box.style.display = 'flex';
            if (wallet_type === 'phantom') {
                const key = publicKeyFromBn(obj.publicKey);
                owner = key.toBase58();
            }
            //getting sol and sushi balance
            balance1 = yield get_sol_balance();
            balance2 = yield get_sushi_balance();
            info_bar.style.display = 'block';
            const part1 = `<img id="sol" src="./assets/sol.png"><p id="first-text"> Balance: ${(balance1 / (1000000000)).toString().substring(0, 5)}</p>`;
            const part2 = `<img id="sushi" src="./assets/sushi.png"><p id="second-text"> Balance: ${balance2.toString().substring(0, 8)}</p><img src="./assets/q.png" id="faq">`;
            info_bar.innerHTML = part1 + part2;
            info_bar.classList.add('info-bar');
            body.appendChild(info_bar);
            const question_mark = document.querySelector('#faq');
            quit3.addEventListener('click', () => {
                modal3.style.display = 'none';
            });
            question_mark.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                dim(false);
                setTimeout(() => {
                    undim();
                    modal3.style.display = 'flex';
                }, 1000);
            }));
            //console.log(key.toBase58())
            const display_key = owner.substring(0, 6) + '...';
            wallet_box.style.display = 'flex';
            wallet_text.textContent = display_key;
            weapon_box_close.addEventListener('click', () => {
                weapon_box.style.display = 'none';
            });
            let tokenAccounts = null;
            //console.log(key.toBase58());
            try {
                const temp = yield fetch('https://saisei-server.com/get_tokens_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                    body: JSON.stringify({
                        mint: owner //key.toBase58(),
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                    tokenAccounts = data;
                    //console.log(tokenAccounts);
                })
                    .catch(error => {
                    //console.log(error);
                });
            }
            catch (e) {
                setTimeout(() => {
                    showAlert(e, 'red');
                }, 5000);
            }
            //console.log(tokenAccounts.value)
            const set_data = new Set(suteki_mints_json_1.default);
            const set2_data = new Set(_544ZHb9RNiZbBdfW8TdYMp7tUAbHESs8LtDNR2SVqrC8_mint_accounts_json_1.default);
            var num = 0;
            var wep_count = 0;
            for (var cand in tokenAccounts.value) {
                const address = (tokenAccounts.value[cand].account.data.parsed['info'].mint);
                const amount = tokenAccounts.value[cand].account.data.parsed['info'].tokenAmount['amount'];
                if (set_data.has(address) && amount === '1') {
                    num += 1;
                    if (num === 1) {
                        const size1 = document.createElement('div');
                        size1.setAttribute("id", "sizebox-1");
                        main_box.appendChild(size1);
                    }
                    var nft_data = [];
                    yield fetch('https://saisei-server.com/get_nft_data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        mode: 'cors',
                        body: JSON.stringify({
                            mint: address,
                            type: 'teki',
                        })
                    })
                        .then(response => response.json())
                        .then(data => {
                        nft_data = data;
                    })
                        .catch(error => {
                        // handle errors
                    });
                    const img = document.createElement('img');
                    const data = document.createElement('div');
                    const info_container = document.createElement('div');
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('loader-vis');
                    main_box.appendChild(placeholder);
                    img.src = nft_data[2];
                    img.onload = () => {
                        placeholder.style.display = 'none';
                    };
                    const rank_data = document.createElement('span');
                    data.innerHTML = nft_data[0] + "<br/>";
                    rank_data.innerHTML = nft_data[1];
                    data.appendChild(rank_data);
                    img.classList.add("suteki-image");
                    data.classList.add("info");
                    info_container.classList.add("info-wrapper");
                    if (nft_data[1].includes("Henshin") || nft_data[1].includes("Max")) {
                        //console.log('hi')
                        rank_data.style.color = 'red';
                        const lock = document.createElement('img');
                        lock.src = './assets/lock-1.png';
                        lock.classList.add("suteki-image");
                        lock.classList.add("lock");
                        info_container.appendChild(lock);
                        info_container.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                            showAlert('This NFT is already Max or Henshin rank!', 'red');
                        }));
                        info_container.classList.add('invalid');
                    }
                    else {
                        const upgrade_ind = document.createElement('div');
                        upgrade_ind.innerHTML = 'Upgrade';
                        upgrade_ind.classList.add('upgrade_ind');
                        info_container.appendChild(upgrade_ind);
                        info_container.setAttribute('id', address);
                        info_container.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                            choice_modal.style.display = 'flex';
                            chosen = info_container;
                            curr_mint = chosen.getAttribute('id');
                            curr_rank = (chosen.lastChild.lastChild.textContent);
                            //create_sol_transaction(info_container.getAttribute('id')!,key.toBase58(),'')
                            //sol choice
                        }));
                    }
                    info_container.appendChild(img);
                    info_container.appendChild(data);
                    main_box.appendChild(info_container);
                    setTimeout(() => {
                        info_container.style.opacity = '100';
                    }, 10);
                }
                else if (set2_data.has(address) && amount === '1') {
                    wep_count += 1;
                    var link = '';
                    yield fetch('https://saisei-server.com/get_nft_data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        mode: 'cors',
                        body: JSON.stringify({
                            mint: address,
                            type: 'wep',
                        })
                    })
                        .then(response => response.json())
                        .then(data => {
                        link = data;
                    })
                        .catch(error => {
                        console.log(error);
                        // handle errors
                    });
                    //console.log(link);
                    const wep_img = document.createElement('img');
                    wep_img.src = link;
                    weapon_box.appendChild(wep_img);
                    wep_img.classList.add("wep-image");
                    wep_img.setAttribute('id', `${address}`);
                    wep_img.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {
                        selected_weapon = wep_img.getAttribute('id');
                        weapon_box.style.display = 'none';
                        yield create_sushi_transaction(curr_mint, owner, curr_rank);
                    }));
                }
            }
            const held_weapons = document.querySelector('.held-weapons');
            held_weapons.innerHTML = `Held Weapons: ${wep_count}`;
            if (num === 0) {
                const no_sutekis = document.createElement('div');
                no_sutekis.innerHTML = 'No Suteki NFTs<br/>Owned!<br/>Get one <a href="http://magiceden.io/marketplace/suteki?activeTab=items">Here</a>';
                no_sutekis.classList.add('no-sutekis');
                const ref = document.createElement('div');
                main_box.appendChild(no_sutekis);
            }
            const size1 = document.createElement('div');
            size1.setAttribute("id", "sizebox-1");
            main_box.appendChild(size1);
            //console.log(Sutekis)
            //Do something after connection is established
        }
        catch (err) {
            console.log(err);
            button.style.display = 'flex';
            loader.style.display = 'none';
            main_box.style.display = 'none';
            showAlert(err, 'red');
        }
    });
}
sol_choice.addEventListener('click', function (e) {
    return __awaiter(this, void 0, void 0, function* () {
        yield create_sol_transaction(curr_mint, owner, curr_rank);
    });
});
sushi_choice.addEventListener('click', function (e) {
    return __awaiter(this, void 0, void 0, function* () {
        weapon_box.style.display = 'flex';
    });
});
wallet_disconnect.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield disconnect();
}));
button.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    // Hide the button
    button.style.display = 'none';
    loader.style.display = 'flex';
    if (null === button.parentNode) {
        throw Error('refNode.parentNode is null');
    }
    // Add the loading indicator element to the document
    button.parentNode.insertBefore(loader, button.nextSibling);
    setTimeout(() => {
        modal.style.display = 'flex';
    }, 500);
    //await wallet.connect();
}));
phantom.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    modal.style.display = 'none';
    wallet_type = 'phantom';
    setTimeout(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield connect_wallet();
        });
    }, 3000);
}));
Solflare.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    modal.style.display = 'none';
    wallet_type = 'solflare';
    setTimeout(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield connect_wallet();
        });
    }, 3000);
}));

}).call(this)}).call(this,require("buffer").Buffer)
},{"./544ZHb9RNiZbBdfW8TdYMp7tUAbHESs8LtDNR2SVqrC8_mint_accounts.json":1,"./suteki-mints.json":3,"@solana/web3.js":30,"bn.js":33,"buffer":61}],3:[function(require,module,exports){
module.exports=[
    "122FgrdhgHyNVdnPBWpC1EU59izZXzeJby9cCxREkFct",
    "12C8zniKNAQ42NMv6fGsxwAXsTkLhA9MF1Xv5xAC5fNZ",
    "12TBhko6RgL3q4N95ufZ59Rubpt2KSEYWemnag8iwPL7",
    "12XvBUvtnpAJHTAat352r1Yr3ciEmdmMZcSkQsaDp9E4",
    "12dswk3sNFiKbsFC1U51838odVTsmr6RVs2Zkr2Pu6vm",
    "12y93h71mssRaVnkzorh9PFVJHw1kg8ZaQVF1V1L7eui",
    "12zgxSMiZmBKDZ8bS4CWSBspj16agPyJme9zucVe88LW",
    "132Y9F1VVDE7sm7ciHRLmU8znefbXV13srqibCDpNU27",
    "138xsCE7gVmKMCSevEfWVkBhVjjosScbP6sqUaeQqozU",
    "13KgDrhzYdKYMWsfn8ExrGb71C3bjohLB43NzUtfPFbn",
    "13WyMvU1B2dscFukq3tG8JjrVTdMdVv7iDBSoBbbJ6QY",
    "13odFPMTVvXCEXSCKZu719QmFUwLzWtFt3QHRjy18asx",
    "148uTWxkTpyEBVAgg7vks88rkZytRCDLdEAcjjduqGRS",
    "14JVpn7xhcRLyb9E7XgQiJfQksYQrdFpNLgmydgPXo9m",
    "14RjXFK12sPhgUWt9zMSJ1LWyxPx1UTjj8cRuv8rDWRf",
    "14b1bEc3nkYmZTbYQ2F9iLxWWstTuPJG4vXykdo5JrTJ",
    "14nkUM23eVX4o3eMchcydD5BxbDo2EJnCGQuXiWKEq7v",
    "14r4BfhDW1EHFuwZqoFgHhB45xMjeTcaB7ePauigchPo",
    "19jjyXL7asa8w6UyGscvhazjnJxjhFxxUusJ5xS5J1a",
    "1TdpjuTqSYGH36dqcQX5H3DiAbtPjt1nreGMNGsR9ia",
    "1irrqpaBvGX1qteRMsWuinqccsAorGLD3ebEGE9Raaq",
    "1nLRwSkUFnieBDD2bPfpNv7uLmpfuKdT5SGJ3GUrzUQ",
    "1y1zz5z3j7K8dB1u6MDgdLKWtASjtqCeU4XJVNEt1v8",
    "218wfuh1SQxsDe3ZtjMZfS8y315d8jFnXcV5EVrexLvq",
    "21H1zbJgpjGtZ6BjbLGFbwz1qQNDRtUUQSTjFhKKGMPK",
    "21P8oaEbtGyaox9j71AfCcfTHwi6K4u4dCGcstrYmQa4",
    "21XY8BvWugDCfgn34CL3CZEaQjBSZuQwpRj6VP2u3qjz",
    "21c9Y61HF8g9FJasXMfdpLmyzyCMXEKHp8H1B2jDEKtj",
    "21h8uWmVzujUoW5hGPq757YzfxfHHBTsfoh3BjA55fLG",
    "21wZ6wh1HpNRMXWDHsyaC2Vkcy1uroUkDbtyZrhfMoK7",
    "22fK7gT435Qg9cABgFfpx4UFyc5L17ry16mZsot7pSMq",
    "22fm6pRC3NGtHg6denstDVgCkSGHDGBWCJr5cYWwnNEG",
    "22yFz8N1riyRVmvM4vC4oUjCUSo9EqmDvxvEwupaVSHP",
    "22yYYS4CWBZ8ZPwP1LcWbjrBmghPKckbNzqYS4hMrorg",
    "23JGfxwGL46jcD1TZpPGSwLmLYGJASbXJtCpvoesFE9R",
    "23LfSqSCSrzw8nPF1Sz32J6DKCanFNtjWum7zR3My1Sh",
    "23Pjis5JQ2Myzrk2KXEGsUGEuNBpueuCvEEaFkSXS72z",
    "23sgYRRmbY8kpTBFAroDpzc7hib5AzPGePis2rbuYKaQ",
    "245sg8ErsaoSGqXGB39newRE7sxRZZToYf6heyauZjwu",
    "24C7KRqBguUq3L3P1myuV9Ru6JiVnG1nB7PthaBj1pTc",
    "24TggVwHf22RH5W8A6RN47cckxNgUpZNagqZwL8zCQwU",
    "24ZzL49jTUwBX5dQELdqwxHs5s9gTknvtnKadJzmRX1i",
    "24gWfLhFwXJCEt8aMDSBpxGnpYLJ8D4WfEXsS62yd6Cd",
    "24iY52wKZyNJR2vYkG9CstdCWCZWz8jRqSX1J2cLWEeK",
    "24kuy3qH2fu36D5BNnqmD5RfuTK9B52dG2sFZpKijorH",
    "24nFzRNahmEQRjx67qfK5wrDz182D9TRU9vVEFfwZpsG",
    "24qmCaHFTY6G6d3wuQvhcY9uindnnjCzZZLPbN7Pg4ZC",
    "24uwCYqL5eRALtow5umHG2RYFhCaEyymX5evzkBXXgAU",
    "24w7mVjMb1LkxsFQBnTbAe1SwKkiWozSAHCLQQQ9zbXe",
    "2584sPngeFEvHA9wkeEGPPsdA6ySW5ZztWpChaYxHJ1y",
    "25BYgaEC5YyWPxbXCnXGbU7rci9w3vdM4NFL5ieXaEhW",
    "25C1o7HiF5aUDY2Uf9AwTcyCnYWcXyy4PY1ieG7BbjDF",
    "25Cw2iqe4a2pzc4h6W5zRVenUdYHAbHaNvXu3vEVDJ4o",
    "25PBCCFF9x1XtJLbsg8z2WbLZtEneUZAW3j15WBCtKBP",
    "25Qhj42dz6T9uoaY7HKcMvVomGfn4hG7wzRxoKrtsoD5",
    "25YNjWeUXPeRp8MhngjsYtKSbgL9YttLxX31gdZnej2o",
    "25ZpwxJnyB1V6tsUa6FYhjHSfw5uC9XhFBcWepwXUdY5",
    "25dyLPkqi2Py8dS3je1n9XmmDxiFzNLrtQsKpzkrduH8",
    "25q9YYA5EtowFER7nu4UfkXuuEbWuL1uoUEa3ha47q7s",
    "25uwGZUyvAFC6HjZynT61ZqyM49tuiwHcos4qTgqQpod",
    "268Vo822sVCCAt1RtHQCZiuCcu3h7aQeopaHUTcv6AWB",
    "26AzczwRjTJ1ABKzpXkQK8EDBgKiG4VAoV9Z9wnmguuZ",
    "26Qy1KyBKraHKtpkFKxf9ovqJJCiQC2PvW3ZJGJtZ54z",
    "26gPeZXfXN8QnqBNdn5Ro8af9ZCuVkjJZDHp5z9o49yn",
    "26iPSZBvGj9ByTFVzusSvSMEjLD9skRBEH8pt6rdZdVG",
    "26tE5N2ZKTxTfAhyRuisauVQ9PXcg9dj9wYKd4C8C85E",
    "26vdYim1TSr9wGWLT6L3ZdiXhzrAdoF6JvWZG5GuWxSr",
    "26x2tSW5HquBnBbfRrY7W1pnCifi6kBonT7FpuKmqxS2",
    "272x2je7dUHyxavBgEV3c8C5j9LvyZ5pRTkCg7cUttN3",
    "27DTA6WTcCFY44CDVptJbUjppXu4SBVwikgeAemYav2A",
    "27H7Ljo6uAUtphyHDsS5KS4dngEBpudbn53nTuAhDktv",
    "27feNH58BqipfBqvJLX1tsTGSNbhgAXbH7c8ca1iHqJS",
    "27hdMqAdARNyzdE6nB7Tbj7UecFZkQixfHmwPNhCpeAy",
    "27tFPHK5F9gMuvsUzkuCfzXCvq6KpPrK1w7NFFubTW4h",
    "27uF9vAm5VbCH9DawcxAfFpjUGKFTXL9jiEMrRyCc1wV",
    "282ZJvLoBEVsPXj4nipAV22UfmULgU5xmTSUgsXc4viL",
    "28DgLY72zAGgQsYLuPCWgjE34hFbxUB3rstJeV5gcXVx",
    "28FWT7erWaRETYPwu7WUifpk55T3beXZ4vRpB4rGPHs7",
    "28QiLuMaFEYKLpmH1BBviHogGH3BLeH9uaJTJvw2ny73",
    "28vZJ72dkG4VioNJpnYCovvF1gJvap6WTzupUeRLGbQR",
    "294bNNT1DjArxWkzJpETgXxLa3X3Mt91s4ykEqYXrbwV",
    "29BAHBmRFkSpRtpdzB5sAMBcev9vocthVBTkxNbxxWE7",
    "29Kj9d3ho4dquzW9NKTsZ9TK1sNNEcYdpLqPwQasm2qm",
    "29YfbQjQmSKsxEJxEijQppp7ib1uS8JHyinpsxbGmGyf",
    "29eYerRtDx54sLvy4Ed7YMeLvFpnfziXWxGpWrFhRhWA",
    "29khRSPShYnoVD3cPNhYdeeoqDzrp2pDPwDLhTWffogC",
    "29np47sdrZVX5FfihsCbP6uMcF3ET5dUN4Vy7tZNkvUN",
    "29rUQsCMs4hB51WtSV8TCdGSobryaHYgyT5pLtrkQ21N",
    "29tCvvNDiHTtBg3sys7z73nDojqisMSNdnvij2UMdTEt",
    "2A1Ak3AhbnKU1SmNF4YNJ5CPKZvZbWyV5XgQ3m2HGpZd",
    "2ADC8F3Nsma9WMo5sG59tRsuNAnn2JUxatKEb8myyMTY",
    "2AvPCAdr95DzvfYtS7qUHghHKxJb7s1bV2rDBhQMiLKa",
    "2BN2K5LXumoWq6pDvbNF5LsvYoMQ5mCZ5sDHWCGXQvw4",
    "2BgRWkwJnzbfJDADtvHcTHGmLP2J1zmgJoZgqXcEPy9v",
    "2Bj5RDdVJHYKNfUDoSTa2hRuDEWuCDL7UZxpQaxnB4yz",
    "2BpHzVwQN6iPUHZNThy1tC6AF8dYMwU9wKf2ChWX84o1",
    "2CB1dAzC5EZ6AkURXHbfQhJaXJXXJYS95c7aUxEpfMiA",
    "2CVKyRwhYvTAAMryYvjUuZLYzTR7y1tfeYZHGFkAgVZ2",
    "2CfYWLLGd9q2jxTkfxnNNjp5w2FaWomssA6jinLwYwmM",
    "2CsNQr4hCXKPyD7gW1i64AY4dUxNFcDmTemPosGDXEFt",
    "2CwGvTtVvZzQ2MebJv77p2kMMrbJnuTFKrQHcVJeQe4Z",
    "2D1ALFHYQXYVfUJaS1GbzYfQgcwHK81zwuNT5EEMRfZf",
    "2DDnhyNLeXahGtuTHg94JCStHHSPQk8UNtoCFeReoR3B",
    "2DDyqRMZX9FjYC2SfaH1vxuwx1rRrYvGSKzNPUXqZGYf",
    "2DESRjRfHJRkXe1CEnYL9fCY3BkqfTvMTpEsvzgGGjCM",
    "2DbmNMAiPSfCgpXLDFwQ3p81VP5YZGQHgiLDqkqekTLe",
    "2Dh3J9vDNogupCLUUSjRaJw8sGqVck2dGbLepZ1eJQLi",
    "2DpKJzfdLXMGr7tEvvq1kksrmN2htSviW8gDkSJj7nqQ",
    "2E425LYfQSTbrENCx6Exyb2VgzsML4hCxq7gdMf64xwx",
    "2E4UiQA1JAGA6piw8gRA6LnyQdpihrrSgrfGPmQkjozq",
    "2EH6qBc3xXJMLRcXCWiivsDPig2XfgwcTvXJA7EigCW7",
    "2EXV647ixequUnBPNKBM2ovWQGJJwFrs1tjvZ7a2Ynvy",
    "2EeiDgY1K47EGZGybRCyjp7z9N9kDRintxzB7dRkeWch",
    "2EhK9PH39vR4QAnhx6H52WXyCVg94Uj4YikMmByhr9Ls",
    "2EiC262Prz3HC6XxV8xNxPDXimuQpSxpRXcFeCwoC9RZ",
    "2F4SVbHLQuuxusN1HC8hpvE6uoQt9MfsWs2WChFczoHE",
    "2FABfvoRg3jLrthjKbqaidca6gxyQeT3oXBpQZc8XzNm",
    "2FERWhfNJ5wnfDssp2vzR9ML9y2KkUGbh59ac23zVsY5",
    "2FJqDU5MZeKT3KgAnZQpXaEQjpb1WmWSXHwspLfUXCj1",
    "2Fd9spH82FRUpkby9ZzNYwDnbCUdkzC6VdNr2TQ3xo1M",
    "2FyZuGYGZqB1AYJRVW2dATbSeqwGcT4uj5ETTimo62zJ",
    "2G2LVSU9SRRd6G1R4kk8wPGDAJYDywUj89q6t6dH2xHo",
    "2G3PxRm8fjkDKC15VJPJRUh7ck6KdzcUfgkZZUdjXLfa",
    "2GC59sNHWNbcsxK2fyMy7k6Qn2pcY7UwH1GPDiE8dpAt",
    "2GGMcNDWwjwbvSX4DsErqTjKbi5SDKP5pse3UVuTrXQi",
    "2GLhgtXqQoMVtG9XDqEMippq5wMHfpHWCcRt3UTZZYm9",
    "2GWcwMdKRX87xxFsHxHTUpT36CyV3vkR8axeFwQm8mKw",
    "2Ghcc7SyLWcpYv1miJw8LChXDnj7AJpCVvWPTLeY9RBk",
    "2GpUEzRX3svhW7ySJBFEvzJYJTUTAbLydhubvGQDkqRB",
    "2GtwZ1sjDA4ThRRUY2BAq1AxMaLZ9RuUJjXwVrQJDKz7",
    "2GzY6ZZKzZnmkz44gTMuPEXuMqvcTeWXanadZqzz2pmC",
    "2HQujDW5b85DrAhNY3GPxtZZAFT6oUcUhAE1p9gFYoEP",
    "2HUxZz2uqQz5RN3H6pS29e69h2hnpYNLoGkRCfwg9DST",
    "2HiJcfRPweAWzFSNgavAcHjvwCxf3wo2bXrd5hfTHwca",
    "2HiPssaVB6PgRLottvk4QaPffwG9rVDNEkg5RqbX3nSN",
    "2HoneJw7WK8aEF2r9SjzPhYt4kownkuf2qm2XKUmXs26",
    "2HuQsPWY4qd4gWP6JdAreV1XLFFRcsak6BQb5hcVwvf3",
    "2J61UZHvhD8hQMirF6DYsE1vQSjtttdh36BrwzhcJ3dt",
    "2JPFcE2MGmHbV7rkzXnfPSH2tc6KnfcEwDC5H7hjYYrm",
    "2JcF345ULPxxmLDMDGuJvswDHbDZyQ653RDNS4tXsN4k",
    "2JnFSt6aap5Wh2czbuDNDosXjFNX2hiGhNgZqyCDt1mH",
    "2JqACxdXZ5M4voqwktr1d1tUzXkNHWQ3bkJLCfdVREt9",
    "2KnJT21mWJrkJYj39kNFGxfyHNxwcToGHb6vMBto7DEg",
    "2L6tXBJEuC4exBsq7FKDKkMqW9XmQuR3L2GF2Ks6FMDe",
    "2LLZq3jJW6yqG2JdfJ6kDDNPS4qb65Dm3MgkuTp8tBHd",
    "2LRhPTUZx4FTXdkp4Yv31ctKEUudnpgfBn1bncGSgtW1",
    "2LmotfnNhUVfCaWt3HuxFoEjmQPk7PfNXqhwjUhXssGK",
    "2MVQ3faMsYy9P9XYtaHyeiGeWrNiy7UDWugE4qvHcma5",
    "2MVeJYVMnTLe7rCjTfCvm7CUQA3MJxWZB8cGHaQRZe6n",
    "2MWaPiHxcjHVsZTqPBtx5WdkxRt6qoMARCUynUjJSRaT",
    "2MYRJWj3KVHJGrcjF1gmiQ1wSFHE3A5AYf8m74MRq9Dk",
    "2Mb2gGnYNh8gLFSyqzR32F5cHwNCfZiv1T6qnZRmAqhw",
    "2MeMUEzvh9JTjoqvkNPcQRJJKSM2zaRDnQ2XNxRkYtWL",
    "2MjwibJ17EQQDLQGkc4tPDEiFgVvz6DqUafMz3QZhosE",
    "2MqNrHaoVWuzLrmcYLZTJ7t1SiPfpV8dLk2fHFGiZt8u",
    "2N4HVcN5htagpHGS1K5EmrAXPvjzi3sSZWdKn78GQsZd",
    "2N8KfakLkuQkHYUDFgcdDW2C1D4muKk6dJWDiwubVHRs",
    "2NcLLqGzxHkUCD8b889fHsFvrLnHGPXqPbZJufzpncch",
    "2NqCR9vUo59yQrzv8JdxRxTqHZsya4vTJfPay9q1n2KU",
    "2NxDE5wmkztfVvEd7N6ZHRJ5m8o7vPeFNbQC5ACiXatt",
    "2P7Fknux6HHAvWZTA6f5ZRdAsdn4YM2SbV4k6QPiJCfZ",
    "2P9n7frRkrfHyKPsURLpGQvL3M3d9s295tLCcpajGFwK",
    "2PCP22uKoAD7P6MNuaWqA39i1LXyJZqqoeZDg76LuKno",
    "2PQ5isEzunXCMH6wYKnv1QuKuvc5Ur5cAt3T1VhoNb7q",
    "2Pajo4mbJ4vHjqhPeCTPDymUJaet9aebZw2fpQ5AKhwF",
    "2QBMUDVjoDrQqzbVdFnPHuQpuD1zmLMjN9zBdCAyaTQr",
    "2QW75wmwtjpA564it5HGibwVSpBjTHr2XfSbEgmw8VoR",
    "2QcYrtAb2X9YdMjzprfpr5E9oZpXrZQ4N221oDpU1tcs",
    "2Qf1CoWpFCfVHicYoFX4iTV8FMun2imXuJz1KcNJTP88",
    "2Qk5meWCUwqN3eDsgTAqyKKe8CTSzPjYpXbE6kvFGMzV",
    "2RHBE3Tgiptbn3vpr8YMAmBrpwZnfRBsZos5qpgvNKCm",
    "2RWGgZpjXaaXXXySpD14MQPfABDnTR5VNzjk937t4958",
    "2RWMdU2JpUY5NMyXZhEC8bcjkBid99D1AcozMNB4p4Jp",
    "2RtcLQAfKq2EfAhPV7A72cXLt4gcwiUheDp8ZcsEQMpW",
    "2S3s4Z6vC5rCHLgcrSUYgJntJQ5bngsvKPxBjaaczCZj",
    "2SE9SorrrDNreEjousjwgmiMiePAHZxT7wZriiABfXok",
    "2Sedc4VvsgALw4JGbWt9rJJkp1EHFU16tVRnEdzTfMiF",
    "2SjcqWmGYhePfZyE2C8XE7D3FCPC927P6PvAE77ipNw9",
    "2T1VKAVQj4bi6t8HtXoTKrfhMqbGs6eAjfFqKEDi9D2y",
    "2T9c2nxKHR4s286mYS3FYQPbe52tRCdduCAx1sMkpJZX",
    "2TDb2iTPX4jzpnsRkvRZ34QBgyoVCb9ziHyhhisdB55W",
    "2Tc68mKAKTVp9xSPFtExsqnREiGupGAyBc17AqkehEy5",
    "2TgrGE8v8H3ZrZSxBRcdaUxGJRMuctpT86staVNWTFyi",
    "2TnzPupgQQ7sRPHp11R3i8vFz8q67oX4o67xkfjv4KJR",
    "2TwC3UBJB8vT2qQ3DLYDcoZ1mHCBzxxFuTxatrTq3yKM",
    "2TxwJL7uUuNtnK2hbBqKbtnNrjCDYVCnL1zcnmTpe6WQ",
    "2Ubqxegpo6vr6doytDNRXfuiiS3EtU2MksupVbEF9rA7",
    "2Ujrg5zJNWtnyZu6yat1uy9x1PNigaWL2Q5HFKNk7As4",
    "2UtcScKqjrpaxaZcXZczSedubhaDdRRkcPyThZ3Lfztr",
    "2Uxb74R5omeLPeHVzC3hm22tdHV1BGmGsbgNZvEtGuzW",
    "2V3BfbHSjnFVDhkcwHq4yBMUac4B6xFApWLDCWnji12n",
    "2VADSSUCwbytdf3pRw2nTcR7PMctak7tm6P2VkejvQ1o",
    "2VHneM5F5B4iXMN4hGSG2e6P718YR4sin6RuDM6mDfpD",
    "2VKm4PVq6JqGsWokyM4yKazqjwVsRNXfgyDtdQHhRdmc",
    "2VRYwZ7D396taz5ZQC34i1TvE7PcZ5eubiFAVgt5DiUc",
    "2Vcfd5ryfiedxAQvnkfYVVAysBanU7dgC2PsMxmtmxeJ",
    "2Vod53sDxikvpcFa89CfrAf5WhYYvqZe7sxnLaXV5cEW",
    "2Vrw1yinPpAg3EHTS84JBh48vh3Vh8Y8jwcR3jpBnn3p",
    "2W66hGyo6xvAnExcAMmU4gPPwPsox3XihMGUNCFMsjXJ",
    "2WDQqMzAkeQ3H65ec3UQhgQc6JjkrZUUYuBAt1vqjTbf",
    "2WGg55gbGdPZSrpWjhYpsBSyUSXj57J8LCWwtixJ8y1T",
    "2WLgPMfbrCD3uLk8jSTFPqRiaAeQZ6DdVPHqhUu8awAz",
    "2Wa1yqSeuDWEcBv41FZfRmPLpXh9JjbSHzWp2G5EnkQy",
    "2WcLBR7DJU2NmQgcNoHw4Ty15JMJWeUJSCXofgKEWknU",
    "2WnaioqkGutJdAsQQQPGY1JvMumuenmkbnPz4hVUWjfe",
    "2X6J9tsKcG64pcchhjGspmm3rnyvFPbYh87ckB3wvaKZ",
    "2XQFkXsKg9R9J6qSkeYa8zdyTac4ZKAArumAjo3b8mLu",
    "2XWg6BYESbPw5eV9NXDvp39bpdxUyqiQJfDSJef7o2eg",
    "2XdZS3bWobBbNjZBSJtMTYKC65oWuZAhpsf3nZEEuJn2",
    "2Xh2zdA5ediUX5erxxnrAn4YTN2zru1Lm3aiKZTQkbmK",
    "2XzyCMRs3JHKoMhdvV1HQ4PBLQawHqsnxF7Pw388XYvK",
    "2Y9K8bcY83yjwEpXKZvDocnUfxpfjvdAanytP19fifno",
    "2YECAirjwqSv3chaPhca2wFk6UNTt4CLYEEVG5JWwuJP",
    "2YhPVivhEAF3D7tjAKPo2b6aDCyTZYCaywqcAU1Y8jtT",
    "2YsBGW9CbN9dxZtfc5dgsLF9ENb8n3KstCqtPGGjRLjc",
    "2YtR51G35shEsJeqsdMgRsNTyVDmFLqo2zG3F9RcxPGh",
    "2Z6xezy7CKPJ38sCZLY3WzaEKQ8RpzNaEyJATrtdhASx",
    "2ZAfjrJxJP1J4BeDrxj1cs3TJj9TPGuwX6M5dqyE2Qvb",
    "2ZB4J8spLrziLwSznr9amwA6XVDK1Y3tXMwQJHFik2eh",
    "2ZSHTZ3HVGNTNDrs9pHSopsZakRiLsQbM6LRYzUbc61w",
    "2ZX1BsAo7HMSAtop4vK69dACcEaDPtaybRG6F6om4Smh",
    "2ZYaF6N1ocHKLoA1FQG8jNUotArUszaxEaHH69cpdbJA",
    "2ZmupC9HFsEQbcryrSQCDCoMhJqbd2SVAx9cAVqDbmZR",
    "2Zv7nUuRtJNCkZiuasfy6y8o8JPooP4nqUcsBPivTcXE",
    "2ZwAKhWoRtJcMdTz6SbiB2pF69dE7BFG9Q14vWqgonWa",
    "2a4GdALcsv3HZrLKGpBBPJdM4e9X7DCpDp4Lt7Fzj6YA",
    "2aMjjRbp6SjSZHEVrC9mJZj3gUycSiekYARDm6NQVioM",
    "2aXG65ajoQUmzRw78nSUEd7rdRSBDrk938gr83KVMcNb",
    "2aeJsAxqqS5ooLzBKpFvg2ve4ToBVAKycDHzVfK4CCbK",
    "2agLLaQh5WakT8PkP9svDzF3XFJf4ayx2jRiJtCHLLer",
    "2ahTFFy5Z8EQrpqWgPpsoES4oYGVeXsHULqthjNPSjUA",
    "2amcAMxQHKK1JkrcUjLMY73Sw4epmx8ba4K7pP29R1rJ",
    "2ashV4iSxiLkvuoPRW1unVvbwuinMWeJN8jZcHF83vpv",
    "2bLq7PQpKuEpvT8fVqUNUPobmn2ybgCSf7SvaZuQHnT6",
    "2bYcbUfM7nyt3LdDfHDeLz4LVLiAN5ohtXcmheEUcp68",
    "2bdLapZCv7vzK5P8KJXsqhi5S4gbc1WtXRSw5YNU1WSf",
    "2bfBQit6eQsUTvsMcEdRDs5z9giNq1f44paYLFeqM1m8",
    "2bvT7HcLh7SikMwLcRyeZgRRvbxhs1cTruDZN2p8dpeQ",
    "2c5JyCoouKY9F5FLuaBmgLDUH6qT7mFEE2Mv4aEnLfyB",
    "2cRn2rjPHMSqUowZX7tSCZrn7ujkCG9vXYYtT26U5RNG",
    "2cWQqtgZZpLN1hNYzX6pN3affYVS5SD2euvfj4jjyPTk",
    "2cbENcbNLB6AdGi1cJVn5grrqCg1ocQHKynKD74DUKxY",
    "2cfRkd3j6kNmSW8NZiVSVydGet9EbQUk2xr2aX38wePp",
    "2d31igRJMA9GPAdPMrvBoQauDAcF3z9APCZ5NwJyWcTz",
    "2dZP3W93sa2kVcSp97FRQD1Kd2QLBXYQ4eNfJCnYQG2P",
    "2db1jTddXEvaFTdzwG5vDp5pbHm9nmH6ZxYhixTMaeHE",
    "2dexSau8VpjwWCNVZWanxRvTprSTW1eCKMR71q7HZBtF",
    "2dgzoqCW7xf7oCQEt36J6dBbg31LoaYLdgXixcToosgo",
    "2dzcH2CH9TjnvQgEndrZvz426qijPF5GBYUPywhmdi78",
    "2eDuwHkXgoBAMyLGYEwwnvPwPxxAcJBNyhCL4GgWzNpb",
    "2fCpm6HZ1H5sANyXCmjr3uG1bAv2ej8iLDQQyuF5yJuN",
    "2fWymXK3SuG4Vga8Z7ixAmhuvdu1HoXmqc5PaJVgGxL1",
    "2fX4RKJFad81fkLzaZgmf7ANTYYtwydRBuACY9HL9ca6",
    "2foaZ8tZ1chYuvwM3eKzkWYX2E5ym9rkCBvTs3ZvtDFN",
    "2forbd5eFsDzdKsrobYFWkX1RBSHCZaMp8eVJzDT7CbT",
    "2fpv6M4WgYwPTAsAPi8pkFFgJ9oyaAg7YQ9Dehmg5N3S",
    "2fsi1GVFkutAKSBeo1yS7wt1fBqKXzgRkzwhmL2Mi3G3",
    "2gPMhPRH9zmcsbgQm6rFDcS4X3BfcAwm4jKeJzuj2ATC",
    "2gUAiEYpw3REP8j8e7yUQuz8VUKt3HxkcqQJrKaRZPLZ",
    "2gUg7jDdfNDnQWxaT6kbTrFLLTQYSGK5Mc2Ytup9bk8B",
    "2gsxNxzUJVEV2vzLL2Wbw5iPTcoQFRnHG7G4FLeC473C",
    "2gySo6vecAfXVZCPoJGfpchLwkuE5wYJHabThKqmw2LL",
    "2hGrtovQZHri9o8ezNWWLGtyQUpoDemyAoJfGcwco6Xv",
    "2hTiQDHG6tQ9D1d984phtDAJcC2ci28oXvKCxxuHCvE9",
    "2hULmQ7nCdnf7c4YyYqFLeeSsnrty94T1zw1Nmp9sn1G",
    "2hXPbd1PkPg9LGkGLtgjHErWcpwv3PgkfgLRUhQE4oGH",
    "2iHjHNmbZ3Mgob1WDQs38AYRbs52oEfXnbpyL21g5WCG",
    "2ir1rfeVAKBZBf21iRamUXp7qcXqg38JzxGgcpd3fY3U",
    "2j58Pms1rsfJM4fLZQdDMZYJwayNh5jGxCAEedTUpKpE",
    "2jE7Nr2cc8mkABkyBGXeid7YBqbmDmCpTJHrMUxeZk2R",
    "2jEyqTmUeyaBBDYu5u9a5XmzkX7twGn6SzMuo4yMasDV",
    "2jtgsjibcCi2EV43n6tuVfuFz7wsW8rEHuJZpQF1XDAT",
    "2k3yDydK659VwU9e6r7MJXherHoyNgqzf15vSAYQSsgT",
    "2k61NrQJen1DV2R8pYBK4gSMaBMc1Xf4BYBY58gviS31",
    "2kEe4rgQ4mtGYPhhEcpLWzyeBWrjreBdxoysD9scpxmV",
    "2kGeMx4c3wT6Qwb22To4aZLZyWHAWiMgKvHuQib821dW",
    "2kKgQtzpdtULBNuDjAmNJWHpfH52H1yiXD3kbdRyc8rj",
    "2kePsJzNq6HRp6Mnn9jUGb91L7Ey1Xi58tpSQarMbdih",
    "2kfGP6SwLZ4yEqtCmGavYdUoEjBDff2ajm8HXeWJTPb1",
    "2kg9R3S5QcNTTPFdaNeHUUjrZwMb8FNUa6WRR7ZHtkD1",
    "2kupuUVm1sHx1KSSiTxAuXz3PipnHjQUHvCe6CngNbLM",
    "2kv2cvkv21ZpcCfpeWc3PUZ24WgrvmC7pDvyiEPQEw3w",
    "2m1CWfY4x2r15JMruwr1xzNz32ZkGNbDPvWM6At8FfVP",
    "2m3Gz9HD4FW2pNwdPhQQHn5mRyE52VPcc46qvXj3SxH6",
    "2m3PuPHf55diuAgMqt9ccMExkweQdQFZdQkiG9b75Ed7",
    "2m9D4Vt7RhoJMuGNeqXRJrJa8VnzdR9F8saqdyzaFi6a",
    "2mUR7NqRPGJuY5Vadmkin46uAxScMqxXFBT7HWYFXP5F",
    "2n9GsMeeZ8Evdt2w74bUq7P6wW7KmR9cy6V1QtzSrK6J",
    "2nQz3EsLwkrQMSnDg6PHcCLGYn1idhLmPS9jTMRWkTZ1",
    "2nXSQCEULmGiuqfA9cAw4K6aUmBgajYkA7F2KCGMtuU7",
    "2ntJxjXfzMkpmQQVkdbBNhqfL8Bw2mdLUj3hdL4ssbcn",
    "2oBFK7XviYLqpYmS8Cg4GVnPVRSb9ygC2LBVNRKFKCo7",
    "2oBhCvB2gqD1btPehBr39pqz7UVDGXZtwaqSGSMq6yQ3",
    "2oedvjZrszQBnCrrLKY4JRXTfpQcDf44HG6WrWZbFWPa",
    "2ooqr9FNdb1AnDQnZzYnvUgsL5rrQghDnf8Wgzs9p51F",
    "2oxmzAhgygqo8b3T1ewztxZMiJCowVpUCEjcwf6ZEBFk",
    "2pCyqj7pdQaXTpN2EsJ9ygTcDWPieJ32Fe3rYMVT5EJE",
    "2paGdcUaTtwduuAiYPmon8gTwSbsuJjr8AwsEqcAJJeT",
    "2pkRzgV8jEoFHMg9tMQY48G9nHvBAfUhG8axVu2mX2tq",
    "2pmxKrfYUyLd7aXAQvJSm6Vqo1d3APwr3Fzm5dS8ULh5",
    "2pvT2M84DfE1NanTRffVMTw9VcCRxyhhp7a4jQxzwEJy",
    "2pzrkjnGP8AN2yxDKi4fi4vxWim9xQP4ahx1qwhCKoae",
    "2qKjdm36r4ifx4wMEoBH5MUCAXiCKUszf716sryDE5Hk",
    "2qMpgTWTCeTSFG5ztnGZ92kr46UxUfxDwFrYssDZr5uN",
    "2qS2qM2fpyRmqSGFJuHhbjW9LCf9aQiUyuBZhYvBY6F9",
    "2qSZ38bfX8yYczcszNn9Aby3bUzxZkNfikwZDa5yeCRd",
    "2qWbwboSRG4tVDmV16VgLBbvVT2xVcQL3MPGXm2SfWJ7",
    "2qhSfn1mf1hjf2K84H4vxPBQLNRjQU6rBcTgP7Us1AR3",
    "2qnqS5D2S8ks6HV4S9JSh1rqU24WYtscYCuZmetwYZCt",
    "2qo9TUu2MFAznZhkXLbhi9oqeDVDdNpPmXdkvxPP58FN",
    "2r9AwmUi7PFbnYR47Zdaa3isc7EUTWGSofgbkAtGwKJB",
    "2rAa78pGtjP3uU3yKitDsc3woRaz9LS6jukoV1SDEHYA",
    "2rJLi7tSEThu3xzYWhCiPMFjrMurAJkfnrzSoGPKYjtD",
    "2rSj4CH7XvqK84Htcmi5j4SoiDFRu76Ei1aEATLZaVbY",
    "2rXsWFYUD6ahGSVx7B5Tvuo6NjVz4P1aWkspAoXkDmiY",
    "2rs8ZeNy5DiiVgS6X1AbcXkRPBFZ4M4aAczUwaSSupQs",
    "2rtNasoBZmjDHtCHX6QiPPL72o5tdcFLjssWQL6kdmNW",
    "2rwdLHikjacrt8gfayAc8nwWK9kfR7kLbSyFdo5bMvhw",
    "2ryhvvrJnMk2DWEcCseBeFsZVGKVjUbgkXHJe8HWmH8J",
    "2s1QGW7FzQXnkfeTSiJXX8Eg5pTKEtjjNpPkZDQibKSx",
    "2sCwvkGgQd6LDzHBinwGMmtz4y536zETXZ6N9fB42ZMV",
    "2sGDUqDkSovNtBepGXzpXhDR8t4UdaX53zJEveEWQzsp",
    "2sZic6PniGkrtTiGCqMr5yRta2QQhcHJeb3AMLbV8uKP",
    "2sa2Q9W31PanYkqhzLQ9xuF9aJaZkUoSXvfBJrWNjAN2",
    "2t4babzJY6pA8NoxGFWYjaByMmYLERBtDVkzpm7bSWtJ",
    "2t95ShAGqMFhLPMSukk8ZVrsZbNS2YxhgDokUnHWPsx8",
    "2t9FuSB9cQM9nz8MnG1eUJXgBCaHnofY4jSNcALaLyJd",
    "2tVvK5GkpU67mMW58wHNMNCxRdBSXkmCNBizW53Dgctw",
    "2tdQmFwAViARoy7GW8U6GQisZC6gtwLZzNmb3xN74X7T",
    "2tjtAYCEpxc6WU5GkfAMkGJzJG5rxjbM6Xe7YoEF9gCc",
    "2tzjAoJZLTmXcEDFhwvjUcu9bcq1p9HXQiEeozn26XmL",
    "2uCPwqinz1qnxwfELYCPPiVaADCE2a9h1F5WPzqSj3Ji",
    "2uH8pVdibZj4aermmbaJmgNzHXkWvCFh3o8aEVV6LNhP",
    "2uHqAmP8N5MV3kQcmNCXNdYvjLdmZ5oA5zMdN2kTuv4N",
    "2uPcYV4wH2N41GHbSvsDYjZu71jtMbPPKQVY5jCwk74t",
    "2ucED5vm5Lfqb4oSAjK6EmAnHDph1kCwNjcUL52hSwXu",
    "2udNu2bZdvgQRcd2PVZ5MARX6wBhRgbUfaXxTbuxcuZM",
    "2ukedo7D4PTmkPxX7kRdegy5v9azhenUGNZvrc2CAiET",
    "2v7uqFfj2sfigWDBUGZpWhcR6LYVwUxA4w3apRNytzdj",
    "2v91eLXiw8WCMZnRTQdmzad81r8suspjrkmtve73QTAV",
    "2vN9PwRNdPnk5jEn2FLVtXPF5f2LfrSDUPTamdPVfvMb",
    "2vofF5g58i9Wkm93yPYVhAE4tSZHwEHuR7giRJJXn44D",
    "2vuvEa4Nszq73dtM4fFg9Xb39avUugKnayaqhDJK2Pmq",
    "2vxdduYyn7MCJiErobbsEpmzN3nsHbGMiHrfbJqzZWGH",
    "2vxv3zXkGutPcM5S8qgqUmGhgLFwVxrc8DZuy8aMf3vX",
    "2w37qAtJeZvwKYJWxBfQixtFctXUm5Aa83yR5GvJ7cM6",
    "2w8cgDgwYG1mXA36vws8u98BTXijinaai2hQijWreadZ",
    "2wEaorniEQvBAX6wmTfXwdLG6T9g22ywWyCt5C5UirWm",
    "2wQose612SmZLHJmh5f2xi5uZQx5eH2npoTB3qSim8zK",
    "2wZR446Q895zoAMQrtotqZLj289HjVkW8LgBgLCfVbof",
    "2wdjdCKvvNQcfJgZpxoiGW2qAhx9Hjnjc9sGy9DBoRMb",
    "2wp3Roe7UDNw9DZqf1986CyAXnHHgJhSSoDdStubvsYt",
    "2wpFKpNqEdbJUeYLtxQmLvw2q7XRv2r2hotDHqb9seST",
    "2wpw18atGKNHEYzgU1crazcYJXGbXCtLKmGw5J7L1m4S",
    "2wuAScLCUkZqCV15VhGRJfbqoKtVSuo8hpG89qthf1Qj",
    "2x8psAdhBuKoDEkrC63byErMMQ4RKn7iK3VfoizYLs1a",
    "2xDkSNfRk9mk2sXQKSvBJ8B1UqYbE1kBaGAPqXG8EFAQ",
    "2xMEXo58kqhLDdS2CCc5o6TgxNKTtBLGySRLTakq8fec",
    "2xNxs8iUGuaZtKVwbPv7EhjRizEymXVAsQtLdeUK73n5",
    "2xVkFQRQrNrZL5yz1M5PfHiFveCw6VdEj9cpsTT1uNnj",
    "2xZyg5WvXsrRfya66eMjdjGQ1AAFWHXNsvvm1sfGK97B",
    "2xe99weGkvHFC36dNU6J5UwQvXAk1kSHwDmT8xrtphyR",
    "2y1CXed2Bk39FmgJqv2D93JTsjmv5vB65vZwiX41PUXw",
    "2yHXhf1kvAPbajA1STZe7ykhz3DX7JUedoSiJMEfe92P",
    "2yR5mieKQi2wfHXreQMPWNTRRGnd5o25Rd4HDRnJuKYv",
    "2yXsBQK5CxppeHCnbFRqLqwZkpiPphoXYyJdHchz731A",
    "2yjsfwUYtrDBwu6ZvmWGyEYDfS9mi3qE911Psv9rKDg9",
    "2ymssq6XtxnDGenTYiihK68ARxQ6PDmm6r2pbQ7m1J17",
    "2z5ozNgD2J8zM3Wya5ugZrXYLTn6MZZENwy8xEVgibUk",
    "2z8nwZvaD18HThckhcuE4gCkno56eBq9dnQPJkrS3jVx",
    "2zYcs1VPrNB2doq9wWtmASQouJx8NdLGWSZWz9GNky52",
    "2zgYgXW65WF6Jmeb262TPPEsunRmffkaGnTg2E4AALpC",
    "313ZQgZwW8M74rbAQJiZBetcXAxgJqsj27M38sYcbwSp",
    "31AAXTnwr9qSnD81yFex4wR3kkozqGeN9Vara6KhfXNx",
    "31FR7G3LmAvD7wU6aoF1BBujwQaADYdq7irpbdsGnnoj",
    "31GRLG5vivbXU4nncvpvmJthxH5MQHBr6ebDqM876pgm",
    "31MSrjUbHNHvxETu6JW3FxoMbTK5a96yiwzWrGsNpN8K",
    "31TBvy9cr985rkTSgWgmLWg2BijJee4vcRfR1Y6L2aMQ",
    "31c7mkWtJiFKKh92gXn2fGP5BBDFNbUokV4QEy6ST33r",
    "31qDuM5S1frArM3BfUJQiuSU7NmrLwU2gcpki862bsnQ",
    "31wtrDT5hTQWES9VreS9fM8WMvhTy65Q2gdefxtD9A17",
    "32GZz1TyTAWqCByFEGV2osby9PQcG6AH6H9DV8WdyQvH",
    "32YTx6gvqbz5CeExUmDugRKLVjU7gcRVnhsxMzoEfmsk",
    "32Yd7KGMK7DmBX4xD2cscNEVq8CZR3mzHE2Wft3Bb4BX",
    "32gi1kYspPHQuSbbdQ12XexxFE96pzmPNvHmcr7LmjVx",
    "32okvhS2HjeZVg9VQAFV7KbmGJ66zZFZRBPMVydUVUig",
    "32soh3n1yxYQEJwkVzHwnGWtsQiCCS9KY5RxUET33CzP",
    "32uen1NfT5WBSXCVt6pTNXMdMZ1JvdcpCFhHiJNjaF4k",
    "334CMAtwjpbG5ytiVeECHgzpmiH3fW8YPdoPeiqKGfNq",
    "337otEreQqGWbZketZpnhgH2SajSz9PCaSTep2oaiAB6",
    "33NnUTt97pkXDVqfxyxHWVfiEUEFK11Biu5wC4y4e4QV",
    "33QhxK3fFKcgmryhY7CGj5exvyQStdnb1a4aNu39Ms8D",
    "33U3gbdNsmKkX16ugjtKor3XUjPkujkqBCzZ3NrKD6D9",
    "33i7q43qMojoYiw5TcEpr5CKZQA2GkeKieaYzx7rh8om",
    "33uoxGvDpgdjaFucvygUY8pgX3qcT7NKCQtMexnzAGx9",
    "33zRJtyTZ4ZUqqPmYhSTjSVaFdLsNBdpr5s6bmAYpBLU",
    "348gWSWFfmPBuQDFo4RiR22anKx5xnUpxoRjXZ6fqB4Y",
    "34EYrzWHAezTW3cCtAgirvMyQgrzZDnCMFW9qp88EcvE",
    "34RfKprBnUkXZEi4XsDeUXZZG7MwTBTn9aWXyjjT96NV",
    "34YRb7CEKZS9BWnKUXB2cNhxj7WYSvemDv8Vg7cNAvQ7",
    "34kTdYZcrEEgwyCNgzwy99W4Gjn9jxERT3Q82cbXt2Kt",
    "34sGRELkkm5YExLEcgCLM98Xg1Nr8t2GHLwhBRcQyPMq",
    "34sP4okBSwWmiptyh2mKJQDUg9kUunCAf3TzT2UkgUd9",
    "35pxjAqgUeJCaqaJqQRvC47MXi2ubUbWzDWLtBZq862S",
    "35rbaZnGuCTLrxoBU9nZr7q5XkQxP7QXyfA1HVY4g7ST",
    "35vczgjz2BsnWHKtkgaSbERGzcybPJQ9snm8RCmfrg6F",
    "36CA5eN7pT99Mnq9sC1hzum6LKQHaT1nEVKkqmG1A6wL",
    "36ELMPE82jSFyYg3hPZFoHPDJ1cJmajpYai3m4ojtSJa",
    "36EQfT23pSoL7yrZMMEMMQySSSgkDBfMa6CxSXN2oVJt",
    "36P8iyNx2JV15vgSeXj1khe77KxdkXi14VR9AHvozw6m",
    "36P8mi6Gmys1T6j35WRsq3sgJggirT5nHU1M5emWLJS8",
    "36fB2KXGwL1pcxsUqkMiMZEk9gEzUPcVcG9PffxoJbr5",
    "36jxzZqDftGkJQrLkKzkHSEUAfDt6c4ZDDbEYDd5rzRs",
    "36vhSDpYtm6CUKCGsN9KtdFGxhw9P56v6xxVECWGSyLg",
    "36wuCgbDko4GTSe3cBQ6AFRBJi993ShVNjap87vHusFn",
    "36yr8A6ks7TT6VapvWdE4qxePsGffYzx5vrBoDnBQ4xj",
    "36zNzo28nv6Y5ytYd27duE8zMYDLYk1gzQP4mrjV61fK",
    "374LRwVTziVhgjefrxSXVBCpCreB7CeBXUJKYfAftiWS",
    "37ATSjE3bznmZv4xipXHni81eBRMP3yodJtDJVFdYyPD",
    "37Kg6KWxx18RDi2KHhas9J2DHSwqgrVMyDbuAciSz9K4",
    "37LCBk3x68ws9ZGQvDkX22bno4Y6ivsRfE64UkSrrJWv",
    "37RA9VpGH71cVJt1XJovZxpqRvWJskEKFkoxvL37eJbn",
    "37TV8p9i1y7VAPfzZjmrZLmnj7FEsinhuzn9QDDU4GAY",
    "37Xz8zwWBuxhpFvQNwxkUvJWUv9BekhTjXxHHrkvMy8k",
    "37ZyRuNujgFfSz2QkpinNwrTsLE5egUTqCA4JKZcPx32",
    "37adGtw3zE7hT8uXz69tz3E7Cb1BTHvLBxicUWKpE7d1",
    "37dL3gDnGiheGR9ttZsgHBZQUpswiGVhsnXFLXX8ds4N",
    "37vCmjucci5ZbRvapRLG9MbXm71QcbmS27y8Kv6HF3QT",
    "381GEiMmRJvpUD9DftrLt34Nhx5KBjKQP967vDGPkvGP",
    "38Bcqrt5i7zaNDG6DTzpvETJfL32WgLEEPKzw74bTxpS",
    "38YfNSf1u98Wo62WXCDuoiqSGqYDAHhyZFf2MSBkcYPa",
    "38ps6Pz2iGT53bsDQDwsbJm4Ri8DeVJMjiDgc2E3piK9",
    "38uRAQqbiGJJcNPtpu1u9D4iqHthZ9n4FEBMiSNWKJDW",
    "3997NiCrByvm7msi9N9qP9GankNbXwDJKAGiWWHQhLP1",
    "39FWfCWQkaukQiiMj511xrDmksK7ohQAxD3aiPct8SQX",
    "39Msptoc7QY2ZXto7reCHABQSjsEvx7cAGPXhfyKi6xR",
    "39WiMwEoQuyoewCTD1x83Fv5XZBEnUHA5o5PGG6MCUcw",
    "39WqomWw7dfzLRfaMoLsf4JtTbjQYvTmqoDZrmzqcAti",
    "39Xg9DteZRaHDLH5cqXFyC8B6Uviqoh1Wu83Fm1P1zq4",
    "3A9wmhqif7RprR8w5PVy3ozShQy378GoCVSqQ3ccJgx8",
    "3AJ9UDp2UWSN3zfuLi8Af3FejaZf4qPghD4KF9mkCzW2",
    "3AQM6aHQnsG1dq1Ys24fYC61HbZrjrmXCisiadfeENFr",
    "3AhVYdsaPAwqPDVHjUw7mV2j8X5WT2FwnW3Myai19VqR",
    "3AwAumDf2HDY8uCuJdtku7WrJ6tgrco1FXNywv3qrgqC",
    "3AzM1aZRUJvYLUkxGpYiov635JszzhsD3seHbptrLspQ",
    "3B3kvwNMDpmy2ATgZSU2KQHDzrpY8i1b24UVWcmNJqvt",
    "3BDxmiYaw2d4Uv86vwvK9W9HVZTCgyv6x5xJyXC1hWex",
    "3BWj7QaC2xw8zRNUVm6ZJb2EoWwzGTbAufoszczgZS9q",
    "3C1uhoeGht62caaS2MNo3UMWUyw4eA76sUsuWsjNRav2",
    "3C2MiMnXWToZe5x5f8VT839RtPKtTDAuMQELdmNzxw6r",
    "3CYL2YGdZP6chSJrGJbS2NpsjTQieMvNnRXq3kFPm9eF",
    "3Cepqp7vfWwak9BY9DjwmbT4r9ErtRodkESVihjEz1Ay",
    "3D7FmzRPiefoMCKaMAoajgTiyqBJo3hReRYYXEdmVUsp",
    "3D9MtCwxiBhHZRjMKzdwynHAGS15hhM8pCrnRDhB9AuV",
    "3DGXxLztDA6gBPNtMjCokcGv2qF9bwQKjeAEVr24sgPk",
    "3DSuiwipjkpGiH3AGgQjAb82V1hooKof6293CkgxN19h",
    "3DY6nZP1HZ3jauktzQTkdFmu7Z6YA6siwL2NamxdeSu2",
    "3Dkui6Len3Jkt7rMTfKhuQJ5YZvbsvKHc631RS74CHn2",
    "3E2XevYdaRCt3k8Bg5GZvCfmHjug461qAe94FVVNtxuL",
    "3E8ibsjCEiMsVcMBjxhjt3d9r6UUAc5gTCotJ8HkwxXx",
    "3EqH4YYDFy2Mc4uKxKin6VQw8pDojUUxfVT7xFqcbhpo",
    "3EtJQFoaHGpBw7V4S7mWV6xVKQJYweEFPURReAheSAEx",
    "3EtbVXmcZgq66BsroY1K4U73CYXxarfQkHCPCKxfhtNn",
    "3F2zjxX9Fnm4RWR2zwhJVNjafk9nSBeuat2R4uoEuUyh",
    "3F4NjCTRPdJxd6mQzS25GsLpQHNebNfPChQMMyZVPSPP",
    "3F9M9rZbvJpJEHWjVCnyXXGUgcKdSJuMmq5knJiiSYBS",
    "3FGip916Y8WebnuYkjjULF8dbiuzRhf9P5CPUSqjbVuc",
    "3FSfwbjZWN9E4S25uU1f6SHBDm8Fe3MQv7Pie8x2cj1J",
    "3FZTiskSfyLqgWhyWkmVbXybBtnSVExRxbw5rU56Vzaj",
    "3FcNnBCpXpEPVeTRpq2kVskz4TYmX2RWSCDSSgxJHxen",
    "3FjYqTSCwn4rZ2rKuy3EvMCtVzhmbqZ3hc1B8HvRhktq",
    "3GDQuTdMiwqQjHaBrfvu7AFsTuAMWAcMh7M8aWd63DbL",
    "3GXSTuAJ2D7W9uYc4TgPeYt3p2KwAUDh5W7kbUPgKXwt",
    "3Gmr4mgDkjPHZZnBKZgRM9yeeoXjrFFBcPBbeKhjRmCz",
    "3H5v2tvv7rcmQELhCRDBFwR23AUBnAjcjZXgjGrEC4ic",
    "3HAzxbmo5HNLH6xtfZWeeayFAVUAZJXtwxwpoyYTxekn",
    "3HF57EjmXaPkd1jSRn6xraK9HYPxXqNfyZsPzfQsagV1",
    "3HJ3pC8d7XrduKWffYtP78xtXsp2i8mGcPAaSnNDb9S5",
    "3HMEus75yPzeKrHHgNJhYg9UC8TANN5uKvABPTRZRhSh",
    "3HSm5rrQqQGo7XsDEEZ3RZe4Mx4K2wLwQbt3f3PWAatX",
    "3HXebBiHWxzqqf47EKhUqV3kE3jEUcawwqRWduYQjrYf",
    "3HoQwgevF5mYKXFdNdg4tFEGxufNBFwrEHSFMTLTMfac",
    "3HoxzpFHHGrjJkGx3u2R6Np6N1ehRNg7z4brjEEb7adT",
    "3HzqsjY7GHckLfqdCaxVXTKk63TRDtpiJRHwxkFfjYo1",
    "3J3sSRzBLVREMi2eCJV1DGR8TQk95c3H3mnVyo57jurn",
    "3JDZNT3bHe1wZaTWHVGU16dRQUoYDdckj6fwMkKM8pS9",
    "3JEBUhiRSgPqB1qUkmWbtDmrTzh8pMgsxZJ5TFcEDNjB",
    "3JRBaaUwB32RTBQruCnAbaDueZN4dazo5fCvhc8rZ4g3",
    "3JRV2CEczGhuxm1XQ9oqPsLBzZnmFHoqsryYkDVoDmaJ",
    "3JYdrPw9mfcYUP5bobFQ7fHns47i8dqgwv47pfPaNZn5",
    "3JtSEPZiagDJiXV1Q8pTqzpguPGiaUjpXwD3njDxCqHj",
    "3KPFkpbtWBntEwxCU4kvMTEVgreCEdYSbVHHkeXkj1RZ",
    "3KV8A6483ZsEnajFqeJGDZQMdXHKDUdxJBWsTukwRRo9",
    "3KbJ7ZmJsnPVAgfLMzmgo9XPEPagfUTtYp9iPADWBLFu",
    "3Kds25cpedN4UoLE84KDC95DMC9kbqw4yLx5i2KtbU7i",
    "3KgvNcLHs95BwHetEfov5FkZxuQ3eNQEwvCupdyURoBD",
    "3KsRUqFRtAyrXbm9yGWQV5dJE27YLwGzYuEtWnf6RF3F",
    "3KtzdnCxTXq1GwMGE199FjSJAHGnYw7L4ZXX3zrJ9FCN",
    "3KuUThEMX6DLc4L36zZkpPZcuzyUX6xzeuxAGJD3bkro",
    "3LSBzk78e2YaZtwrmUFoooKqRFPJDhe3gi4bxjf2XiGP",
    "3LadZZ3zBqZtAQFiJBwecYkM2NiDo1bbDPK5cdt97Y7w",
    "3LcZ64qJtYygvhCNCTuENDAvuKQDU1g4zdgN6LNhKdSh",
    "3Ln2oCsb1jMagwB1AZHpvu3m3qp761AbpRqsHRxuRL6M",
    "3Lna22QXipkN9phfuPuuRa2ef8cdkeA98SYWWbX5zPSK",
    "3LurxN8xzV9rBkUCVkQb1se6eS5i27BV4RSX9VZcfo1y",
    "3LvAfAiPyNBKbmn9BrQsb1K3BJ1JBFxSmMQVm7rgKgoo",
    "3M6spBoMJnKXSske5WFLHWYLzNRB4JSzWznVf8RKdEqg",
    "3M7WitGSW4m757JrwwAnrUfhzNKfdRRpyHnnQVXXQtWr",
    "3MEUuV1w5Leg5ch7BWpycLUWrpraiM74T11Ru4SHsc3r",
    "3MnkENwMBekWZvMTaXVnjhUYsGgWpuqj6YNeZsBFNhro",
    "3N9eJoWP21HRjPTgW8SfZezF573FBDjjmBiCKnUfW3Ec",
    "3NBAAKyvQ2UmZdCDySto1B4YDTipsZseTjRep2aBrQdw",
    "3NUSBzYRWtez3Zh35b4WPTiQtYHiJry8m2CyiiYbcpAE",
    "3NYHJBZbxozPNWQKCZEta8jFzB7fea5tg1QVQTqYNc7J",
    "3PKnxXaC24RgwEVWgufBXPytLRBmBkmXZGeHYpBRnFeN",
    "3PPjeBR1z5anezhrznyGfC4CG9czhVms4CnymNB5JA3R",
    "3PTrGEoGb2mKhu7ueJ44To6ddqWsqR1nvbXpqSRtLVEM",
    "3PbWinostCqNxb8HupQLK1NaZVT3ovHcgnWXVniNUGto",
    "3PgP9zvZEmzdBTQccYwmYHxBUBX1pTWX9jTFWXkuGkAZ",
    "3Q4KCiHLq9sENJTGVGp5SiwR8imUUirK7ksZrNhuKqQ9",
    "3QCfM5hxrZUjTWX8bfp28BtZtwZS7XCacwxBSito4fCZ",
    "3QH6Kyt9zf9fz6wjsqQSy7Vx1fbK4294VS6WPPGRS4Yt",
    "3QSagQHwbmDJEMp2uWAGm9xYhVKhj8dwev11jNvKbssY",
    "3Qo8seE1PHfwMvMiK6hW9iWVR7QsWC4XmnwZEc4Wf2Vv",
    "3QpN4oQJ3ysRufdU5oo4YNSPykNA2rynJ4L2RdbEizez",
    "3RPhZd1jzMJwog5Z1Job8btsQa5pEiW4nmugRewcGmW9",
    "3ReTdJJ6q8n2JBpgwXotiVqCbeZv6Zbfx3SZgCaNmMD9",
    "3RpY63AfaGvtEYWZQ8cLA9woSvFhiRaAPanoHvQcf6v2",
    "3RwUbbymoFBcHnGVQJ18XrrQECJPZCpKi7kBwjaQxaaf",
    "3S2MvKsF33cDKt9KimAdrmzQr94HmnMbUeLUAncRXt6R",
    "3SabKnFWDsDX5E47zBEJxXM1g6MMHJucBCdnrabRDYCS",
    "3ShtkLhqpt1UuHc7fvjYpZSyS99E92hwT7ACvD93iVHC",
    "3SpJnYheRuaFDFNubvcoq7qJjmkuvbQEu8ufsGScdaB4",
    "3SvJajiGtU9849qW66QPyzAcs76L4HC5FJ7YezpboMib",
    "3SvKs6JMN1hAgtb7ZnAosNEgqVByUeKHJHx8otvGgCmd",
    "3SzKe1deJhNxjmH3sAMSNdh9DV4sKeiCCh75dLf854e7",
    "3TJF21dTvQLj9EPPZhGHXSiEaxFjUthSAN1ebwPL35Ad",
    "3TPTJY5YyohyFErRzYrbCuXvcqTWgFCKTDt3L9ebwCfc",
    "3TgA3RWgq4bcPzWC8UTmL6MSjZr65Rz2Rmhvc57Yye9k",
    "3ToDHDipeK9qFH26qeED6VNrqXojbtFnGD5c5QH4PGUB",
    "3U2g21565xskAzKdFCF7q4zrB1GJvhhMKZALPSTAYZFy",
    "3U4AxyrzAkDEUzNccMx6xtFDmdkYFHLhH83ofdzeGe6s",
    "3U7ro374HJNtjkYds8339UDpFJeMLg7KRWZTFe6g5qGo",
    "3UfNinYHBjWPZYBTokzgn6S3w7LtUpNnYjmzsz92arZs",
    "3UrhsDprQvLZtN43JvFywd6Hto4gjspeQgXuDnM6AqJt",
    "3VxyvZgRyB7k1m3eXbCbPtawF2rTNbenEdFzRBxAyuKm",
    "3WhRVd7x6muouwH9aA8SVjyHccX6bR1buwXNPVDerPm9",
    "3Wi9hKF3MTgqyKpBDV55nGf9x6m2k1k9G975y8f8J3vh",
    "3Wx513sKYDBSos37DX81uea77bo4o2mMPZucnZKuj5wi",
    "3X1LqhWYhttNHXuzV9RqT1c5P6kBzSSJiDTAVugGT7DA",
    "3X2zbxkoL5hzNy7Erk6ZSWnkZLXis9xky9mTXeEGof9Z",
    "3XE64Y71epyej75TVSSNUwoGMxnwkhNbKQq9QbeFTHuf",
    "3XEStmxrTcGoxr4SyyB6smqKvJAJvsCBYkiqYoJdcEAx",
    "3XTQhxBbQHcDVS8H7Rb1X6E51eegZ4g2AiUy1jJMkY4M",
    "3Xe7m9uQXk9ar4XKUVogaPYUHLgNqXsc6SvF5K7UX1dR",
    "3XqVp3XvcDVBSoD5UsNJjCP62uWqf7ctJKfhLvnRMGr6",
    "3Xrk8AnLtyDfQH4p5hzueCXHE94zPKd2WmCqR6tL4uwT",
    "3XtptsvRAXcuvSFCcZAvhHYK1tELN9XdUKq7wzQ8Emqo",
    "3XvUu3uQoQDf6nZaBYvHb3JSeRc3RQZs5WMGKEb3hxwG",
    "3YDdPwga6bRFpNwH3gfx8sdzNw6vT6265wssefTKfsrZ",
    "3Yb2MGw4boyj2uSQUUWTovADNGLWfhT6xPwoDpyEFWu8",
    "3YbvHZz4R5NTzkDhHfDFRaxKaMFkBAUiK94N1x2pA4Yp",
    "3YqLjmnEnE9fDmJyxy7mrZSL2TJnxEHETVaB4Q9JNAjQ",
    "3YyH7PZnznZV6hbqorvzcdSfHqUbXxe8jpCP9P46jXv7",
    "3YzAW8fxvsmN1MvwNjYF6uthrpFn6SnHTRrwmjtjoSo3",
    "3Z9Zuweh5BQfxyrSj3gFKXauksVPa5pzq9oNnTVQtjgW",
    "3ZHJ1Q3ByBtmRkXyGqS3cTpQBEHPF9AGe11UMjSR9s9r",
    "3ZJBLzRLGHEjtaeUgwnB4cJj2LNK58wdnUrFnz4bSMcE",
    "3ZJcn2TpgWjGSYT5iiBCsiaU38Ei3quLpC1SaN7QiC8j",
    "3ZLe1mg1VbtThgvJtFD5BRPvDVSgqZSG6KEutwucv3jr",
    "3ZQtDUywyigAWtinPnseLJauadz7R1q28TqKGTKY6dkL",
    "3ZUjXdF66eTqq7WCJbZ5oirSMPFuTZ1LRQc9UiNfRGF1",
    "3ZX7P84ihBSym8Ez3RZCJjwY1nNx49tHufX6rSykeAEj",
    "3ZhJYc4avrdF43fykiUzKTZb1BF3UjY7EaVNB5br3Wxt",
    "3ZvmKuCDHwzK1rMiU4Hzcx94wcbvvhb6GBqTM2m8T6SH",
    "3aHDLmy3AXGTsDuypV2X2TovFwgosmoehxxYX71a3iJB",
    "3aJ3HxqyHydcyoWTRBwuhUPks2qSmYS8ADhwthUaKNoh",
    "3aYSxERwjRodNsY6HzsTngrmzp4ZZLjjpWC1bLAR1RVV",
    "3bDXaL5NsZ9A31hkwv6souFd1eiAKeHzc8ghdFeRwKQK",
    "3bSXJVZMFFZnFvAegF3m873TdZypz4mibzHhax1oeW6B",
    "3ba2Z1K39gmreYYGigaofKGPRBpy7RFo5SbZTQJnok2o",
    "3bsfWvk6XLWhE3xNeY2KjXLeyqFWJWGb5DUdJ1TGPsGc",
    "3bxiBits6mgbJuE46AoBYRWKw7PrDLetnCQSiKD7iQqz",
    "3cEwVr7cmXQwggYw5Uy4wuXeqiUGPRPGUiWoNW2GhYgE",
    "3cJpFMhByc1GLRMk1SZRGNBhEYuXQyVJYJT6ABr1gGjT",
    "3cPesSLwipYR37tKGnumjsyvTaQU3KpbRaJWX5bmMzqx",
    "3cRQ4imp6fqCrpEK5fwYc5hxxXTtEZHxcRfJ1VKAhwxd",
    "3cmB8hdf4hNBehZSqdoMapgnMiLKWJyp5hJUNWeeLh4C",
    "3d7LsEFd4HSyYMDzTa4L4K2UkktV4bwjfHLmCDmbcFbo",
    "3dAc3ywQdmmQFfJNfiEpySGbAjW5EeSXrFQNQmFBL4cY",
    "3dCZ7MzZC21xjXiJQ2pRED3snGiF4XfTM1D3q1gsA6sR",
    "3dGhwzQHPQrFbogLphGPHLZGv7rp1mbbaYz9FQ5HkZ3G",
    "3dNWiWkFdacTgJTEApvp8VdFsnMGPgSP7Wr24vqWQesp",
    "3dZNEyvJ5S7KwF2fzLzzY59aQySA9bZ91HNQhzrVus6Y",
    "3dkkcHXUbV641zfiQ1LYxNHoBDoV5qd7zKjfkhhWuyyS",
    "3dmf7h6tJNZgvFutCd78dnzviRpVc8zSBYt2cFGAKxjE",
    "3e1CHwdNP9SoHhnUcdzcLdbzn1SDLhqkgFvwVNk4xb47",
    "3e8iLrExmGsMtn72J5rvBzyp49LY7274PZYeeJPybQ9u",
    "3eRsuJDw4y4yysQXTL4fRVA8tGSDGxZ1G7VUNVxZW9PG",
    "3ejFqgTzKJT6hfXKD92Tf4wzw5zh8D91Q1QGKJTVPD9x",
    "3emDNbeUrLxxJsckbeGVAMHyyjeuAEpCrQBiGAafxg1Q",
    "3eotszs9gFKBRGJUhwX5F3J79CC9qj2yDqkwvPPqpibK",
    "3f7qzJ57ovtNQspv6qN19zU6BBRJYZPFd9e1D7Xjq6Xv",
    "3fAaJeiAzXaeJsSPJTbAkswcbCaakjC82m6q57UNugwK",
    "3fZFk8vgEhSuvJfYeEQSnTyYWqoYGqRcvgTLmGv7dHBi",
    "3fhNVK1UoQssPKL3wbWjKMtEK9y9xACnJCeGzbB54Wss",
    "3fiqkqAcyAR59Dqsey5saQBYw1kDii5A6Bvigk3LxMZr",
    "3fmHbs2MH6myfcZ6oHoYoKdGvwzcFWYUd6bvURYCm66z",
    "3fvB7Dj8MH94ofrJnGUNKFDkD7R7hYdvcaokTspnZ2ru",
    "3g7aR8Sk4bfNYJGaY3yxmHqp5NenVNCX8BEQLWSTh8qJ",
    "3gBHFdJJrg7FhZwhjsJ7U6hjKyGFWEdVBKuc659p7zXB",
    "3gDrBgr5mzd2PyYu7NsRXNRtzgbViUEGimtoX7iuu5LZ",
    "3gFtdbEJ8maCdhXxH7ZdZgWMmUVH5BFkhhchhxkeUyW3",
    "3gPZic5z5VGu8VY5jPjKe7VrQ7sgDjDS9ZD3dXzVfNRc",
    "3gwrBFNFZucDecqiBicneMea9MBTniBtkLui23r6A4nm",
    "3gygTxbVBKv5YpXyepxZZ8TTK7pAu6MMw97EP1zJ37Vy",
    "3h2rhNSXeQ8tMsxkcPc9ryEXVRVGqZN34tmbKf8zLSNu",
    "3hEC6sTJbJBJrM184koeNa8shokUtuphbNkR9ExLMfHz",
    "3hFHjZpvCNUoyqCYx2oKyUdHMFzUdWgYknxDUX93zzzE",
    "3hP2g5oUKLZsupgCUSUYAfYwk7VuSoviXScA6MDEtoz9",
    "3hVTamqc9CQSSkghTY7JbT9ZZTKUZxsuiwkm3vA2Sjbc",
    "3iBhnc8bZY9PJKnZmvxKBryD8HW7EBgNJ71JDp1udC7q",
    "3iTJshdThJAG7oGc7c8cJkPPxX7DLqrSxRgqNzj29FRp",
    "3igEQrEDLz4ZvLk6KMnJZ9aHxU1ugfn4vg18Ffy91RVV",
    "3j58SXDxq4HdPpJFkn9n9LCHaWwGBBd6ovC1invTsrfC",
    "3jEnw9h5TrULEF9jTQUkdSmZ6zHQSnc5zjtvUpGEiC1Y",
    "3jV9ULEpNFdQ9X8xHDAyuc3eKi9x7u4pd323BgCyh3Zv",
    "3jdW2UHKHdQDXx5NmfNGirT7GzYmFt5RMvE9UjS9idNy",
    "3jg2ZHRCdnBQVVBvXvkBmzS6Z3T1kxHz17YvcQ7dQFQ8",
    "3k1Pq2hz8bC1qMz25vGApFpuQryRsuwbDf5WFr6t9z6B",
    "3k2SRp8fcigGcFi48Nsae1ns6kgtAQ3QVgEvurZRkbUf",
    "3kRe851kYyab3JRWKo1dkUYzvYeaJeKWKug3L6Aa1FuK",
    "3kTajqqTXEkd9zuttq19vnNx34SR4DLhuQQXhWgx5gaY",
    "3kcfmkJifYo9HSVS1MGaDvs8kW3997ENmZUzGdatGStF",
    "3kxAXPuk6AExEBcyitAFs3AhrzP4H1zeN4ZcsBNBZyB4",
    "3kxF8odr1J9WfW7UsEaP7AMCy6wiyv8iPaL8hD7s99zS",
    "3m1KbxQLNgXqPLw3EKzii673tPtrffu3zQqixmpXKut1",
    "3m1dHR1TrpsAWofpYYbzdQNRzJSME5zPmqEFLqiQbCUk",
    "3mHrZBPtnyuAgJ2nyJFP2UpR4Np55dp4W6AqNkCKZESN",
    "3md2kVtWDUXewXLsMvP66hJHCC7Yii1JfrzsPyi1KX22",
    "3metnK5yCzFrTQydLU3RmSAxRLTz28DtatTGjFU3VYP9",
    "3n36iwAR2BBeViqTmrWDpYp95i4eebD5kq2ym4Xc9wAu",
    "3n9CEMJ95mLq4TU7gWkqbAvcbmrDR9aWYJrxW8x66zs7",
    "3nN7svkcVcUjonUB3VGyFxZLYsTt4JuNu15uuBQeATmv",
    "3ndq71hpT1Hvd74uVF1JAawDwz8M3nxJpa2T73YfJLSB",
    "3oK6aBdeuiN7WSLTMsMRvCKWBfNB8gWPL7WDtLUgV9na",
    "3oTM36FvvfXXSKehd2AuGv5bpL2SKpjGWQAaXv473xSp",
    "3oZbTNkiPrnANphkE5VLNFLN2NxQqthggEyDVxvpLLk9",
    "3onu48JN2TkJWYUgQaZVqAWKK12WN68KSgu4Hsibw56Q",
    "3pCFUTBJJ4dATF99Kfw7FQRtK1oUTQRUpubsPzNFpJgq",
    "3q3An1iGgQLRhWMGWjyBbR31LaYJNXAipvbMYsh5iD4s",
    "3q5vNuqPJY4RTHp3PwPobV133Xrz7ksvJZ7NHasMTR48",
    "3qg6s7qEBTNBCgYaXtVRsTa5FtBdvMw9yMow4AVBnkeJ",
    "3qocCjRBqPTJPnu6icYxNp4zeSwEEjooYT22PDFAwCMK",
    "3qqgPHqn7AcdLdYVLoFpBWS8vgAuek4xEaqL9c6SwrKx",
    "3r4XqLxxm6F2KneP48PYEi5zVgxFEEvUuFhrxLu1adEb",
    "3r9gt9bR8XWQLVHkEhoWi8QhG26QVEeNQ5UbrvAJjJ27",
    "3rAiSxKim8UXySqGiXDH33nAfd7xYFMeoXm69tNJdxUp",
    "3rCoQ1LRwvNQJH1b1MowLdzdafVTKWp32U7WHYqmAdx9",
    "3rHivuHjNA4MLedMiwr6PGF5jA4sSFKRLRqPVAwdkKqZ",
    "3rP4BrRp1CAXFfrPLzfX9wHdYno3dVwvNHwBAnbcW5f6",
    "3rWVovaG9GQFcVAQ15we2mK1S9VmaQnU5EoNCmmGawRN",
    "3ryhkBvB1H9Jsk9VBDQGAKm4E7vQ7j61quuLVYQteVYN",
    "3sU7o5fpppM1ZL3K4Lohh1kHL5cNHSfsY3dbCudtGLkx",
    "3sVxz9WXp8gP23WaftXGEd1U667TwzyY1yeyYGEw6bWv",
    "3sY9EtTRtkNXsavGpGPCkMwnLStPk3UCXFCvZPAkjLjZ",
    "3skVYLDGVWP8a6k45nxmpkq5ZKDtUqZP4UY1wkKazJaT",
    "3smMdGwX48yBQ2mavJcjXvAPL1aX6JzLcBuYaii4aTCx",
    "3ssVE18TgJzyAiKaLaS9ZsTaBaQFUkY2WXUwZNjbNcPD",
    "3swpk3HV2duxc7oYP6h4tNwifocYKeWivUQyVT6N1fYZ",
    "3tCqPtx4bWsGKVZ29rkabzHNUgBfrC8C3V3SQmG2UKi8",
    "3tGNZAgkmZ5qB7KFtS8HAswT5tQM5kfDSkqK8s7Uujg5",
    "3tYqjx1hRxoAjSFt9bWenPA8d145Wr4e6586DtmSgGUZ",
    "3tgv18UaXksBAs1a1qmWZ7qyV22cPfrhfKCjwXDyRS4B",
    "3tixsQcqmZFAAriz3PP8fVfro4ARhvK6ajfaPrcBbztM",
    "3tthg2kiwVtpAKwi7HP9syEiDGL3whqxzDgUqXQZqQrx",
    "3ttqMEMidMBeN1TLuWmEziLAct6kxKYXcejmYxgK68sT",
    "3uANPrywiRu8SZHu6E4x2JhPEZcoauEMLHoVySKoYaGY",
    "3uK8Tfcm9DcjEmMpu5oHdiDdB1CrocDvEUMaNWwWGaF4",
    "3uQYjJa5ZDDoz6RXVaVmNKnVb6uPodVgNvBhQ3Bx9QCx",
    "3uad1cgVum7kvB4ksewdE7R9QStm2diCo9Htargr2afd",
    "3umRnKg1XP1uNVAnv14GpX8CfLpDovJSTj2f7XcGBzJz",
    "3utrynQNRq4SywEJiQsGUD4DAvMt1gHaXjZcn4MaiVNG",
    "3uzzX1pyfAS87zmJi7BCHhAgsxj1y5W2ZVLumpyAefa4",
    "3v69NNsjMjADUjmqTEoMwn19L5AHaRmCnrcy91GEw51q",
    "3vDrcGiXvJJg9UPkeJH7dod7svgYH4JweovPt61ebPnd",
    "3vVnwxWY7qD55pG22LBSk7t2g5YJyMpT4DjAyGizc1aV",
    "3vdM742Vx13v2AVoF4yKeNt5kZoYA5wpvAZJTVadbEsL",
    "3veva2sg7dMZ79veftCucaPjY7cfqfPt1BJSux8a8Z3M",
    "3vjQsEttJWrQX2srqgXasqjJQSFhzhVTe7XfbnrVJ1LE",
    "3w8iCbFqgk8Z88dBxJhrTGXFmcnjrhoDzHwCU2tDGj6y",
    "3wA2JKYyRP5JYGLbUaFUi6FtCFzUb83t3apKN161LAJx",
    "3wHJvSnnupfycNJTnu6xTNPFXhBoDVvZ7FF2CALqKDwB",
    "3wdQX7m2AQgmmjMNNhGkbAPTKybggkSQ8GReSCFaHhja",
    "3wgma3MiF19Vf6tUiSwQ74jB289U6tE8n8jfAYT8NE9g",
    "3wonSGqHS2kNHWn6bFkpnsQ3BUn6grCgHJtWegmTQT1o",
    "3wtRV65amQgqEGNw8ja2dubgqrtsDCCvhcjTqL8k7uWg",
    "3wx8o1MXXtWk83qsDdaoYupDVQKigLe63NGx3xFQuQau",
    "3xSWezPDMTKb8WZEVpZdedHYDE3wKxwdDzH4ARNkWpZY",
    "3xgt8xWNs5LMKkdLG8Ae2UmWNdEecTvLTpvWLMJKRtT8",
    "3xiPa4epzFadodEM6nGaLNRZbHWURgPPhvRbp328qZKi",
    "3xmozT679tgdz9pXYA2TfFdQgnHchbPUGCCt9JYvNGq7",
    "3xoZRYzxGP1VCrNHs1exHfzEmGsRny4PoT2sG293BJVz",
    "3y7sb5t6SPUssjgcYbNLz7cnQojtWoQ8xkz8NoeKc9zg",
    "3yAwUguhFwjd7LidW5A3hqQJSjkgYecNkVcVuLck9NJ6",
    "3yB8Wii5UACs16pAMFN3r8whsNHgMFzxXAawWF1rgZ59",
    "3yTMzFRzujgeWcWiDLfUfrg7fvWKhVWEZXDUvuVmN2dQ",
    "3ybE5wF5PTybefhWCtdvgKHR9446V3AyMjj1XWhkujPS",
    "3ydgg8chNY2pXMAqufPZt9XswSonhZY93ECNg6pff9bi",
    "3yseRSTcHAcPiKM8ATqPFqcJL5pBg97fyA4xafa9i28y",
    "3z3UR8qVWcP4uxaadGPza2Q4Akt6ycaSckyPkJjKoHoE",
    "3zCg8JLXE7chiCzbrKxJJCt2VcA9ySfgJiX7T4PAeubD",
    "3zLx7Chn1MsnYf7EGpiiJkuhp6M9Tp3YAD53Tyyy6FqD",
    "3zaFujUb9grmS6uRKjV9z6qBpTYQikdwSQZgz4xLjw3P",
    "3zcMwiRY3C24sniF7ptnTvyzCnrouuV2Si96RznL6DPd",
    "412HmigscNBzk3qqgdFHjE3DcsqGy3FaGKbjVoLFgDiF",
    "41hzDQXJ5xsphVMQXQ6FatnQjZcK8LHLXW5jtxCqwteJ",
    "4245ehVZfDKHZ2ekrCniU66xdYFYm97xvD7VBnhxkbQm",
    "42CT79vt9AbFzka4D9AQtUmakVn65shP7hXMz2VNBBLc",
    "42DTxa2cEcn3h8grhExER39dJYQuYUDrLBRcSXtAMMMX",
    "42FACzj2MbchiUxfzhsjAyhRXkYrBjvSiqaopGXpJUsJ",
    "42FiHMgJjLXb74rX2keK22uWWrjAdiYZJZdgWpiqsTUz",
    "42RRaBRVoawxwWdkhwFKcURJScvHFpeMjNQYKsHzNmhj",
    "42Rt8HYEyG5WDvmFkvhnUX8tWaDvVbS8E8pZBUZFLsBN",
    "42j5rVgJpyhgJXsFGDdsgzM6wq5P3QKTYdsip22C5t4T",
    "42r7MNeYHM3UaUWfzqjLb5QVEoCbVhw58g3dAgHmhrum",
    "42wBkbnqkATyKsTR48GopNNXXNnefiJ9rYpgdGRXp1UY",
    "42xKhYnUxnYUzocHmabAioQY2yD94Zs55y4UVAg8K6mf",
    "42zBSyzJiZfEDcWeahUBQP8N9qgZWyaMs3D9Q3KXH686",
    "43D5u1CiMzpF5U5Y7am6iHx55WS8mrJnCH4jXXc6GhrB",
    "43ym9B2fBZB4cmaDp6VteTUf1tZ7pZQKJt65eiLo3MPM",
    "44G189PWzn6HxEXgA4aG5gt7oeGh19R66GzDBnrHuAY1",
    "44SbWsX6rNNsCmKCatHkxnBYHDKnrQ9JqpKbasiGacso",
    "44rpZ7wLzXKaPb4xESxDjnnzMY9zdws33GL1CdEUXdCR",
    "454uvm7q9RcATRZugz151myK72JoB6juXxwTvU7KUyLx",
    "45E6NbxibEWTd3wStbQxo93wXGTwYiMUMQ7V8FLsb4PD",
    "45aQ4zQrsBUCHcM8x33JCccQb4H8wMQGkx2ZZX4D2mgd",
    "45iq6cBAL4VcttMSJtAYLj8ArauNCgqvcACBj6JAyiyh",
    "45oESKeNwFF4z3yu6eJN1QWn6TG8xAX4F9EXAn7ocDG8",
    "45ovEVruKWppc7KqrAzHZdVDx3ZPx7H9CUEoE9KgLCy7",
    "45rDLZVcSE5AJ7kerEtcuXK3qd2Buk3diVpfisKG9gwn",
    "4635uMHCyrd3LwrCXdi6g4J79iiFQPedzEYhCL421SwS",
    "466Gsn745HkJKQo3oVJJnaCipG3A1uwWVgh6rJbzsUAQ",
    "46CVhbAEfr4acEgQ8RY75i9UJGV5Dto4KGGbDXPR82ER",
    "46KmoWZmyrzuYEZz5vLwDD22QSbo3DbiUoHKw5hEU1te",
    "46i95x6zvm2QzadvmXqzcNRDg427axWuYjEnSmeTrGXf",
    "46oxUV9VUdG3e7iktiXCm8pKvw5ZH4oEW2nMG1ExMHs1",
    "46rvytSkbAe4kbEZUfuEhfVLrhHH1LwMizhoN5RTHbJa",
    "46tu4mimofahUihffadnaQt2T43EAjQMsu9njUXMSzVy",
    "474EMXx6NCgakm3xnnA49GkA24fmX45NeomGu8iWWgNk",
    "47H8nTbxCdfvHCDjYNBKeLT6dsSUQ6U4xiYmo1uDwBQB",
    "47KBh7ZYsPdbCJo3XjRMxQVnwzX4W6JMCkfp6ks1GqNE",
    "47LjjL4kQTnx5onJ5EuyJ8QjtY56cBTm1ETNPbqhuSpy",
    "47uYZVTxuwhf1VFWd9zzcKJ3dkesfHPhEWjH2mTKXF1d",
    "485HLc5o2SfNUiEgKZwA8pwX6uzd5aGhnnKKuQz5fPK3",
    "489jsVLpq1HXbjzx1PU1gaVjXEXACgAEEDDoqnw1Lwvv",
    "48CEQjMaPN7qv9mi8W6WK1nSwkcU4DeoorY7MJpkKsg8",
    "48K7ep1nDdZeNB5U1DwN8qf8BY1ZNzsWHndjwGH4Q8m6",
    "48KwA5dXYnjFpkZFLZy3ACxhVzRTqo3GfVXY32rwdjT8",
    "48Pu1VoGrznDp5wAmaLDuAGcWehdq8nh67ymwGpfiq3R",
    "48UtKMqL71Kca6ekCMKyNLhvQVFJZLuz5v8DhwFkJfy2",
    "48x6SkEF1y9R6crYCSZFsafQUUD4yenzRBBo1MtjWVgM",
    "49Xo37vaseDQvVLkmrF754U2GqRToYjaHbL7e1UfiPTv",
    "4A8VsxzReef7ofWSVRvFvj9YUhhKd6KrAwkmBUYH9u23",
    "4ADYw9knELhS6MPu4VPQEiEeSveyRmjnYAmvFnGcqBQx",
    "4AME4YjWz5WDB1dm29VWH8KvJhnUQRpdG1cBJgrABhiV",
    "4ASgEepNzjFtppdujb4wN4p1qZ3pohgkykgkMUC7h5GF",
    "4ApfNFGK2HWVY2Nfev8M5Maycbm1xQ745oTr37DjmFT3",
    "4BSZPss34AVfWpbdxQZdNeRuU4sAin2fPGjgrtQPVFez",
    "4BSr52YPSL1hJdkvqugeCWTuKoiXuWJ5daBoQaQTeTCh",
    "4BfqQCbk7imgZb4ZRWiyBKubUAcJkapkK3jGSBoCMMh2",
    "4BxH2KD7hMdDpYpFCHZjYbiQpFH2rey38ALQ4gpCXmyW",
    "4CFmdXQfiwksUT4a8VYwdUkfomzYXLqpxJTaPx6V13Tw",
    "4CHbRmiZC8GjDQ1nVTJKv8RySuwoYVZDSNvHaRCay5uf",
    "4CQthoJq8LV5PxG2JxjYCby9Z4nsbi3aWicYPAkwJa7N",
    "4CswSn3ME57ioDQkEC5TqJUEe5Lx15fyBJeUMVNwJ3Qy",
    "4D2jndx8eiaVtjWt4QPgkwXMBkCq5nTDG1wt8CVnFuHx",
    "4DK9hzWQvLMi9uw8vF6qUCX4VN139H2YnkpZp37vtu8o",
    "4DNUtsGH4FDVvDTxNA45JJ3bmdq75ZnKNd7ESfLCZuFG",
    "4DT77pmRxWuHV1w72fNpGxMZby2VoJb1euvcq7LaJkPt",
    "4DXyLJW75YkyWXD7BMaee2SGPjzXtdkotaKrnDvSdioD",
    "4Dm2KuhmyUADr2MuD6yTUNi57PXhrVD6VJ7Ah3zMCUSh",
    "4DsLCxdzV3JV6Lqqfsmen3DcPReRUfWTA6E75MGC1Vj7",
    "4ESDNPxjypj2yoSEJFGAis1LbX5XyDbQ58ZuWZxPVTjD",
    "4ESenPNb4KNxZx2gDb2yG9pULf8sR8hdmHtMVxJohKHH",
    "4EXQ8gCMh75R7gHhDWYdsrGEkph3RZT7QsSMEvj5oqj7",
    "4Ei9d349wNY5gYW7X9Krt5KJN8Np3ALJtiYE9ZgGGXeg",
    "4Ek6vhpJYYeycaCEcvahtvpavQ9WA2WwSRDAf4g2vdh6",
    "4EteUy2PLrxHrRDaewzjxn3bdXoZduUMFQBCVFYyxTp3",
    "4Ez9DKmRjxihq57hfRF2WBjWYxHVcxsyGPmdHtHf5uWg",
    "4F1LbMgxUT2xr9nTPKbgGdf1MsQUxRRX6ZDhMcGGosd4",
    "4F3YfKT3peNk65vhFyb6jDDEtp3QJg4gCXNBzQACR26T",
    "4F4BrJtcxd7QGDFUGxPwMKyrHgNDSWU7nBbrL2iLyHp4",
    "4FAF6s82tfHecCosKDZaCPNcZgZSPqVLaCxyJomrpq6D",
    "4FoDedeiqr2ixCymYfJhkZLikxFDeeTkdbAHatuBSNU3",
    "4FrQtVcTX3cbRXU1xp8NGKEcA6ihfBqiubGwgNmw8Bdo",
    "4FrkQ24VK81utZn9NNEkFVGA6o65Tecx7weT41cUNFtL",
    "4FsPRo1Nx3Jv8u3c1GovKeG6yb7YxkMXTKEauYk1578s",
    "4G8YEKzAaWHK8xmhb3KqiJX3JhB79Pua5HGihTNrhmgs",
    "4G9u5N6FQDfL87cfL7MejfosBajnwTjyUMu2Pmg1vs21",
    "4GLVkPzsCR5ApodGteCNTGhEXBoSsFDDZMKWdAkvnyuu",
    "4GQtxGF65DoEB49TbYHqZwRnY3MKT8Mq3DRNPg7Qo7c4",
    "4GfhHRBWccVb42mv6b7S1bUCqbuUmR25LjLQQxKoyzpU",
    "4GhDyF2GEfeP7q5xqdpzbHqpJVV45oUkJgkSvHsuNoAN",
    "4GjWSBCQAk5mp1zxBGUKVWr34D7frDfbX1H35cirF5YV",
    "4HzxeiaqDFN4aEHaTP3d6eJXmY37pLHjGALRcuHu3VEJ",
    "4JHMjiwrYN7jYkCS3okG3oTHbFvUTrqXct1UTMrLBTnA",
    "4JNF7Xgiv4iedHzpH6Tt7J95yZc1E64UyjkoGEbqa1Tk",
    "4JWp91gNX5e7cE6h58PWBrCoyH9BWnw2xcVYTk2hCH3o",
    "4JXTDvqGAPWuuVmCk9YhG8QV5X4sSn3szUAQ4mVyDRCR",
    "4JcTYyZDhmdhSSrFAQdxmM1fS8UMbYNHji3m4wU7uDo7",
    "4JfxCqnQjL43Jx6qsSpuNTxMFkePTAwPk7y3qE4MGZhm",
    "4Jqzw9zqM9Kv3soetSFfq8RgHEdpzJH1kjrSPt3yTPeg",
    "4JuaSguQSse4pvWnMzySGVmNg9NqwE4FVsWwEK3ZyYq1",
    "4KBEEhjsdtqxAdmb54iFWvcDhjcYmiRp7aKkR762Vmpw",
    "4KEEFYxiinbgrev667Bqqyn2mXX4tZjfvGTcwcjqqkPF",
    "4KFBPNAjRm8XcCUNQ5XQSzucC2Heo63xyddUGFoAohYG",
    "4KQ1iS6cWvQMkSL6G8WxRwDVmbh8TXwruD1p1tMMQDuC",
    "4KS6yr6wRpxoN5t14Gw6hBCBHtbbPa5zoMyW7Li4rk5a",
    "4Kqf9k6uzHJGjGbf6VHvNj5Dgq71vCRCXnxDQ8ohcCu1",
    "4KreLvAtP1JyjQrnrdgxzY8MZaYSK4TMZoK4SMMWpoKm",
    "4L6hWPeo5BL2S1cMcrBQ18rhddyTZ6VmNHSbysywLy3M",
    "4LQ3EKDZdB5iFmVusHEua4U6TsKrne868ivdXJFsmzdb",
    "4LWCpWwtjsaNuV3hBX1Rzy3W6Q42wUoYxD2AYGDBNJyH",
    "4LWNva4nDaDCEp4yTcbRNkqHoUQ8EPsEwiKCpZ96e6iG",
    "4LkQMtYf45XLtVEuDBWsZfphL2s4SxAqBfpoYMDSD1a5",
    "4Lod14XQgoixwfaGsfUWXdDe5go4UChsFA9rYXtamTce",
    "4M6zffNM3k1R3tXDqoU3J6swcRgTxnqDuX5uk7tk5fYs",
    "4MHAUnJzxahtpSwwn47mfSctTq8fbS7w7udjJdLQH6FC",
    "4MKKiaeDd1Yq8qwoaSYq61u3W5spiLevunyt9AN68FVN",
    "4MQLVDkkgWhif7spzST2i1VWULf4RBVs5eMLmmWpSUWC",
    "4MRff7nv3dafQMSHwNPL4GUyAiFrrPr9LRYwHggjdptp",
    "4Mg11asuENrXkC3eMEUoAbDaf1CaXWeFXjXCsTBHJjtm",
    "4MgSFLhdbqoqDW5HYj4ftz5dP3riFPQsCWKMAnFmm1jQ",
    "4MkNJyqVhuBxuJUoUarxEdfs7N8dtvMq3vfGKPo5USf5",
    "4MoYKfkg58tQboemf6PBQqrcY2y8EBvqJZqBaqrvBr8W",
    "4MxsMCsPhjvTTTcXQeAg79GscB81g9Tg5MQCfq7shcEX",
    "4N9WFFmtRw4dK3Q44k2TFGfuL5f7SjMgo1pjhW4mGBVW",
    "4NGRTvrtQLRY7pPnyKQeFDAR9q863xhvSRXT2PcPiDL2",
    "4NMMVnKi7ZvcFkUBTCTq3osY5c4c1FWBi8BwqcNnRst5",
    "4NmTyK7VNCEnzFYShcmdXE2caMmcijVxibvrUBRokii9",
    "4NuNKetiWZa6VAyMxLAeTTYr3J5Mk2SVVuiW58ScSrCe",
    "4NzHNRxYLa2eYjKS7ATz4Q5iRZLnHGoAaBsfL8MAroa5",
    "4P7cyiZJCi9qHZUkbSboZQpHnRhUBLXPkQVWQDyJX1W3",
    "4PKQmA16SdxikGqxtuwDCCLD8BHKdhFX43bvF7EzBf26",
    "4PQQdzoXEowyNoKdBEcYo3TrASepieXcNGXrfB5d4fhF",
    "4PWNC6u9k5YhGeDKv5HXAYNKKcnLNz26Th7xGknixLMH",
    "4Pb5qYEjk9xXApMTAywdpbpMNGP17NgVnkKhKu4fPYjQ",
    "4PccUwdnzEiaNpfNXrH4ppdAAEsFxSPybpUropia8rVd",
    "4PpZsYQBqb6hVc9BcX3tw1D1DKE8Nu22khaYgi2rJE3x",
    "4Q8L6pDD2yZ5Z28si17r571pm6jq2W6A69aw5gs6CPKe",
    "4QJyLmkD7cb8ZQQBAtqvySLNA8wy4NArt8dLwAvd9qrC",
    "4QKdPPcsphxaidRggd3RWD4huYMp9oc37gZ8XApRzUpe",
    "4QTWBBbySmNog31T5skD7CN2SrVoYvU8yUDVNkcEBzcx",
    "4QzHB3rbYNGSai2WnxzkUJfxjysbk7ZTBeRWoDAcqN2R",
    "4RJNugUdS8Cg2P6FYiMV5eADq4JqX1skn3TC3sSmTEqu",
    "4RaJXqb1SsBVQTa8HBK6s3YfKE4tN2ZAr7r3ZgccCSzM",
    "4Rh7gAmk56Xp4NJBLxHYLwcQhbXFNNmyvLbvnd53Sfys",
    "4Rmo4crDrmHxLXBo1KB2NTpckabNAQD3iK21joNicy9r",
    "4RpfmU5XdyFz1U4RptnqUtXU8VJVvyW2LGYmwMwCo6WU",
    "4RvMWGW91219tjw8i1Fvo9vihkUJY4WhwPEstdmHZePp",
    "4SEa8zXnRwo1iwCzGUvxiS9MC964MKN1wvnbeV7KogZo",
    "4SFa9UBKTDcrq7QWkdUmpqmeXrwD8cGHsZGBgk3pgHFk",
    "4SR1z1DJ5rXDXfvWJWxWpUoH9YSKyQQZbKfrZ9LhNFHH",
    "4SS8wMgwTfF6CVdpUjZFXymC34zpjhRbi9xrEE14qUZC",
    "4SUi2LJxTCZuEUPJaV4ryxr4FAVJxwbBh2CFQpEhDSqs",
    "4SiVcdfTN98oC8sbxHyaodTkRwEf3J4Y5j7WZ52CYdA5",
    "4TNRhKjNibaCVL1Pe5yZeAe596fhyQ63AQkSS9A9dnKk",
    "4TNdsM3Pn8eBJQsGwaHqWZgdQZiqBWtxzR6W8yYgVj74",
    "4TeDQXN6eavqX88GRJEabAay9D1kenocFZUbUstCzUvt",
    "4TsvSZ6vRvPFDGC7xYuxpYiZ83DP8SPxEbD2JiJXH878",
    "4TuJFi8Sh2Rq8APqVGy3GjtK6LCekg1rd9if1ZDW7woG",
    "4TzxSMALYk3Exh26YFxJA2hQX6VUyKkoWZtoh5ChYhX4",
    "4U2ndMhXhmVMNhNMrP1PRbsMM87GLZVwBYNXFQm1MTdZ",
    "4U5QzT4ZsQEFGBsbqVbY3areq9juoFnn9xbAaDkvgQQW",
    "4UBkFF5o1WZVVG92kpstknuSJjGMyohQkusQ3siNvFB6",
    "4UnhNBXfzv34k9QFYmYuHpv1vVL3VN86JW9CPGkKWEcX",
    "4UoGfHka3JLMyfuL5QtCrho2tsaYinf2r3ssnEPcQSkH",
    "4UttcrzPudHJjo7pTpaRHhLfYm1H6YRrwnK2pqGn5rJS",
    "4Uy3rUpdHA56Y8vE7pV8qui4vETQumhhZNAnknCYND7Z",
    "4Uy7KdKNrmQv1urUaZwSnpgxD9sQrgsFvHy5aQiPwpoM",
    "4VJo9yU79r9GZ3gpLfHHKqxK3K6A4BPDiBF39HMF7SzM",
    "4VQC5nDbkMdarv31AB6cxq3bz64u3FbL4wBdKubvtbF4",
    "4VQidcMmQMYwFZHJE9q6uSxQugQNTSQLzEWwsLfdotrc",
    "4VW9ZcJvQUY7GoWSZYBFrbvboZ2VUqxpKHYWqEmXwX81",
    "4VX2Gp2PzHNKwKD5L3HutMNhJiMzaY2AH9ChCjXvWsPb",
    "4Va7pwA31Rg8EaC43Bt2Pnr6tYnumYJLoPQjVkdCUJ8h",
    "4VeLdeU3oTdH9un21eFrZ9HDTTRbMj878BiPfnbaTJUu",
    "4VviXMTfRp2v5MKq88i69oBNdJmuepqnswcmpDTZ3Crh",
    "4Vzcpq4xg5yyAg4N3MxdMcx2vTKL9M3TyvNEpkeHeZbz",
    "4WB2Tv8N75bydveC5t8H7f1GrrN7x7Fz7ZvgjZA41xtj",
    "4WDv14cf38LmnF8Xa6fuCWRJuk89HHmEJZLzhQwboLyk",
    "4WNnhQ1rpFd1TmebwF2633bRparSXwRTykbiQJaPQLwh",
    "4WZebvYKBBortBHgNX7SNv68gXND3jsouYRKGYWxHg7T",
    "4WezwAKJR9wTcM81Fj8vqwJxQMhm2ASQguoJsAHKghoH",
    "4Wqf9HQVLyzYHbJY4QhbUeNEhPnQYSECAtJt3oeVutuN",
    "4WrG8AJBnSgHXsA3KfbFx9qsSB13eyyFY3HZSZno2r6p",
    "4WsgTqFLN7rAkv3Qbok3bmEmk8V6pq7TdPFUAQcyaNy8",
    "4Wu6qFYMqivGUNrE9smXHB8JcXceTMvaPBGQ9gCuufkm",
    "4WuDiZvZGwB49kPeT7TDgZf353MsiDRtjGXC6thkLuMV",
    "4X29v2ZEJstAx4AHGKAgMYZehmWrJhqorbUMRBf4ovS3",
    "4XBoH9DWeF47iN8tSQCmaoPYLeVpkFT7BYCAF6yvS2bd",
    "4XFABWwzGknU19NhyxaDcEARFKE7DUoTpNGiD3QqEjd4",
    "4XGzupCNwYAhCxrjNfPaLFr3fJt7MtHpVpihMgABdDYJ",
    "4XucLj22XFNj9AbQn3dg6xG1Q8WXTVTBdkhwNQn5YW5g",
    "4Xv2DuFzyHYviQbFq4Zn85oZBGHFd4Bg1Sjh8ZZZHA1q",
    "4Y1jpCYhksyYKBwuDatwDLRwMz6hUzZqkeG7SSUwbMGK",
    "4Y2fbkuuGkB5ny4cjiQ4mTxPzNtLR1QCLf79KPWVZ4xp",
    "4Y3Ai4NhZE2afA8KJXSLhtDG9XbHPxSMUndXJXKkrLeG",
    "4YCNLUMq6g3rais5pnrKczNXDHz4SAJgJCKkD4cw2pfw",
    "4YDaMy1Auo2RkW2nGv4dhqdm1c65VZHadLekNv8c79sr",
    "4YDyb5p2byj1cVoHrBoJBmhd2JqcdhvkRdtaamKFJGga",
    "4YFgMfT2Sw6FAeym973q9Enc9bY7sFNqk1kmh34zYf1Z",
    "4YPxWk8JaUsYFtv3dBEE1qUapqx2rbmbt1NGZqw4ELA3",
    "4YTHW5aLNCByAdTyShXnp9zay9CVh9fDVGaWAkbSVTit",
    "4YbhDApTtwJResDbCHeh5Xqq5URJLgnGcPqfhQ5AYg69",
    "4Yep1L9xNVxK9fdQeM9xoWxar45rugm6LhRbySjctgd9",
    "4ZDSkY2Ncz4BkDD3X5fyFAYDtLYgKQPEa1qZ6vsNAZFW",
    "4ZNQ8xy8Yv73P7qmvnYcZxabMb44LPxbuyxe34MQ243R",
    "4ZNgKJbwdJ8MNjd3z3v5JgeEWAQjnQuRqH6w53R7uJ51",
    "4ZRkNQ1ozoB2HFFzw9sPpHVAjC3YDceqzuXFrvdtsvWP",
    "4ZVo4tn8A2U1kiNJxNSUyjASqr9h4FE8ed5BheP3mPD1",
    "4ZWvJXDT1BpE3EMQGPFp18Ce1eMN6G5RKVE8Ck4FBEdh",
    "4ZdGG7U563YyUZEdg8QbwhpXtPvrumC9WVzqc8aqW5WQ",
    "4ZqasNsApAWQNQnwwTLxd6TuTytfgCPDpZEdGs7FvhNf",
    "4Zxk6SJnxR1sXeRTPWkMjxkQrW6puCF54XKHceeDfFCG",
    "4aQpaCXJKuCjnmGa14EMbn3N7mJnqLHpzutTe8ChAAdD",
    "4aRnXQzwm4ddCuqy9pni9V81c1qUMmnN5UivJ7ysTb5h",
    "4aSD7aVt1S9igQwyCj4hRvFJd9sJujQqnCQ2XksjHGav",
    "4aXAYjTfCje7Ly3tWVp4iK5fybp6PGhkXe43GrRbF4bk",
    "4b3xe9xVpaQnvrxi72Zc3bqVBSBw1LxZ66FMV9B5fjEL",
    "4b4Ltq3s2TsJNVG1WAT4yiRURxxqg6RNZRZHG9evY3A8",
    "4b4NDB5pHC9ATsvyRG2i2xQGqN38dpAQPM7w8Jd2cBk8",
    "4b5JVzpGsYs11YqQrtHCwews3UuqP998YZjqmLmSgUBQ",
    "4bNZmJY2RUidfUbuo6NJmrTijKr8taRzUKhNgCKunXEX",
    "4bXsjudgyNvFYqZBwqnY8c1CxggkLNEeiUR9z9hi49XJ",
    "4bftgUXDVvENPfa8ZU8xU71PMKyA9kwLfLv1uzJcsYZF",
    "4bqbJ2igscD2YkXGJqePRpSgMdNmwFvvYxZbhzhCC7Qt",
    "4bwvmGjStceJx6ZWSkrxaACL4ebVNMTzYEgs7dVjzFCb",
    "4c49eaVdxh3w7uAZbmPCdK9BeHrxeWi5YxzQcoWnkHV3",
    "4c9VTUvZ5wPVhV3PdqTPtM8bstGXFMYpVCBYxkBmKVoo",
    "4cArau5sHtS6nGtYTYD7nvBKm8wRucRDVFcRoxAEThYz",
    "4cGr19mTcznnDTYMpBinzKiCaxxHZ45SrYuWgzPuXVq4",
    "4cj1r2LAa4GdjFnziS5QWEVD3AsuVhNRxdLW3M7CXqfk",
    "4cjz5Qe4ukmyrfivCtF3cHZeWH5SG6b5Wd86pWiQevA8",
    "4ctfhaNyZE24ojThnBpZ76MTaXRCWyYDZFtWv5pXcciX",
    "4d6Pqv8PbY9AVg5WB2yvUHJfY2mWvrAh5obYovU33m9k",
    "4d7ANrY4ucYn9NwML99QQeC3G8neSkrLbgpWH6EiRdRa",
    "4dEWPMxxTC5QF4JdWQ4Uwfo8VdyQyV1Lif4RXTUoXpa3",
    "4dGyxEkHQ3dWVLXbRDqCNyzQ6BUE7mVuSRz5gsHkCR3U",
    "4dN2mxkKpdW5Zvni9w5RmT48VCfTSFr9QmNSngek9wdV",
    "4dc8qaAECPZUN7q6F9E6qo3BWQdM2orz1FDDuwyfgCCN",
    "4doMTWuCFeQHrm713qNjdoRGeoyb213dffbdoHmKVDFW",
    "4e7bWAKVz3d7hGEYD2HBifx2tKjCKa1y6MvCzg1djkCm",
    "4eDrAv9BH3JT9nDDV1LSGpWraqsJejzf83JfXCxWNr7r",
    "4ecPEXE6QvXWUe7t4VhekEuVTnGjmyLQyQp8kKwi3Qax",
    "4egsc5VRqNSYyPNQy2CDjoaqu5P7UsWV5cWjkFM3xjZN",
    "4ehLASu1GXgMox8wBEkeBBX8XVJAxCjujzYntWfugcwq",
    "4ehmn5VuaFxRv7CKcscCaX3Xivy2qYy8igjjY741jxBn",
    "4esYsVnZXhu6yWXRZYZXzxVmdQbxxSkH3cmJSssCUBgq",
    "4f5N1waJ5bqL5dm97kmkmZ1KQHEZ3Fm2L5wkDs9xikXW",
    "4fJWhC1maT45QCjXrLfbLWDdCQEh7oV2g1TAg2HUcMAf",
    "4fQpMRraUZPJ98VNcdsVqpazGVLbCjjWTEhyWBPMyhie",
    "4fbDfpNru1y62Dgp2w8rbtqhGAnuMqZxMmEGZS2XUzTv",
    "4fhfGGUAMk6QZJv7ubB6j7SHJrT1pohNXzUDzbekWcrz",
    "4fp48jhyEoUvnFwXxinWuBpWPSfeocjYhQByeneWWAwu",
    "4g4K8NvjDS8LaWDzbznfzJuoPn8TRk97XQyApG94JGiT",
    "4gNQ2gj177mu5TZcudi2sZY4sVmBQNhm7FtULkuw97J7",
    "4hBFVS9uDp8U71bfoTrmm1CHDndGk9VHYzahkGbtBBBc",
    "4hSWGrWhXCetyLS34ZGLXPWpmCYUMJzhc7eRjijobPtM",
    "4hVhEKEazTp443Crmmm7BNRJg2sgRm1GVEmmzcpuiw1J",
    "4hxRbJavkKkkaQ6srrzPE9QdXyWM1Wzp78z6sRPixNz2",
    "4i11JjU6iRLumeDN98BexeuhHUMYfuKtzsH8QVt7PXY3",
    "4i2hbCgvZvt9X6xkTkX2NusG9iKBHsh2Cq87nBAEVvuk",
    "4i5m2tBB87JA5xsVowsavRpee8DNyvEaxbqzBrpqB8TH",
    "4i66usk34f2D4yvW2XGojQZv1jTna3DRhb6rqKm4de6d",
    "4iBth6Kcnfb5yvPtoZ47CQjn8wUKzJyBzDxnXeSrEZe7",
    "4iKuuGG5wZowWJNzip9CeS4UgatYqe446Wi1SAUeviSw",
    "4iLSagZpFCHSi6rXcArbwahXJfAiURiNAuqXKgvALHJh",
    "4iNKeaySzTTKxwUWeRFNp685kGeQauaTdqjHv38g2TQ9",
    "4iZoCs5pynR2u4tu44S9w8mTgvn5Koe7JDeUpx92jR7W",
    "4igA56SSKafwnRgmntkdmmLjCsTFfQHiQ9HR5crvNEvH",
    "4iksYvBHhygDz7BLcGu9SQEhUU13uCPAdXTLEVckMneU",
    "4it9JQ6QqWAMCByFkub9yo3g2WgX29mZUndrB3i4oMXf",
    "4iuC2y3i6432dXzurhkLzrSbv7wgq9iyixQEWjjxAiUX",
    "4iusHUhcJPaYgNFy9gyhCTLHvLKPPoybxDJgMFHueAL4",
    "4ixCoJsJgfRoXyjKz2z2cxLZgg1VFHZmHhYfVjGcdEHj",
    "4j1FRMuSYFaa85jCbB4SUYXD81ThAohfu6US6zrykCtk",
    "4j52JTd2QbLNab8PDH1USDXZYsLFchGYX1kJMGZag3jg",
    "4j6msrS7jD5jRd9rWo3sMQu56VGVGRVMpTRFmWL8cbYE",
    "4jDFqdsi7P8AQF6jgVKF5hmbJQfUC135QUCu5n7Umk2E",
    "4jLc3tnwEEZPJw1r34rYSKmUhQdEuY1nYV9iXtEib7WB",
    "4jRWDqyezGBE8TgtXnETJFKPRaHyvmP2Hi7gsbS6ehia",
    "4jh3L3TN7S1AoHQ6dtGkXoAiK1TK5smej417GrmfAsiu",
    "4jhEbv8kpC3hHREmR7fRKFdM8fRkoBhiqMoyZVmTYjN5",
    "4jjYJYJaXMizVTvYrmJHt4g2WLm77YqeHA5f2kLsAF9N",
    "4jm7BwJHnySFwgAKWUnFtianZmJiS8qJFdpMPyGEMLBy",
    "4ju4kVjLdscENhYyDfZhKjU4RPYe4HQSXGVrwSKvD6Rg",
    "4kNc8wgPDafBW1NwVWhkw6j4ax4kQK2JG3JvdWGyxqkG",
    "4kWKP78KedRg35q3xwZ2YePNDBMsgqkhHwAMBMGBdd9G",
    "4kmX7YzkGZBydJ2w2HJ9VGCNmCDHR1PtKL15QmBFJdtt",
    "4ku1qqqUhsSFFwiWbUiLCYi44WMDnLUHKsjq9ugMDVpp",
    "4kyADEyrhSJ5F3bA3ottzXroTWKpkdUo2WPB58c61EVk",
    "4m2EPHPbGRCDtPHYvVbpasWEoBUT7pQQENWZFh6Mb6Xa",
    "4msvcC9bRFk2CyyAEfxnaWZqECkw2Lv66VMD1YucpMh1",
    "4mwhzo2zVYMbMVcfKS5AhUrQGccMV4yb1QqNycXqmZdp",
    "4n3zoTfCnBRcZHyVH2mywTJZW1L8y5nmzb7gkPjhuScW",
    "4nNkEX2djSXBD2EE4qAHBckQx5571av6gZdyBv1wcm1L",
    "4ngtfcVZJjz7ppB1AhFnuTemd9i9fdhMrs4LmQiW2Cks",
    "4nrceXekFAPreNXDaW31nKmCeCnz2jWu7qsfkcy1u6bg",
    "4nwoSDKAyPQd17bLq4JUxbE17fKvZQvDMYkxEm3vFmNV",
    "4nyJNj9J2QTJbSeVR7b61BM15qw5tLKGKHiMS3mGAkfB",
    "4o6RRFAYiKok3mSQavyLuYx2HFtHuKUPAjjCbwkq59cD",
    "4oTtKvutdeq3gpd9Vx5AHFNvDu2rA93DSWvXMtoNxhx2",
    "4on99jSvAvijMpCHkKh9xWgSSpsi2aNjPPjvMwXCk8Jk",
    "4owADaGmD8ryXW9KEMxDDgKuhBj2uQXMfJyF8JwGV3fv",
    "4pXodTFPjCGw45wHpyWibXXsHBkVndfsoKDxWfF2w13N",
    "4paPHvqATZfZpZkbcsMCyqRzKG6CGvmNUj1YsNEvUuLz",
    "4pfwi4JC6PNPNLBCXuuZFowNd4itXN9zqCy7k3pu6cK3",
    "4pnMB2FjSYhGgQnHLxFdUgK2qVktdzjSWegXd9n1bQtY",
    "4ponwdTgUvHre8v1rrbADkYyc4HAWTJwxPUGGeLF9a4M",
    "4poq7EShGQschj4AVtTCRrWexYAKTqBYom6N2eres1xK",
    "4qP73pk7Aec4gb36t21phAnJGabKFGdYifgxzfDtLojC",
    "4qfFmekukCxTWWHGC4oZYTjUYYQx7hDcjgz3qefMfRPW",
    "4quEaKzyNMYdrevkB1enaWC85269iqS2AVoexGbVRQ5F",
    "4r16VE3jeYfc79w4USoHAvwAF3Q5cqn6sH2CWnfKxps6",
    "4r6ZRSJKyjenk8pVx6AHefknAdXvWwBuBNWDG2vxYVZ3",
    "4rM7m2p6fxGCGAQVv4uCaabeXepW13PRCGZLfSmo8TN7",
    "4rNPYT2G7AyEEepevZVtK2GnrqdDX2MHT9qT1rYYWG6c",
    "4rPX3V7c44LBNfdt3hLVFCzctuPTMM9cD5FkuswuKWTG",
    "4rYXQMQJKz1Rc6BowRNjBQjjaqEm1ApwLoiKKZWExEt6",
    "4rbHCMHrgSxLjxS3pCKveG95DwmBSCDfdpkSZZSL7EaL",
    "4rfmsavHgUtjG7yhTVkbSER11Sn3nYzrmCxQHfcVosdb",
    "4rjr6Bi5Bqb5A382RfqJQAWWH5bsNxDyJ83pZangS7eF",
    "4roJDMZKX3Jrr5Xx1bkND9uXkg2Vq2zvyAURWkesFCp5",
    "4sMbzYZtvAkF68qr4oNiburXYmAdcdeYaiQrf64ngDgr",
    "4smGjyU686eg8CqgDmmUcAHH3X6BxBFD66yPZZjQWWuS",
    "4sqU8ynCfyVh9GjAYvnQYxzuTpMPk64KuYaoWnXFmcYL",
    "4svPGMVUWriURhAFdgUs6N5cnNy9a2fNpbHzoSgQQATE",
    "4svtWTqz7WWsdEJMqkqKNaVjtMsDfptDcbpSRdeiDZkk",
    "4tBdsTzzvU8GUNd4LNVpVaQaddMQZiZDXuZ4zKKmBdpd",
    "4tDp3e8bM3DbJfnna7keo21mfg7YmpGnSqfrX958g2sq",
    "4tHjrSryj8n3HbEEKhksHG6t6svztvK1oHLo72f4bkJj",
    "4tSMYfHon3sz1EW41iJd1yhyhk2h9qsHaay9y4EmZ7Dm",
    "4tr8z4yzWcXfJr5CsYyBpnCn6C4XySaBtx9j3wPhJqT9",
    "4u5dLRZpFKMb1ioWztpphknKDkk9P8tvrW4wUnkazEZ7",
    "4uGo3UK84CaHdLvQeKdksCAPAQcMHiMMC8yrXYM3Zogt",
    "4ucHefUyL3T4aZmtBUV8WtC8i61MeKATk4wASfCkoYdt",
    "4uyqrmC47EKbnZytyri4k3SRBEfyMbkxpRQSrVgNgUi7",
    "4v4jkGr3H6nkWBuf1gnH1PwZ8NfYoFbL8QB4tTomoC4S",
    "4vB52yA9JT2cU1nrgbbNy3eFDzwgKUvtvUf6CL78wNK",
    "4vFt8wjWgi4Z8pAEwn327A7woBFQdo3rhqVXXF4ZXRiN",
    "4vGNpo5DUoAfvcrD1EGpZp3fWN9hkihKjQCp3orvAskh",
    "4vJRN5Q3qbZpvUxaaXzQBwMFGTFQt7QF1n3e3stQraQV",
    "4vmvmE6Ws47bk25wV4ztYTV2UdBiWaEdRrUBWWd4m5eP",
    "4vwSxmMx7BTEmQ2cYL9GTmSchG6Xca45Puw3dutiYPKP",
    "4vwUJF325NU1k65xk3xo1sdW4yRV1Zf3UibjsK7bG4go",
    "4vxpSmxbQCcxTvyYTTen2YKkDhzm3MX3KvCEGr4n9t4S",
    "4vzbLmMrpFCLKmCWy88foXJaGUQncjmfYNfw5YfvyTAv",
    "4w1viEy39WnNzScumakULvWRKEoaDUSL681XMDppAoin",
    "4w6mEq6VjEceLrqCqxfpnUPEq1Rk8XuzoX3BbvfpfR6r",
    "4wEJHwF7LTz175A1HNbXPDpzAAqEJuWqhhfGeoZkFtN",
    "4wGMAxbmNkReP8MFzWUJ34skbudos1B7S4hAbRHBzZyA",
    "4wcn3yuWRivb5ykcwYFuHXc8caA9cVvsCVDnU4qFjgnJ",
    "4wcnXHz9fyGwGvmmMspSwc2qRSU1NVNpNwrPVDVZ4R4Y",
    "4wqYrHSroBTUb4LaVaitibicqYd7UNxz1x9HZnB1xQp1",
    "4x3UxhghxiPpWbGxLGkH2GqhPFqccav22hKh1URvWzTM",
    "4xWDPRtxgPcUh4pJMMVjaFHj2cucpekjAobjb9LPSCyU",
    "4xWdfn5dFJsc9CHTidLUktbVeUDciXy6sX1Sdn4Hmu7F",
    "4xbwMb97jK2AiXbZ8yFWAVDGZw5shAstySQMxbKZ1jHz",
    "4xnX8pXdpSwdkzNm3VdUXubf5ChqVj7UTM6Jm78XcwnD",
    "4xoPHEofY69eu7VoYag5JVGnrJuC5GkbAFgBSFUoMAf6",
    "4xu6YwRMMeYLUNNRqkjekm6ZT83y9fqReZjvu8u6VEvf",
    "4y1HUhYz3Dx9VSZcYVpFsDfRMUiRTcMANbd5ZUmry4jK",
    "4y6h3SEeM5Kei3HtAnw7Zt1sBmYPJRAZr9K1dtXSUjUc",
    "4y8oWj1LN2jsDzShYTbgPwXdRxqLetZPpmQL6eiuWyVm",
    "4yC3BzF4oASDg8qrpcHFWkUzVcDSBRKAUmb2EJKfiHZ5",
    "4yEg5Ub251YrKd9rNddt6mJZyne45wCekTXNGrCkLV6Z",
    "4yHiAvNSGkTdEnhtWoqdoXLeLekB132W4GhgpZijz476",
    "4yeWxa6ByGvZiEPaCqF8GtWVRpSgAz8XugmPPUNragAJ",
    "4yomJdnXWmEZ6Z5SsRa6zf4t9mtUGnhGjS4nYHQRFjza",
    "4ysju5xV3rDu2bHav7QLgYDxt6Vz777if3XuLyncpcFT",
    "4yxnwxYEjcPhTcdaFEWmYZAZtpWGJUnywrCcizJJH5Zs",
    "4yzRcc95Cz2GPHDpud7fJ3dF9tGXBp18AwxTNYpvQUoZ",
    "4zVviq4n2o3c1d2NanHSiFjyJFzG6jjfXL5YHkUCourV",
    "4zaG4KaHmfDebgz3jak3wm64bbMP23hPiB37PWCvVYNA",
    "4zjLJxAazZ5Lvy2yr8RawBe18RmGRwiYe2Zot6EKLUQy",
    "514cK74bq5djwJYEuA5KKf3HqgUHiB6ngqPqtJvnLMeH",
    "51F798pxHr19rCKib5GKc8UXyj3erZgvy2EhFd5FFfNv",
    "51JPtojGL72XHtLcvYitNUZrhgA2QBS7F7Cnc3LwKYbH",
    "51M48qv4RFMKGkbiXayrWnc4VohBsfY6aC66cTGcpzkY",
    "51VgFJr8yyybnrvWetdGxup1ywBVhGuhN27ZRYijjQv9",
    "51v4A98GBba1idHnjmpVzbrQK5CQSrRkvZF6WcEyuurE",
    "523R1u5p1Rp6AnibNgSQ8qkiukjui2SqW2LhBAA2MqWH",
    "52fxRkLwKf8ziDj56dgw3n3ZHJEuq68bMvRFHSJV3xhk",
    "52qknb69f6DnzmSWL7GM2aY8i8BPRzyaaw4pZwABR1ZX",
    "52uqS14DYEqmVhHuZhvw3PhwXpyd9ARnLPBNqE7YECkA",
    "534Gua6JhwEgmZt72JRKFmWzHzaqVmf7metNt2oWThRG",
    "534dNhe7wH4mxoZDcD4t3XnyrMkHCoNrx4oRgZVQZdMs",
    "536tsJyZmnUEtd41jmkjFVRoD3SCe5aGKWJ9tAd8njRB",
    "53D7gq2VVyuHhn4TWqkY4jmQHA4ZvJMdVW2ru6KyVEQV",
    "53EVwiYaoQzeqqJ5qNeBmprv8Q6ivHqrqoFZW73L1RFn",
    "53JZRttRgLv41M6oCdciAkEkwYTKSv6iYHv1LG7Zf7Gy",
    "53aXqR3A5j3A3Aj7tBqbr5gc6ncDutzkTFSQEUZ6wPV8",
    "53jGiCGHBQDYzCiWvzUqTKxeeRaBEJnGTtSdoguauB1X",
    "5432rH9as1nSiTGnxZsJFAk6WNNxaa6YWFPSbe6Deh6b",
    "543hND2UmGWo8oAtNLbBWKnziQoryyARipm9hhtXLf5T",
    "545pFcLMvGGBPpfsfyZSMpiTYJ7VqEXJVrfnFrK5tgRf",
    "54Gnd9t1S4G7VDpVH9xZDE4Q7ieWDXDLQdu6MZ65deDG",
    "54TMHbCnCzpZ2LxWrUH1iDwzxuabYHbmf6PJVqunnjqV",
    "54tJVCuMKzrmK3f9LAkUmzsY2zT8Rv5EhqJze3MpvKXL",
    "54vhPW726GLM1UxjNNG2QViwqyKiNErymTr6KGCxVkkb",
    "558cA6i3BDUTU3BUosDuhbAzwAGt1egF2m8LSrG1owbH",
    "55JWLnpXsdZSxwyqh6TA5AhEMHBmUQTFStpSPQvS9Lyr",
    "55KjEn9xjq6UH1LcDtntrrXXEZMe1uJEMNNR1myJEozC",
    "55NuPcVPzRbV4zegmeMFuaWMc2NMBPP4D4a8zw7upTdT",
    "55TW7EijBdE1pkzja8H1Js964F6hN3g14eCb3LML1mX2",
    "55kGPfZjPQNiY1mVYPRZSUKwNiV123q4yfjGpbsVDGvr",
    "55kaPNHpYg4kdciWH3ywKovJPYGRELxn4v9pasi5Qe3n",
    "55zSoy1TF5g1mS1ff8kfAUwcXpJRAa1QB25UEF5JruEe",
    "567ugf9VWLRVpt6H4yPZSW5NhyQ26G3cr1Xg1WyRh6Tb",
    "56PLYqgxVVkwp6vRpJ7mTjrc3HymqZDZhAE5pmrbhSjj",
    "56PwuNG72KEPmdK5urrmqHLeLkTdyQa6yjFyYfRDYfas",
    "56TpFCuPHfDkfifK2E6bg36v6WMJxrwk89YT33rpupoS",
    "56UiLUYad2zu5YircG6mckipd1WpBYtrePhyxaWBD9LS",
    "56ZN7VTqZRpreKuUHSnCx4yP5o2GArx7HN6A7CjX4rHX",
    "56f5xWp8mSQtjuK4cCyKKqtFFTHKtY74zDTbkoSYqf75",
    "56kZSkhdS9d1DetHxYiDr2BJnwGVZueLfRjQk25G5w1v",
    "56qGHDEf5J7emJfAy6jHRNxmqDa7jCX9paSMFsUQpcn7",
    "56t8qo3UQVmmKRx2uwhHCQjF63RysUYUoeB794jSNjB6",
    "574mGFjbCrYNmBYYyFBoCfQrXLDT8yZfFAjL1phahFCS",
    "578mBc91uUh3QvNXhXSyypagQgDvz6AxSWT8x5ENxXNz",
    "579qrKuwmxeNZAqYyh4vUJcroYBoKsxr1vy3MXTFmi98",
    "57EmLxVQgzDGbrCvAykjGq3dXfJDUxB1RYf81HQUHYMa",
    "57KJEi4syP9pnWeuuyKC4PofDhS7YkvqBYVctCPVFiqS",
    "57ap8Tz6AFLJccCWZ83wFfcnog5NYHuxcVpwzg2NBYKc",
    "57dZX3u51kn4Q3L1RTbA88vweAp93E5bnXKKR4XhZgeN",
    "57fR4uwrkqHeW8UP5UvoUvWTQwczu1S5L9c2PHBZqJA4",
    "57uMngFpZR4HXxPV2wh1gRpf3zq8MTLTSdm5cG45GqZV",
    "58QFWHbuYKATMjqNueyNeW5rYfibTkX2FxVjgk5Y1Va4",
    "58SgeZSpKWQ7iGTPJjNtVDdxMh35DvFTr7kvgXy2EmiB",
    "58egJkU53FpUKEfTxEz8yJxVwTDQUUNMqNT1LrFCBr2c",
    "58imjkiDdBLhXfg3NncoK32vgEbbhWiGXdQ5286Ts9CD",
    "58onsjoTdyG3g5c5aAJZRPGJeJ6gvZ58WshQao6zpB8X",
    "58ztxHxSRTsVUVY1pStrud5iUEpSjkGYRH3qCFBM7vgX",
    "59EHP4BVSNpK8crCi81wsp3iUfzdU8G8zAVCkXHAevGn",
    "59PRv3E2c4iSQaQxeFyhMmSjfXJTZvW1fJ4TR47jYBUr",
    "59beo67tqEoGaC9AgRCugCo9D5pbjmNkEuk6a6ehdECr",
    "59d9BxyUH54UMAReKxmREh84gTrnDN9wdbTffSHgk97N",
    "59hZdScRTSMNdGmaGPWCSapMcGV8o7CdxUw6t4Xcoua6",
    "59vS1WJi3YNEC5Sqj7LA29ErbaPmNgWKrc6745t8NKKD",
    "5A3pzVE7UUZ2PLW3vLYYbNr4HhJM5ufWnKxmQ1TWVWk",
    "5A7CFMSPxbvP82AHGG3LpDVYQntzLqWdnim6USAFRdpL",
    "5AA1f5fCRbzH7v4HDh5XZZfA1iZqEJUXjP8WVvQ8acx7",
    "5AHNxB8vgY6E29XoF82XNpNGvGXB36p3Vk62Nqzemoiv",
    "5B2go4eJgL4mjxqAs6kmTvRkDUsUigY4dQBhmDvTygW8",
    "5BTuQYrm4cdgZ5KTwC5m7mJSSVxTJJ6L7YmWS5xaQFAj",
    "5BpB1SDzEH9B26EuyiLK2Zc3QyJr3tTK9Ugq7JLBC5eD",
    "5C4bTwaNYWB3GY6oZgMMHUdtaoK6sevkzRDhG4Eb6cNZ",
    "5CDx4JWkS1p7DsHqydasQYEWvmGpAhsuSYDm96UiokR3",
    "5CWzPGoueUT511XZUY3qAU5aVUbCvyAtfcbUdsJDTyoa",
    "5CXZT4Yp5Rwxuv1xdGPnmwB1gpgN67EriWDVtypK6JWM",
    "5CvpBKSrhkd2KwLamdkUHnRwhvGDz9rBJ2i5z71cUY8a",
    "5D3NkPG6XGBYVp8ua3YVJsr7REJJ45vbzvnNjhZB5VBN",
    "5D9G3ooWcoAaxopwcy3WgRbFrzcQgH9BcgMVD1V3hBaV",
    "5DMpqZXUAKUYeBohSa7MRvgyYQjZa1vPq2EqbW9za4Lw",
    "5Ddb8fdViZdoJjoaJpLt47KHzgTmdJLf4MRRuaQh3KKT",
    "5Du8QvCMkPohuukdvsZTmksY1pPvvHzcCRKjY2JRNdTb",
    "5E5o6bCunND9xnLoJeN9LYYwnhghdkjYFSXRZ9pujRDG",
    "5EJuGHNaGDpfjxKhrxqdhw6HEXoXbVF4H6k6kXrPXrLk",
    "5ELhK9Q6xDxyGqjXTS77gGohsr6PpBYG2SKKSik7Q35F",
    "5EN9Aya2ASkGKKUWAGxFrGsw4qhShicaxur4qMjM5mnJ",
    "5EPbYuWcqP8dMJV2f2xWHSwG6E9FbWUd5SgHHyLR127q",
    "5EbYEw2dsCmFBeN7hLnhQkTKG2wrHZXEFkekR8xp7dQb",
    "5EkhHqP1h9WUNZKqQZaWPHE1XXrrgZko3K1QGrYKVUKK",
    "5F8cPvjeFHK97rBCGW3WAAzp4JC6CPWXbLtEH9wWnSeW",
    "5FFJjhSShF849y57Q92BoctpFhN8tanky7NTwesPpFpG",
    "5FXWNCVuJ5S1TPmhxJxhqLxCQrCnfHriB4e8pAySMH7p",
    "5FsKyRncJ4rN4FwEmf65iWFsykF152PtZHGuhWMsMhvK",
    "5FwCwddzZ5BHJz32ChfN5kZy6ujpR3wwFwtfB7BTcMf4",
    "5FwZVegP9PTWeqESgENQRHGGaS36sGiETxoLxZn3qdgP",
    "5FzisFfAZRMnsT1EgxqNwWMEpJCT5mfcEvbLhubdfoEE",
    "5G3YxVqAPqRmvKZcAZs5H8GwL3aQTBogdxML6ywPoevT",
    "5GM5PaWUEvLuqJmjKwXLxGuj6piiKHtnNJqSwuYPJ5u",
    "5GMu1qdos7WyFM4WDEGmsEPsiRMUhuP9b9YqmewCoeqC",
    "5GbcUE26p41ZxqATSkJ3NY86EXohnHVffDc2FNAhfTJk",
    "5GcKAroSZkvtv16R1XqjimnSTf5v5PL6XLfboUTAJu9M",
    "5GxtJpjHorhv87KZBM3XYiFioSyjMjqBAHGoWFGn1w8T",
    "5H8UAfc5M4GF6fWSLADbXZy85M6DFXGERwMiSuANbm17",
    "5HQGEHRT9uBfuQyGEETHLZxAptR9c3WCZzSKAYXK7Fdp",
    "5HWNEj3vf8JAGiofkXDEh3qvJEnLVc85NWPDzYp1PFKf",
    "5HbZJSCf6A6TDKETKLwohqzdjMCyYJ37GMCrrkLk2pEw",
    "5HfgoTALVGJFR9a1M2pLJBBa51YgaQ8Wz6wHjFiEnV3N",
    "5HjPcTGYdPiGK9roD2kJxDaHhZjcd9pBQ1mBikXA6DLA",
    "5J2mmNiRR54JTJYqguAKbPyJ6739ULrsG87rc7YpXEw6",
    "5JJutCnkjpvt5AGp34GoQCAd8ajyG5ngZU4Mk2Euacke",
    "5JareK1rVFBkdvzDUR9hkkDrroUn8p1T456t8J34Rrbv",
    "5JoDLJGH7o9Nb1LcrNS3VkVxeqhnKdemDw91htZ7Z2L7",
    "5JvqgeafkWh1kXVCrPZEJUGu8hXxoxTnqbmLA2oy39YN",
    "5K2zxym1AnAMM7a4uj8Et97SAizh6M3WhVWkTtpGKdRV",
    "5K9dr9qA6BwJkR6piBs4skrHD5C6xfkdqgKRfUUzWJvf",
    "5KBCBDXzkpFNpqPHjA8sVvWguLgHUjTjfRvnYwRhCAnC",
    "5KUmPCCceC8T5B8DKJVdQhmDeYsQG1D87NP9WmrWayFu",
    "5KZmbschRTNw68R3zYepTogTF4dfvhes4Y4yFt7jgPWs",
    "5KgEvscZ67xtn8zQKjJ47PB1VKiHtGZiocchVdHb7i5t",
    "5Ks3hyA566DGFBv72ruLAqj5HuApC3gUjtayUSYPf8xh",
    "5Ku2fiaKTbsCW2pkNvxpge4mkhEdZAwLjC5s5S1gMzWw",
    "5KvXZbCr43nimqf3DACDkc9nHHPsFonfttennGuhe6uv",
    "5LCq49NMHBPtY6QpR3wpPdkECi77DZb5vwfskAfdtbRn",
    "5LQPUp7F1dsRWRiwFwK31f1U1wCm2brnv768rqqQjPNP",
    "5LUPsNpeMSHqPfYTVLBs7g2Yn45tm1qAgZg4QygSgk4R",
    "5LiEujocaMyWu4M4GevzdpNkiC6HoQhCKFjdfooxE3rF",
    "5LkKNN457ZSiYBqzs8TLvh5hYER9zHBqsNyKpE6xp284",
    "5LmJVnBNRbZnaqNuFbREi6c4NwqHZLTcfU7AyCtScxNA",
    "5Lsd87YbgGnqyGXN2fF4zZQxmtG2YYTH1Gs4HwuRviLd",
    "5LvFpoHoGbzuuZbrvjKNXZqf1TeABdeRkGV7Cd9G3XXH",
    "5MLZmrUaK7UKk2mnFNiptjHfgBJ3xjzRjSzeubPHq37m",
    "5MzX7R1y1H8CEA2d6qTSv5hC1Yi6oRP8j1SDad1LPPKv",
    "5P7xGTYx4eMwyMXNivu2YDxpKqAgYtB8fWaxsLNzxtpQ",
    "5PjhncTPgHdt2yRz3hESUePW2XjDRwBDzKVPz9abYsKC",
    "5PxuVdEtZm2KxGZWbavnQhipNt9RMYMA7rBiLX1hWied",
    "5Q2iChw16oecWQn84dgw86fuwftSbsVqPVveyKqxPZiF",
    "5QJqfAVdzEzTz97tWqmzM8W1VkhYPgZmPrMafvig2c2q",
    "5QYK7NxbkA4xBhFa2ovN6i6gfBafx59xCiCaPCQcsCKm",
    "5Qhy2ZydESk2k2pQzLt72wicc57qJKYjwnZkypjqTyFs",
    "5QkfX9ScL4b1vrAP1eeGKn3b3ViY9zn38JtXiZhpHykD",
    "5R3VtRD8ZtVXeFm7oLajNLVfn7dEfQsoR6DeDrdRcmdp",
    "5RC88hq3bsQDt16pf8XwLAXhQXkyHmBMnneDEReJkgqQ",
    "5RFomkfDTEKh3oyKmxM6iaR1wZYV26LcnpsYgtdoZqFt",
    "5RGrbcpWZM2EhNXTqGSGXBXtpaSnnjhxWi4qoKzdwvjb",
    "5RSdeXuoyn9bZabJvdoMv7TyBUQXLWxoLv4nUuPhthoG",
    "5RYLFecRQQW1mC8sWAuFnQycfJfbAz6YBbC7xL4bWJeh",
    "5RbapQdsxV3HxPFDPn6RPcoCGoeEJr7xkKLtBVJnd29o",
    "5RrACi3o73CAU8wP2CWyYaDGmBPwMw9mLoiqCCBUg1ep",
    "5RtGDtgeuCHwL9yAuyANyoWtiNCGQJ463UpgTeEQ28R9",
    "5RuvnbF5GAMNEbVdQo9pebFdpzKF96RLRfHre9TE5U3Y",
    "5S4w4ayyCSxZzB32Y9qmXfAzXmwt5PMQMaA3V39hrbyX",
    "5SQnH1h4gV35ZdRVKz5e3NfwLmMHxpXcsD5JZhZFg6VB",
    "5SWr14x784AhcHYohB67U9uik4Rc2bvzHxUG3EK85tNx",
    "5SgEccbJX3gnU7tNzp227WkRQ7xzm49UNhBF5y9BFZLu",
    "5SiLW6gSP5xGobsJg1hAC2HuNEvwC8d3HnyuC6SbkUwb",
    "5SnAYNBFCa3mB88Dt8zur8hFrorKegpn4PvYwkewdEsb",
    "5Spq8v9FayTFXqzsy5TvUEuv41N3kGbePdfT9dbfSWQ6",
    "5SxA1YM1qeXqa5gNr8L5BupSD7S4KrcmrEJWE3GVRao5",
    "5T37eMtp7CEDe26u5Yvsf2aCztyogTguDwT8SiNyMgKv",
    "5T3vZphpjW2DfJb61iKGbpd3KVHgk7DMvzDg6oDDX88m",
    "5TEmigBuJ8DE6m2iJ3Cmd5vEYi7s9kLzFrAXk5Ha2Uxw",
    "5TJf6NptAVri5uAHbtxfhpQPU9m2Zm38B1Nd8YHQeerG",
    "5TMCEvsJ1TMPC73yTzSgPte1E3cY4iPxK1UQKZCAtscQ",
    "5TaeuQQ8bpi6qZdXKqhBqYatVJSnnDey5nspLTbyU79a",
    "5TiogEQGfbWGZnpStksUyizew1MHw1rYYSTsZarCAJXo",
    "5Tq1sQYYDCSFiaiXahJ1Cf4BgyjZ13biLYjvN6B4bA5f",
    "5TthcdgLtDAAcqxX83sxTkD36QhbsSTJSUUyRojt83QD",
    "5U1dkb9vT8RrhWuHHeVih4uHYxjkAQd5BBY71owq4RrP",
    "5U5XUCqJUktt5pRriFXo1oZHrpmkdPjAZXu8RuB7r9Rk",
    "5U8VpsWTFiC8P1Jpk76LfMaSPmeb3mdncaP8zR5RrvbL",
    "5UBux192YXgy3xGEeCr1Bjp4hxJX4w4PZxrYKwXVeKHY",
    "5UKtb84jfktagvQ6okoV4GAQRNXPEspPL6BYuf4hpt7J",
    "5V2LwqWQALN33M4PyKCH9BkfKJUVputLqhk6Z3wX4JKb",
    "5VGwJARmW4Tw1aKtBoBVfqVBDowGHN7oKNJ5jy1XLy4i",
    "5VLkUgGKT3pUMjusNV9u184L1YAXbk1i2iMGs4mZKovx",
    "5VNqDq64jqgDFePz1Jo7dADf7hpWTwbSp4uKUHF8cxPJ",
    "5VgppoPH7qFx5RDEG7d2itkgHEYpyzosbrH6kvS9DtJq",
    "5VhcvcjxkxUj9e93KMsi73XLtYGqXVLdbcpL4MBnhbNd",
    "5W5kT4QxgMcS93j1SXFU6sQm6KAn321SVeExxa75cLYD",
    "5WCAemJZfBcGjVNPgGbk8ioUatvDHgPJMXVd6o76hVan",
    "5WU72yw8zoeeJLkaM2TTKQJW6Vn3aga8NpzoxDjAj4rr",
    "5WoprXN6vxaYu81mkeYuBQE2dnYdVL2C1SKgRcjsbCHq",
    "5XQRtuoEhX1Yt4g1L3iyCFeDdVvGyHsFR5F1HRQhPX1X",
    "5XVNYBWa1kg6kJereFbJ2cWXeq7SctAG8uLnsfJdiTWr",
    "5XpAtx9zSzmEpmc6oNMXf6hpxpPsJ2VokK3DdgxG6goX",
    "5Y8ucHF9Ls2np743NXBhc33kDTwdzAHGS58PNfh1xVyP",
    "5YDuBRHG33EfYDJx3pQociR4gNTtaNT9CLKG5HMuXbhA",
    "5YFpK8jeUPUjP5gHftwt1DKawQUfAMmeNP97SJ8N9EUj",
    "5YUCpUtVh86DuK95QzYERZZjgxau9YnXFWx8FXQQiTs5",
    "5Yig2Fh6Sg3qC8xrGbvxXkVXQyNBDwH82xafKGy5XVUC",
    "5Yt3XmXznHLSrvrWvX2GAE4jroZpfF61Rk1b2AStjMyA",
    "5Z1jeoiCDJLHhokWErBWkeRhK1TUdLNzbhBV9YWhzNG3",
    "5Z5giybvcB2sYx2Drcp17qm2BaKUWQ4HowM1NzgSAqXZ",
    "5ZRrPo6Ed2iA11jxmniWXjoZJCBxBe8RNdvSCL1yCc8q",
    "5ZSnj8Laaft5f9UatBj24vi3C8PLFjAGavNTyKUbrwj4",
    "5ZTahjnBycxdz4EKfUdQAsecjgHcLebJRS57Hmn7sAUs",
    "5ZTxin2pStfVqs8ipzhSyFoLRSgCZ1mFNaAuj4iweoZT",
    "5ZVoZzGGhvzVBNYnskmGPwkYbCt3tmhFWiiowL4LC1pE",
    "5ZWxi72jqreYxW1Z7FMfJa3FRLaLsUi1jPy26Sub69G2",
    "5ZXHMZwE3gjP6apogan5oTxAFN3BJ5wchxVbex4t1wvk",
    "5ZYMWnpfV7zbhQdXgQP6wy99saiqXAA3iqssHjokajYC",
    "5ZaTXuPqK7paxX1kUUJPQHCKgg4vWMRs1EnyZqeyQeWE",
    "5a2xY6ecAXJNrDmnK6C71CNqGLvYtPaRLjTRAnYSwiE6",
    "5aEQPBVDCnGujirdb4obB8Bc2YC3g2A46NCrDv5FWXyy",
    "5aJdEjW9wpPJACUhUCJ84SSbHyDZG4FNgbcs9TBWkbmD",
    "5aM6FFx8to1WqtRFN25tzJPZh8VHvF2ro817e4hpo4Ag",
    "5b2g5ipHQspXfKfRqqo5FYYRCBCazNaTLkKQ2jFFBhfB",
    "5bbUPFAc8szdizv9cCvP9bizKok27mthNimCS2u79VMv",
    "5bjr3q2YS7WfLDwySFMpXwxEjNXBBM4rHGoPtYexFy2B",
    "5c51eHxLrtDR1mUz9NS6jJp5eZQdk6L7bGuWkA3SPMNF",
    "5cBq3gc2ks3Cm1gL4wniwejcJcPZ9L5KuB9jqHagTizX",
    "5cCVTGvuj5ozm9NGXv2GvQjAWVzLhPxPpJeQZhTiqsjd",
    "5cH8tbcqXqYcGZSZoZgac1hH416kqoa3YjvtkVHKWo9V",
    "5caHw7AFSyjYFh8ZSXWG1DSY2AvuaRZcfNbjw6z4aFiq",
    "5chT72W2DB3RTDD3gt5WS1ezzPY7F7topQavZzKbjb1x",
    "5cujep54GtKfW8VUDM2UMacgM93yTDVzd2mrjYY5pFCo",
    "5d4LfAfSXd9VHUQSgJHwtNi7NH4HYR2sK95fGN8HKjcP",
    "5dE7rfz9o96KsPxUYE8nDQqpwKyd9dHKsCRoiKdEgT1u",
    "5dJpNSLLs3QTSSwjdN7aZrHvSW8hB3tMUKZT7KF9jo8T",
    "5dLuV4rrTnVsemt4wwqnHjQN3kj5BdoPBMG8ini9MXtw",
    "5dRE2DixNxY3v4DeCifD3V3kYoDJm6yKoUk1AJ2hEEgz",
    "5dakcpK2M5hcXYWHXCUgxnqXZhASYBXPoXQPjzFnT8su",
    "5dbkoeVjhLxK5NE5rkXASjzRdzRqryvt6R8ut4b1wzN4",
    "5ddY9tQDoTYRUXED4rJxjUqtcngqb2f8SW8wJZpYKwzC",
    "5dkW7w7mDxXG5BobHvRKTEZCNrqeHd3S3XNade3zLpqJ",
    "5dpV4n4DVbvaufkWiUqv99ioj1aHeC79f47wginXN9Fp",
    "5dsKxMqRATGszKQU659YhuWLoSsuM3sC6AfxdwNHUord",
    "5dyVJ1oqwsTQwPApGZd1UijUtRe3KTxV1MC9LVTFaBGu",
    "5dyhx9qQog3L9vG679H5caxxkWtJfvGMK1upN5ULkXpE",
    "5eQ5xU8cZNuMY7ckqabC8ej9qYLQgzRuyha81UQGbBEx",
    "5ejosTvAa6TzMxGhEwgNCdSN8fThG2Mmxs1kHieaghvE",
    "5em5cazwEEPMEiNVoF4Dmf7Ku1aVtxdPWucFdmVvUAiw",
    "5ezWhMvW1sn7WmUgKNCVnCJx9hKg8hierjXvZxQqJLcH",
    "5f1uEcZY5D1SFhNDCN5KREHu6DvmgYLLrZcXgf2AgLPk",
    "5f3tAXkFVBsboPASRHcMyJt9VChiiBEnbHzzeCNbtzSi",
    "5f44jfRKQEHafcCAAVLGQMUM7MLJREUBGEiALLTy6nJF",
    "5f7KbvLoNKF3FixaiqSsMVzzq1cwm2aEZHqFLTWsnRU7",
    "5f89pk3LFdAFML2pgYJQPhgG5a4p1LqKwv9WR3SPpZ2w",
    "5f8jrn9eT7HBnpYstfB54do1kJYodGxqifPbZoxQbDuL",
    "5fMegVBEkVVaajsSpTn1RY7Vydf3CeojC1xwbFRJ4g5P",
    "5fQ6EqQ6u3NFVjRVC1HvEgx6jesfAXv2yCGCJmXQG1vs",
    "5fQ94UnbKL8ZW6ABR9cQWkqL63NFcXHHzhKr9TLvowza",
    "5fW9Y839MYAMuwEvyrw97gBhcmc7moKGd4vA9Q77kfP4",
    "5fXFGr28LLHUfqdRyrPYEGCyYg7hssMXu47FjrAxepJY",
    "5fgVKEkfXtjsvDgGn9jPucHawJtyTZsiqR5bTuhHtXBv",
    "5fhKHtUdfFmVFChGUrVh2DQiqSLBamcpJL3MuNnrxwTs",
    "5fsvDftirSt6xC9NU8LsY3sxD9ymfD6Xmo41EDxPVV6A",
    "5fswTfYkYdSuTMLg5SZA5McMnrWD4VWVre1B4hNRipx6",
    "5g1mRouEH7zkqPFi8RTSRTksW7TkpnUjmP8Es52geJVy",
    "5g55dgVSTCsnQDV37gJJ3hwF1dBPTTBVh76tfP5hoTwa",
    "5g9pnpfHFp1incNreguvN6qzW1KJoyp5c1a3ZZHb1JjT",
    "5gAiKpxun5pqnkeGzqijGvDd9xYYiY9CYyZNdRBaFLVt",
    "5gFp2LyBkayXAfW6utRprH2FtjjT8ycsDBCNuMPYoXYG",
    "5gHsbdDpy7Ym8Psf6ECK5V3o4VpcqWMio2PWmR74ZeQ2",
    "5gUGRg475sBeyt2Dqks41pEni4y9CsNKHz59UAEsHkYq",
    "5gY9UFnH2X3K3taW5BeR2WeeEEVebtSXqHjP3ZBYScNs",
    "5gYKQ6Uu3pas45gkVVUqMaLqg3ghvWaRckPdnyHJAir3",
    "5gnMRhGwveemVXqRhpcb8cuF5TunJNtekgonNXcDh8Mn",
    "5gnQ2GZhbzAmfZfpmnb9G2AySgcm1qe2AvAyHn379FUV",
    "5h7kEQqScrSsRYPYQ99KYDmgeJmA2xtrDj8o4hhzJvPe",
    "5hKSbKSUiASfPvfyLJCRv9ywjm9ToFHcUxm2w1KNz4oM",
    "5hUMrqiE9i7ZHUpwh6yoKLgM9BLquvTeyesUCjgqtCf4",
    "5i1cMX1WvB5AVnp1ai6C8XDG9MqzemzkyP7r3B79rV9o",
    "5iVwSeYsFe4aLy2P6dB931uSb5rmCcyxgTVZaD4qPL4f",
    "5iic3zNm8XpyCSCjJuHgrno2yrAmn9u1zdKzjVjpLap5",
    "5im9AgsVtJRH1CNF1aMHhfoNYzeNuJXD4NtJL9ZJnQBU",
    "5irvTNjobtcDvM58ppDQ4CsnrHW2LMgmH8NEVGLMkyDM",
    "5ivAoCu77JcTu7fxndxacLmuhCBhvGWh9jWx5NGxj1Pr",
    "5j1Cw5HQjmuCWFABEqRsAjAJG2cWhM7YdmRcpELob8dD",
    "5j9dxByt1UuStwDwkAuSsTf63LJDEC5XRRVZdmpxZHsU",
    "5jH73HoKLby1sCykoLZUSTpB2A9DjCBbcPSFNsKLyjuR",
    "5jMXpX8y6uAi2YvTuLu5wY7QHcoGqBkTSnLcUoY5CJUT",
    "5jRvAkoRtRq9wvjQqrW4sue31i7VFDbSYXTsfkcb1VeC",
    "5jgNakjxFdrhLo9JunVpgoNuE3VkaQW5LCmkQ9e1MAza",
    "5jhFdBtX27iaj6SEe682Q4HrxsxHikNj58xCGibBao6K",
    "5k8CoqPYW5mP5vu48PuA21vVRYcYcaAq5e3pxrrCtS7S",
    "5kHYQ93KRNgJKie9ZzuqUPk9ZNbYJ9Ks22k32Q4SPDVv",
    "5kLqYifcSaHu1bMgu5NDRuu6fG4C2HUDgRdRmcqx4Qp6",
    "5kXVxzAmEBfBMUsYxsXbgfBig6WHwbaL15MKV5CQxcjY",
    "5kbD6By7EBNj8kTRtdjZ8naoheA5GJV4YyM7kiXMQUWD",
    "5keSeLdQW8taBLmebwT8a4bfMTKsu7Jsx6gat6hgfRDc",
    "5kgQrkUxsdWhcXAByzoEdk7iCLRReuRSJEBaS2ZnqHLR",
    "5krwypRg9S3VANeV4vZmchmWUZCg4ngfFLTYjgTEeXVW",
    "5mAwhFwsM9kr8qAgZWCE1M5xrXsP55VtJ1SzFUctEUPB",
    "5mHfghnCjb8gxFqKpgcmh4oB8k9HwFoz1YizCAZsQQMh",
    "5mgzwnxnq8DqV5BWSMX5dW7AAGr9ZoQGSH3p9UL57Rdu",
    "5mikE6zAnbcLeFmeNXrfJcBq1YDAHVzVYRXATN51TeVS",
    "5mj5eTXnCqiDnbcqh4dCHDKmjUn9g5yxyjyZeTk3wCWp",
    "5mvMRaBm4mSrcpLN4apA7NLc6vyRnjGbmmUyEzQ5j9Ad",
    "5nL4UXT6PqP9v3Yrg1j9baXm6DtqyfF2ptTSLvCkJcKL",
    "5nokdrebVs3KhhVDvpT6MagTcb5nM6s5unLjgu3U2G2Z",
    "5o9Uu42CombZjfK9Vrp23qM5mVt7g6V9QVjLuzhoR49R",
    "5oGsDM9d4ZAW7r5phTgq3pgtAct9s6NoF1a1CCsWcYDR",
    "5oNNHtPj8Spmtz4i4RZwtTpVKjnFGjDgrQMePXLj8PK1",
    "5oTviCNHCchomT9HmPWBnrJviCjTSpe4uMDDXqJpgfuo",
    "5oUQ8M673B6BBdZNGxDAd9Z4L933t391xE1Nzvhz3kao",
    "5oVUF57WygVN1t1atjAPrAoNvvhLrBGF282bv8EcTEMR",
    "5omEDTaxXvFBxzGtcZ8sXbdJc1QDHy7izDgUz1jQdtYr",
    "5p42FGmNic7era6iUiWVvfntZR8nGXJBdKeonwFiADEw",
    "5pCV32LdvHnwp2d5sXpckjMF2dutxfXoTMxQmBdSiqEf",
    "5pJJFazD8ArnFc3cDb1e3hUDAyBPN2RUXuNyEvDMxwMa",
    "5pPXErnjjsDW6UHY3jzDSEveXZzPx6C32wRExvjh6AbQ",
    "5pUaNk3KfDKox14xg3K12faE4A5or7EhNnDnJAWq6nuM",
    "5pVTQtDZuYBCBKFziJ3JpVLsmEuH3LpgmL8DxHTLRTuq",
    "5pkAhLpj3Zbo6qKcAvAYTmV5FymsoDj1cbU3n61eR2Rb",
    "5pv3XUeRobcUkkXruzQV5H5J3ZAiYF7q4eG7AjvXzNr6",
    "5qTUSRFAvejP9b1fnEvmHrQ4qZoBX4ZEpv9Exw5hGrXA",
    "5qgzpY3V2nii5S52hwWfUEoyKZGpcAJQUtCG7HS9yqwA",
    "5r1NK2EJmKU4TzLmK5iA1TmfcJmv7X6YiAeHawjCAHNH",
    "5rDo7ALPs76U2WW4cGFTXSHwo4KJTvgkZCzrunQ8GusW",
    "5rEsyxKSVXqCo2cmBR5T2gE3PTNGzHrv8Y66Mt94DChs",
    "5rbzJd6WgMMQqzqGuF31uKFnRLRu6r4sBbsVoyMSzJZY",
    "5rm5QhRjczMj2sQaKBNPQdtStHAGWi2P2EZJBoUTHtwN",
    "5sJ65bcDmmVtdh2NxjrQ8woyUEShpzeTBmeCB6PCUVFx",
    "5sKtsmAouc9sHotoiwwCVGFGZdPWgwJig7xQXyiECJie",
    "5sLMHvwW24RJ3Th8X4NxbcTXSeKRGmCyAmAVq4uJp4nr",
    "5sWhpZVZhuwnmVAFy6J8X8krXoHKNX9yNCYk2y5vqruX",
    "5serG1ae6RyZ2FKCbaJoDaBryxdRRVSWwxpJ3rxg2kyD",
    "5sgUCBtpTXrwxh7xg77h22ztPozkcWSw998ZF1nBZcW6",
    "5st6thTgT5k75qnfVoAuGHV9jQ6av7eEkGrjtt4xbMPJ",
    "5t5UyJ9i6q1DFRrgSHAXj2bSQPGWDrdG2pYRX1avG14m",
    "5tNofaDwf4K4BhHi2aRh7vCtTPW4dK3h1SYqCR4Gezrn",
    "5tQA7YdXUGYBmKNXHJqCN96JQx2HaKH9ZHGTFds3NCja",
    "5tYEbnK8Zg8XkEgZzSz2TTz1RfAd62JMDTXDE5nVpevn",
    "5tgvV3UxSAzfBpcF6NEFjFoLCHbJ5Gb63qrWL8Vtte9P",
    "5topzscmNHqAh5iNJVsFyMKFUgmTTMB255cvjG8B5Tvf",
    "5tqjhywMaVUJ5DufnTM9N4c2wB9pWXFkjU1m6qB1j3kb",
    "5twLq7r5nHiHLrzrub3nRVLTZFggSWyecFLg6VqKzzdC",
    "5uTwa2X5e2x6uWPyY8hZCWjM6JSqMeL1iJWpLH4P6xq2",
    "5uXY1Doj9n8dpFLYA2WFzuYXgSksLLNtoXZ3wQFuJqoz",
    "5ueCfBmorU7d3SmBNfnhGNABaNP6Y5a3dRxsYgUVeVAZ",
    "5uiUrQXpw2NXaSNqteYcPQvouhZi4puU5v67MLyvo5eV",
    "5un6Z4CGpLdDR6Sjv8jqLkWt4vWFNbbAoP1xYfDfno5G",
    "5ussyBoojFDsrd8EgV7ULxTGRbSYPiJaJEhoxVCb1w38",
    "5uxfxiqZ1grHaCoh3kboqgoSBvF46DJLnbnw9ZLuFVPh",
    "5uzjofHkttss4shhqHD3xU2CYAKp1NuzKoQS6aXF425v",
    "5v3B5S7T9WjMb1Rk5KueSQc32HpvuN3hWj4kR6FU2zdr",
    "5v8mHaJbY37X63bExSqLtBUdjha6giYB53G4m4SYkisg",
    "5vKWA2WKcw7gM7P195F8ZhdWEuka1YRYoSe9nJr9LZhN",
    "5vShPKZ9B8M7MppELdchKAqMHVUTz9rf5u3KfbR8XroU",
    "5vUjLMBTWN9zWdHzLMiwc2sshqApCc6GdbZdhFijfdK7",
    "5vaV6T3d55s9CNH2LmN4jBa3VngihLroZbVuitQhgqXR",
    "5vu6udsvQzvnmx8dDMtu9BwdALYRcEoGHTXBJARo34iH",
    "5w5F75q3VHFdfzgaYViZ4Vy7LTmvD5WU1wiGu1BXSNtT",
    "5wHqww6TGzi9KHa1192boZgjz2zYVmoRbEVCrAZaSPnn",
    "5wdbsuSj5ZraSJWXzLv1benxsPYHWHKFoFEToJ3wcuEa",
    "5x48X93VJxNeN2XVKQSubFDrTLxd2iF2zi2HBspPBmNB",
    "5x4t3tnjRu5XW38SACAKtRXbdy4DiUnRTn9A3s7D5DHK",
    "5xBom7juuvk7r835SYLUTtMB2S8T5qeBUnQXLecWWhuX",
    "5xCSKJqcfdqcHpUq2u1bQzp2KYis2LQF6ZjyPa3rdEGZ",
    "5xGMtJnr2FZkyV7JFpkBTGEmQiErzM7mAxfhvshYpuKR",
    "5xKrsg2QvTZ3DtjX5KScLHH5b4X5FNAatHNtddjFVtus",
    "5xUP6FkFRzvp9tK4kNJqwctbwgxpEzmcZ8BY6V7Rm71M",
    "5xVWekJU6Y8cxGDoGHdrmGQpULnjvBocd3UiCpVyWYaW",
    "5xY6fWQX8E7s1gtdkV6yDTrNHwL8cqwztrDRVHao5az1",
    "5xZVj3pribKKYm6PqV3VehcPCjYfLBenkZtGSFF4tMi",
    "5xnMcPCk3GyPieow4TorSDQKnRJrr8XMsRNWbw9AQPxR",
    "5xpqaNTCgVEJ26YPStZ2XLMpHikQNDq9cfdGC1oYEJnx",
    "5xtiEx6aytcsWxVrWvLLGxrghgNmg1FStZ4SstMuCGhF",
    "5yLDDJE4VNdgSuZkjovZRizY1BB89Wj8kCj123dnnF3f",
    "5ySxiaDNUqi8V11PX4YxFLM49G5d6kBRCp1yo1KBEQGj",
    "5yYrqjYJjoBWzuXn3ZhZLz3mn8ZpYsjnpV2TyK3zD69o",
    "5z3MgKifeVDD59Kq588uacyfTFHf2jfdjTisjyfSfHzi",
    "5z6Sths5TW1Cf9a8LW2hE3PCrcNYd8wbvJxjCktPqc6w",
    "5z7nnQfyzeBv1gtkV9mcrvu3aYJRP3rSirQHGbAUHw6M",
    "5zF211fyLxPgYofhVkvJFHcsxhSqUnP9MxePNwu71qbE",
    "5zfWFMYfWJuGyBS6W5hHumjyoGeFSusKuoCrBcKrdRoQ",
    "5zoe3PQA58Mjse8Jt7pYNTdWMVHYyWEHRUehmoAy2Nk1",
    "5zwYkVBK1tPcvbkjYU4LhGqseRqFRMHDjQwvJ14RJwus",
    "5zyXCPAdLoUkKC2kn34DVSFCRcgRmQ2GSzj5uJJw8Fgn",
    "61duyoMywKtKkqUb168G4Hh5SBuMaqiMrUKaUiHutsgM",
    "622p51eXckcRMgVXPRdtyciuF6mm6jvhBRrhXts7mW4f",
    "62VsyC82NRHiQkg1LWaCziwQjKuYHpXxfeNRSFh5tzPu",
    "62azENsz4cy4KmBAmGh1WuHzB61a91hUx6RdHFDx7a8U",
    "62vErQ8a9F2hXG9a5eT6JT7MmHAf7jyoRaTRsxCtEuSB",
    "6387F3bUSnmuPrT7QLepD2sgKmzRQtUFTPZdymNKu7SU",
    "63ATj8jZdkaPMLtDQBX7x3RibdeybXbTk4zjk2uT99W3",
    "63QgFU4tEmgZUzmh2yaVSWByV885HYUvJfwarm5KkPWQ",
    "63TwQ5ccv9i5qZGsfaiDpDXPrGCDfLR5fVZgQAyp4t1h",
    "63knsTtRJiAMEdRzWZwr5vHd7RzZ67VA8yisMWKupdeR",
    "63oggQVAR4BjwSY47zdTJzcUTBWVVm4D6ZHo6uShdGLS",
    "63s6iW5bctVGHxk9FRQCkxbr9CwPfPBqynYNVH3NBu5V",
    "64Qp7hthKq5XwrJUPJyEF8NBBPZWoSKbDe6Am58ug2TY",
    "64RbVyt3C9i6yrPSigTN8sxjKv4Cf5w8XEGGfc5prj9y",
    "64qD3sxLN7qMhv46EZtXDB48pJzvtqQ52CK36xAWvNpv",
    "65RSXkGdDfuP3oTMe49Bx6z6oaQciqs3BBv4gnMVyiKC",
    "65iSzRYQpv2m89QFD321JRMWayFfyhNeQ3WvmBPdTWbo",
    "65jFyKEt6BAVktAvS6wfAY7QEEte6NF154X8c84GKMQv",
    "65n6mZ8xotg1Ud9NKUDy81d4JMMUYgotjmDcFCozU38v",
    "65t53dwP5QM3ARSx3zaxX4RcrE2gwBqGi38g8PDcfQn3",
    "66AuZCNH5nawzCncer1URZJX29Yv6CTtwsfR8WUzvgyg",
    "66SeEsDRmKaead1dU6EppCs6r1Ybgc7JT53zvqsmSnLv",
    "66h2jTFqAE5rC3us9FzUHWDVjia2LYXCAqn1ZEskBjfW",
    "66kLC9LoEBQiUPsnCBx5Tw6VKbUwuY8MkAf2yg12JV2u",
    "66xhHW8GbFyA3Etw4RMAvgTzHAvZiRjydxEZb9cThgZj",
    "67GbotwFHXzraCeVQQ2a2JMgLMjS4NNSWbkHnnDVEXQf",
    "67MHB97jKdXas3WcDs7Bo7ykThGA1m115x4KhmRvHL8k",
    "67PLjDXh6Z88jDRGKAyzskeSfskHGwDLBvVhDdSdScEj",
    "67ngYRdZuV6kKN3T2LNYMRXNQPUZSXCjVCpM7wGNQTs7",
    "67oZ6JE1Evz5wrBsWi3jGiYa5wujoZhPH4S8qyNuUGD8",
    "67wLeGNoAEYouCVoQ8GvTyvUHixSPMv57zd2omJ8jdr6",
    "682fWmg6nPiJ5c8ZqUW3zLGhk7jF9nnKroE5vzLeciG1",
    "683Wh9dLkngx13D43ceQk7cxjTz5JxFahE91awKhbqh4",
    "68K6TZYeE2u58Sp4cgUZvcgGNaydnvvNmevpBbUwfzGo",
    "68jmzyZWAbMma1fDg8mJEA1zo5cuHNHKFEAKjmsYHvPV",
    "68nZWFZmeJW78RkTCo5NGPdWrHi6XXyMEf4bkNn4ETRZ",
    "68oCuv2ov6pneG7nnsbTGDCLo2S2GSnUgsgc7egBX8Zk",
    "69HHrEcpWBqtH3dBZgebk9MyaWGkVxKVTH7cUMhSFxde",
    "69NMewUyh6aWVbTB38twq6q76oDmuBLXFsFToEvj1A1t",
    "69TvdjwRKYTUuyDjoZaNWhLf724TT3Lhg4vixSQ43KWj",
    "69UvVzwrnFu1v4ryrkinWf2RKh6tMgjR7vK5CTUqBrXr",
    "69pPXfXZbVi9Jj5WAnyPjwFbJYsCx6es7CKRropygtnU",
    "6A1Jy1rSDYYKmdxXWmFkRijR3CWGSiwcRUWnDWj5c3dy",
    "6ALCM7XZNw74i4bPy95xeVTAgXsVpBM8NTUGidp6ghjd",
    "6ANzDKnvqZyZpDszJJtMRtguCNsucRSL8kjJrH7RJ2BL",
    "6AidubPrTAAKBzaPeZrWtsj6Av8tXjTJQ5dLsVPR7Wnf",
    "6BRTyshTWD4pBkzorqjgGEPfPgNAJi5GWQ7GCuMss1g7",
    "6Bemfuo5BBBxDUfa9KMZAibpFNNThkNxPiWKdUjPBMBk",
    "6BoCzeaSxLnfAVM5hxekisDgMTNq819JWsJmQA8RJM5D",
    "6Bt8YQNUkEMpSp8cpn1RLU4m3QfVU8cdGwj4GKqd29Up",
    "6BtY7PAv3knmvbBT53UuKJZwz6tDSkwWqD71rwxX5ntd",
    "6By6tVypPvpE2XDfYo32N4FZrbodLxasMPvoceVPmZBR",
    "6C4Vd7NGQ68wp7b3V2Cb1WvUQ9mB3mWf4nzRRsxR95BP",
    "6CEycYgvGxNrZif3HLL1eFd9ieVPGvFTCdgw1vVMXAin",
    "6CFSJBNsC1894dPxfBFSjYBUt8BwKrymEHe1Petb7hPL",
    "6CrsBSRom2vRWKJtF18wo7FELJesPZ3YmkFpSBtz9z3k",
    "6DFWiLHMjrYMujP1yo71uchPve1jERPEMpoUT89dnQbu",
    "6DKMV8kb1AKfgqLsxr8UohudeXaX6zyUSEstHpB35KG1",
    "6DQ4icos9z1PScRhYU8jxXb1kcy3aYi5z9eqeBofGtLS",
    "6DogDFts5kSBBEDiaJnPmG2iKCNx2rEd7AMV85KE5Sig",
    "6DpNjhGKTPU9b3pZAq74AhB8n86udpES3TPB9QJWdgND",
    "6E479bTwpo11TjjKvd7qQ342YqiiwoRnZzVcf4bwsrQe",
    "6EK51zrr5Txz9x4UL6MdoBnhbraq7VL2XjjjM1bVibzA",
    "6EKtCCgcckUksgihdUatPjHhEKGMkSrD9fDZDBJXCADZ",
    "6EMuLqZU1BX59xRXYCoygtEQms4iYUHttcgdhP4fYxLB",
    "6ESFEXLZ646Wxto6DLyhmaK6QYt8rYg9MUbdLYmsRKky",
    "6ExufjM13YLZ1atsX7YcKLwc7mxq4qg9auy2A5ZttWnS",
    "6FGv5BhT2QgjMY1PwTxeVHZBQBPh26L5JuXxAuoy3GfF",
    "6FHdtX4sXwfD6rKbL6VtiZiwjP7tynFUEJonqbtZdAZg",
    "6FKgrVoPa8t5EjLpW7RKZP6nonNZDFZCesDxRWQTca6L",
    "6FMvwneTZhntkfHqeSG3guehW54PQuHE8db4y7dEzT58",
    "6Fa8zR7hep5bodQiGrspsUjvULHqRE6wUugGnxZ3tcVa",
    "6G3cv3GjDkHybNmc5nAG1HMKka2XFrzZ1Co4itaDsuc9",
    "6GGsxfTCLh6DZQJZEtuhNBazP8jieipnAbypfqRBpXaT",
    "6GcLtEX4jrtrdVL9S6SiHxjNdiNvg78hGwDCLpDy3LJS",
    "6Gcyuq2w8A1nARpPPquW76fnKZfGnbC7KRaY7mhFp4UG",
    "6GjKPw1KmksDavyo5pk6HFewaj48nXnQJxQXUvhiM7gr",
    "6Gpr72FnNqu8nPPTNWFyFRa3ny9wznvKocTL9CuFshhE",
    "6GtNH273uYBZfjFw8jDV8yp51YcZ5G8byCw8hGXd6dMf",
    "6H48ccokkCjQQcmdyvYryg8rk9rt5ehm8ZpeP3td6Hje",
    "6H85Wrq9TirjfEfYRXSDpxMNZNbpVV3Aj1KgjMYnbpvc",
    "6H9SQQj5jjDeB2Y1hGZsQd5NJVtzwiT9xBRwtnk9Vx2e",
    "6HFdJa4RhR2KwRVdd2e8RrF2Gipwa6jWN1XqgvjtUEXt",
    "6HcyGzBcCoDdaA3HwEgBARBEiy78ptNnCgnf7mPU349C",
    "6HequPnT9b38FsAPX4Xf9V4QTgAVD2VcGLn5RkJR37VT",
    "6HjvUesWchpNrKP7bEdE8xXGFUzecDFVxu36bQLXgfEC",
    "6HpHux57XsBuA2htzg29XcbYNKUjwrvCg9YossAcvXn1",
    "6HyYpWCVoYHhdmbvGpCPTHaxWQUejqBtPNepv5SppBvx",
    "6JBRDbQwwT9PM1kq6MgHznxpogsHnjpPfowcc165expL",
    "6JBgyXGwB19DPemMuuPBnvzbDZY41CCgn3wrTPHfcYPB",
    "6JCn68mvHMeswcfk3JYZFnHZuap7qRfn1FWz4A3ronjs",
    "6JSZHnjAEmsUBqvnxYKbR3NseF772fqQVJKm3LMZLike",
    "6JcJvyizcwQsait8FXCJvsm9yGzGmfUL247GqMogQSjf",
    "6Jtxv9WKGMbA169VDm8nBbUB4H8ktFe3vAZstANnMrAA",
    "6JvEtzz3Smnj3jnCCDcgaPzmtcRkZb22PPtLV89Gwzy4",
    "6K13BazojGJ8FXXvp2r6Fb7RECKaVU8Qms88YH5QzjCn",
    "6KASjnmk3BxxHikRMAhHDgz3osBeWrY3FMxANjLGRKV6",
    "6KXoXCZXBaV4xC5BaGuLA34Fas1vUCAkZsAohBUcxPnC",
    "6L6zWX4P1LJUmfj7B2rt5joLFoKPMfYjogqNE4MnKDse",
    "6LDTRR4gRyxh2Qrv4GE5sVFr19Sm3oquznKDh4X7chGT",
    "6LR4gJiSBFh5kpScYGwXxEnQvktnXemVDTyN8v6rR2qm",
    "6LoBa5bDkCnZHa7KocCLd5bABoizLgYtKSC8SjqXC1Qw",
    "6LqZyeFjSH1MF4ypsThexfDS8EL9La4WciuaUSrhhwtk",
    "6Ls6PzrmWr4cRzAww6s2nAhoEE38R6bg8FJfu7oVKamk",
    "6M58LauT4HuVYuLsevTY8xugT2scTUo6vZqonRzKGRCk",
    "6MJS9L8ty3HamboNKAWYARuvGH4q39SX2y82SjAPDL3q",
    "6MJjZQzeLi1HMRTaQhAgVkhjeswGEVeegMbm3W5uG1oj",
    "6MMQpmvPzjgjwMDGxf2hRh4nMRZkY5okAMQBzic3qoHH",
    "6MxwbbwFt7ruKv1VDJgn9WGV2JDE4FuwJNXuueodMaeL",
    "6NL9MbChdtvjosB4HX4XuQ6i4U9iHasSoQE1QGFZ7MvD",
    "6NSGS5oHYngK9YKvhzR12YhzCoipUK36GSxtRL3b1mBd",
    "6NVguMNKg1Ja5b9dsyjL2X9omMBhaJmSQAYAmSfVrN9a",
    "6NZvee9K7HeXFDzpo57gb5hsNWctrLWsqofQqbWsSj9n",
    "6NaWwARyPEvTVpJHhdJaFHVjpdrqpWf9887PDD8KBJH7",
    "6NbLsjUdmTFX9yjWjV6gyQGYPzciDvCgMtzzTbUMNesj",
    "6NjP56iPkFjDWcVPHq23hqB74qahNx5U4hY9ZjfRaZSH",
    "6NtcMuMkWCBkABkik7m9bMC4CBnTNSNZ4bvjkFnR4rL4",
    "6NykVAdu7udfCJ6A4PkC7xcsVFTuGpzk8DVKCbADafzp",
    "6P64Bb7JuY4uk5rqokX45z8Q8wB544yg1r2q67jaUQKX",
    "6P8ThCzGZXXzi7d6Nbq1aKWioyzX89ebqqDquDaRXnsg",
    "6PVTZCaSRCpUus5iGRLwJLnbxtNfvt8J9GkUaidzh197",
    "6PWxRb4Ufkx6H8NusxLCqw7j1dNrDodLk3DAWdXCbEnb",
    "6Q1s4ovts2fi8MLM7SYYGWe56L9Ln7iL5WNRUcZjq9E6",
    "6Q47B9hGsLVovsCrVQPQ9Zw2oYedb4L8cDUA8Uv1r5a4",
    "6QLhLUcusEei4DioiYD9n2GkSe92cqwQaBvBdXM8TfpH",
    "6QgjHBqdKDFBQHNYsDhSCX2vHMSYd1CCu3uoebcqxKjK",
    "6QkkDXMYGhhkrVuMmgcDi4UsuDvT6fBsai2vLqojfaa9",
    "6Qy7d84Tv7Gvg1Ej4RWtEvqR8gipa7D3P8TuuyXWQC9u",
    "6R5heTd6LJVgRyyo6Ab8Jmq6zqU5RoBYAD8nuxiiVtnW",
    "6R7QDKAF2jbbTfAyB63vDDW6M8U3abzTZ76jMMQBzoKd",
    "6RLKah6a1hWcPPX6Tjh6FFZrPA8hrF8uUv7iZXvi5mg",
    "6S6Rp2Fw8zinZgNnBPrnX655J6NZjCR8E4s8sgu8Mt1q",
    "6SLP6JcxsvVKVWVzdWt8bmW6YKgLSQVVMgwrqdqueXGd",
    "6SUygzoHGV32U9AMTBNFHpW4f9kNg9zg9SqojtpRJ17F",
    "6SdiEDyJMZP1e85TFtswwooUWa9opjYcNz3m1vvcEvgL",
    "6SizEtrd1zN8taJ3Y9S7oeTBMaJRtPGgAfmHgsxyDuHW",
    "6SrY6VemfEv9D4XKjP1WeDpVKxTvPJL64Qju6eoCQTGH",
    "6SvtMW6So17inHXd3uduK7zjwrBcCM2U4zNdVdyPX3iA",
    "6T2863PVnCQo3y5EUBBTYPu2SGaJ8UaL9W5GeVinBUYn",
    "6T5b4Q88UPXmujcC3LsDwB9qdNqZy8jfxMEJBNce3jL1",
    "6T5gjSnDPHd8ePDu9a6NJNmb1G7C2xwqNLC1NHUeHE2o",
    "6TSuW89kP9uwfZiaVnejqAJUdtfBtXDu98EEtKQGh5aF",
    "6TWSn9SF6E1RrJhNATbYgHcyHvDQBwK72H2phqyRxSt5",
    "6TjEwGjjrNmyhZ26bcRS2xMYgnkp6oQBuouANXM5CnoQ",
    "6Tu1Sm5BUm1wNQzR69x2v5sLKpuTNHumrw4Ls314YXdD",
    "6TzmQ5LCEdQryfnJG6zbS1esFHzMHgMkYfcVHcxvq2qL",
    "6U5sbMrWB5z14KPPgi3gfNWpatXHNsFDcd3Airv7PdgB",
    "6UDrTqLEyYx22QdoqXCNzwS9vy1uGVXcV6BqdcBHQmXN",
    "6UN5feJ5i9KgCGcB7cTgtJsFUPg2ziDCfZUxua93p7BE",
    "6UaJrxte11gHzjWDod7FrqZVywyCYQBxeauQmSs6UHgw",
    "6UnRTSWtqU2rkBALrTrHRxPqzzp4PiXDjp9PBBJePyGe",
    "6Uo4UUMJ92q2K59PR6VXWfY47AZjd8USSAGhubrpYUJB",
    "6UyfBYYpSC6HnxFUGVi4JFxMYDeQwcBgWWN2w67ecVQa",
    "6V4GHJ26HjVrkLpWRrvecTXMEW9bhR9BNjjWunMGytfC",
    "6VPrrooaPo4CEFjB1sK18UcRSvYfV7CmRWM2uHATmfbX",
    "6VfhdNY9xMCuGvoeXcqfKHiEDTs26dMf3K91WK4sGGnC",
    "6W6fJgpL7xxVt4MeV7YiZpX92XS9UWSdvYFEhNL1oGdn",
    "6WCoaZMGQ5heEwVTjb3qnawp3JyAPEivjVomTgkSjiYT",
    "6WDx9vnNhMkSFLuhNzpEfWtTmVbFGyBJTiTpeyx2XK6M",
    "6WQksuH8442LcJEGLyxuCKmSGWUactHEuH5Lr7p6wEHM",
    "6Wf4jYUtU1jEEaESHC4Z6MiCJ4pPui7V5H8TZC2FhY6V",
    "6WoTh6icMT6WYTRVi6G8qTbmrkAzSU2BEgTojfXVxWBy",
    "6Wxd9LGuTbPo2Pnr7hhoSqW6EMC2bvEt9nPzF3JDd2u4",
    "6XL9TGEwy7EfUw37vrkLZoGtxn4cbxXs9PDFHf9NbH6o",
    "6XQJsQxDgT8AkXjfNTXmt8iXU7QfT1yLriE9iHNLDFaF",
    "6XT1TRUiPTxgGdahftypT62xjNbcKruRuXNrmizawwgG",
    "6XTVq2Q9nRicJY4do6e1G1m5KdUqwgPjR5yRMz3d68qy",
    "6Xb8Sujg7qcU9MC9d5Wo7GVJCc1LEY6NiscbSPqnVtXr",
    "6XgTtYqF1L4QUPUg1YmU6YHWfuyuqC3affnJJPzZB7fz",
    "6XoVX2tF88QsbDQArbTimSpggzNSQrRvEdxPvMrskXbd",
    "6XsLptNh2tgQVL1ktjfGjwP9Ru8vuBfBVh864zC6SrSG",
    "6Y4rC1823ninmCdrj1pWiWYJCwVHvDG7KfugtdgLB4fy",
    "6Y77iWG55xMJaAb7719Je8jWuX7rkodG3TdH7SqmRWX",
    "6Yjx6pQ6RvQJTfbqJgz1vWMqB5gcsR99Dwce4UvDCSwE",
    "6YyhRMxZapyGmH2nRoYdepjZDUmY2J1XWobwfqaa2Bq9",
    "6ZDQD9DE1BiuhBUgcGhPQGZPdy3spVQjsMA7nPNdoLEZ",
    "6ZEn6zB5YdGC9e5XbjCU96qQPW6nStqmLjAcz77PHS8k",
    "6ZHrvbNgjgoSAFKcgTrWNukLQGjL7g725BvxFExscDy2",
    "6ZPrhHhTW8nhtgfgtZxNxMPzip3UYPAUnt2iTgaLaALg",
    "6ZQJ13Rp6amJoftddkPnGhdeDGKAYvwhoj1G39fCUf8o",
    "6ZUW1y8aDpZvS4ULnPhujchM5yp5xTPFwezHCRU58NeJ",
    "6ZepgfaddGfNeqnuymck1dRAVPivEcEGggrj8DWxeaiF",
    "6Zfh2rbziqoxqC2nHse6geEeQpvrgvP7cBtgH8GSeggM",
    "6ZhutotJRn3hWwnrB2AdJdjC1Ab21t2SMnkZvqrAuPXS",
    "6ZpE5TwdRC7dxxkhoyCNkLdt9FLWDDtS1N8T6SPuNPM5",
    "6a42SVzMQWN7b5nW4Went6aZRhmKaZi7PiHxnoYJdNG7",
    "6aBTypevUvA6aVvBA8FKQ1o9nidbcAgnjojbXumo3ESK",
    "6aE1baDNxhnK3PphzFpsPfkNTwycBzQG1myq8Cqh4Wna",
    "6aMF8n2D7Qa84CVE4FuyNUF794qc2h5dvCeQEQ3dGtDw",
    "6aUxmeiKoGBpb6EwaNmVJj2vK36yfBdsooZoX2jXFKDY",
    "6aekyPVMRQ69sCXJc22rDJz7P5wdSwyybpZz5CXBhh3X",
    "6akiHENURBzqXvK4SA5cMNiixiAjStGY66a7bQNpGiVb",
    "6ao1cNKjXvA5aD5foXC7C7vSoN8Kc5nqF22oNdzYBaxR",
    "6ao9AMQu2WiiRVAb14TrTJg1Bdv5NJAKkXsPEnaZACQt",
    "6aoNeGLvaiS5zMgaxFBEWGbTxK41LQq21y2RDy3LgxNw",
    "6b3CpvNrjCvxnWmXbfbwfPmEcFfoqNEma1uwJFBhihQr",
    "6b6ZfCvYZXwjvhrpfdB2PTJWi14uXi963jit4rAHLEbo",
    "6bExbLPNdG4pTLuGQi9aXEFXobJySBwcTLtAtEH3WRKZ",
    "6bTSGaWNfii3HKAFwnpMAZQgkjHQoD5bhGYncqEHoDFU",
    "6biPm2dNeXgMHd7Z9och8QvjWVuzGep2DuFcTNREeUG8",
    "6c91jXFAznGyXpkJAo2dT4tMbv1pH8mmyB8Cx4Y5Ri3H",
    "6cf5P3ZQKxF3N4Dd5upaMeyBEHhXPNpo6k8wBp1oqrF2",
    "6d4qtvouwbJ2VTqUUsMcXNPYskAZyR8H4sEFdQ6QWn7J",
    "6d5UqJuPa1yRYg1iTEuLFv3uLD4VtBrvT3eDJzxVrm2U",
    "6dBqHWt5ukKjyWQh2BVESSoFSr4Xh3QmujsB1j2vx3a5",
    "6dSJNfVD2vj4XmUczzsPDQUn93oYNJyxYbjqdim3CSbY",
    "6dTRgJM8M3P5a3BBSvefh19cebpw6eCGJj2Z86k1nWbk",
    "6dmeLXx52bo2NUHY6z5zs7bJz63P5V4sfB917RnvRW7k",
    "6dyLgE2VoD9fsXoqHyifJHRZNkFdrumt1hEqa3kkQwds",
    "6eGfFSspD9W8hu7Xi7oTRJ47jDBYpgUGunUmzch2937e",
    "6eYn4M1HcvuVpsKaxjsLxaXbBunCVg7pw2btFLcBiZV6",
    "6egreS2SGdcvEdgJFNLNRFaTHx2becMRDpDdVdov9iY4",
    "6ekpxG8np6wCrBVWHhZ8hwY5VsTSbiyoxH7VTcqET4ib",
    "6fGgrRFbkpSb4mEmfFMNC6jpVvEZtF5R5xLszQ5N4cE8",
    "6fR2W7N89HPSp378UWkz489WMFW2hhv3pPaZrf4kJ5YV",
    "6fS27u5qgQjixS5Fc9Zg27jYxTiKE5hpRwgwbesxeFYP",
    "6fW84cDBTcK3VVwGK2a8UczeLejz7VxKJ3EzFrofNwAD",
    "6ffr8TSX68emS6Q21pxkCxw8m467u2Htx2NoRAV77w5z",
    "6fvwspckvXN4MRztcRfnSf5kaAGPcUNNDSumSisD6oDh",
    "6fwHQd3t7Reupzzhs3cmFuiYyqjYYpnvX7sMTEegA1UW",
    "6gBu2Jg6e2G4FqYWjWq4aoS4mXix9oDKCsU8z3sR1QP5",
    "6gDzpYerK22EWzjwv3CVZVmTCEs6zqwM9eK38d39GoJK",
    "6gR2sCPf8ctwUE6xiznf2GoFJjEGPKna4bHozeZh2brN",
    "6gpbngP4fMjXQ3ZM64GYL2miVcR6g7b2yjhru6hEVnWX",
    "6gssiEc47VCHX96MDjJ88hGbsi5uD4YfoHuUiTy5y9wE",
    "6gyUcKiFNLvk6ysPNj8PSh1Wi8ERGZeWU5SrD18hnfct",
    "6gzyJjnpmXqTAt2qrcfoitrRBvx5rcEhxeXt4K2Myuwb",
    "6h2JrBXrNaMHG8fzwiQ9SCmxsn6xeZifeJsn7AQ7SD31",
    "6h76u9B343MWBZZ9nHEeMVeNrUhNQagHg3DE329HXyAy",
    "6h9HnWc5y2kefnJEzpCZraQoRTk2scgnMMxsrE7QLyQe",
    "6hJkxzRRLvtuKdzRmZmyTXjPeNGXZsy9PJ5RR7mP9iES",
    "6hJqjwKQD7iVwpC8ZH91smvR5YPxhKRdCGmmFkn8mNbh",
    "6hM8bWbinDBewbgRvG7rQVCqpyyqLAGdwemy5rdbK5eE",
    "6ho5gyUjsaXd2wXzMDiGeWv8xHg13Ckx94HoFNaexhRv",
    "6hpoYAhe6ttb3V98hnpiBqsFUMiJggqfJa4Z9NBm53KF",
    "6hr4mDdqxzoCjFZQ2a9Vwa32gBrb4f8E2QkaqTmUxk1q",
    "6hw1SPs7YrentmR3foETbhdMoTPYvkkxsD1DLZ36wJfP",
    "6iE1qMpK3ZHguSKe1FJcZo57fwRXzFe7y6Q2hGzuEeqK",
    "6iUw5UQGVYua9JKuTHxNJhXSgSuMmuFw2vQX2B7uX5ZA",
    "6ikfypx4j8J93Ay8QstDJm3fJ4W4GQmk9nX5jKP95svu",
    "6itXwZe3AL6F6RUGSdbVyBujyfqZcVnH9rxnzLhYqMBp",
    "6ixjv97TZpPEJpuD25b2dLyhAFjpvdKWfzbWHegF85eh",
    "6j8cZctQ61cNxRiBDdSeZa4CtC6YYqExCeEf6CoA9Tfj",
    "6jRMmhV16MohikHbnPqVZwRbTDXyWfyLX7o4M66Sbap6",
    "6jVqyBqXVirRjabmGMToQrDe5jVjdifkhGkDm615EgBD",
    "6jhhVWywHuxBpvdC3X9EuNTtJABwYx9ot2nPzRnN88j3",
    "6jiDRrMYiaKTfGK3zmpkbQ7DUeJfoHvSQosGcAwrTWck",
    "6jmDd7ZapfpzFAsTZ6CW6cWNnKUY7VXpjMidiS6KC7i5",
    "6jpxHuKKnr4sZgZsKWd1z1WwKwzABEyWMpnp2bebNSy6",
    "6k1FPVhVPwZwvGmimadCx9VT47qhSiFNVUKJFQEnZNkb",
    "6kouZmHNwk5VDyqoqxLu5qhJsCqSkCC4foL6cqWL3ns9",
    "6kuaVDEgFhr1VVgMg5aH1k9XaDbTJUsXbpHGcsSwebRQ",
    "6m45Kudirf7pTrvuxcpFK2HQkMywW6dxLyaZSqRntoN",
    "6mLBcujuQhBxdEAfjtSb8zQCKsgKy4wnX8pYyTir7qnZ",
    "6mNhcCdHki5iF8LF8WXs7HZ8JFRVWipu3JbJNE3YFpZr",
    "6mf3ngPtBWunhwxJFsLs1Eu7b3Q8jPGk5uhU65EtMgpe",
    "6mk5qGSQyFFLecLjWEhuQvs6W1DwodCtc8yK6t9cvWxp",
    "6mupTA4XA1Gq4oy8vhhPQ2heFfMufijCW6kENxHiVqwF",
    "6n3DpZdVkTnugHbb9GSDAWegfmYcoErYSfkGci4qHAeA",
    "6nAxSs3BMnytuCj4ZRifeqHVm8BR2mFdkjYxNif7jrGv",
    "6nELekF9Qo2y2LeT475fUySFjEGh9jkk6WvhBFAE76eQ",
    "6nGBiZ4U3GzyZKvRUsVWLVBTBfLqV6XqxoHPNjwLguSL",
    "6nipWHRB374JBxhKSCcRdpAt7Uy7dJ4pzvq8EFiYDoai",
    "6nvVFDwaASFjADK48QKKjwyfXLmTYUsD5gig454gBJ3w",
    "6oE6qcmmutwtJLQrpQArzzbmhnE8yf1AUU2yCGfNfSbF",
    "6oGQFdpG2bFWWZiH2eEW11bQgUYb63ZXTaCXgDREamkV",
    "6oHjHxBYLCGhUK1kkNVQFok7GFbK48KHVpGHABxxsmDr",
    "6oQu4vM85Ckq9MgTuQBtSfjdhEas2JBhFkj82z9RHBQR",
    "6oWi9wBVAbc7miBXe4323vpehdgujXVV7RxbTLSKt1o1",
    "6oeXmyY6VDUT4T6cutKYmgY8AxEnCPYjRJeu3B9qBXuB",
    "6oh1c1YxanLU43GzwJbbbGe2FNQaNaGoabyX7NyK4AGb",
    "6owLdKauSCxmGenwwaHZhvoH9innCnBJswi4Kp7qNFya",
    "6p6D8bavQfP1eRcU4jt2RUQ1uSUhM8fgdfhbEzTkcgUy",
    "6p7gKmJWqm3Q9qWaFXi1hpcDXzGFwKpuLUDqZjtjYvTR",
    "6p9kSu4RqWhfG2AqLA8qksZoyscEYGACQX5Y4TohK5FX",
    "6pABphAruEXhYndFgY1bYYpid4z7UtQonMv13otQW2zM",
    "6pGca6GmrnVJMNFhqdk4bZ5GqxNcdnGxWBi3goSkHMGs",
    "6pWQLe89oyBf5nD8MnsLCSNtvPpyJbc9LF8Vaj1y8o7X",
    "6pm2tsUAtVqJZjT3D3S2Db4JZ1vqNmHbhyVaRXjzMNB9",
    "6pnfbSkPeUDmZ6weLmwrsijny8WiZ31cTrFN5bV4ZACF",
    "6q6heqWqXXvQLeThQ2Jc3u6GSGnBF379Tjbe3aoRMmB6",
    "6qCCodiQRvd9KEW2DAR9GyiVgH7LcLG5M32TCuCRpFmh",
    "6qDkeecWXdH1kWq7LnWspCyVXYhZTZcjgfNCZKSNphRN",
    "6qU8A8YNQCrjRNFAxAz5GeSqCorrSbdjj7qDTXAjMhCc",
    "6qYRi2poYeuBfXrP6WxrHNQ9Ug6wUg3BHisife1my44M",
    "6qYddHCGTYW12B2XWM4pFjm28KBAgu1x8Ycpd5Put6AD",
    "6qvv2DnEi5UVwDRpv7WTf8PCUY5dAMSxpeujrFnaWTQ",
    "6r7cHMtJmKnFWvm4CbmFGd7uJe7rvPXUEwN7zmh37DjU",
    "6rKQASJj5AqoHW21gi1KWdE6pqJqfNbw2CkqppQqPi52",
    "6rVCSpXVLtbAjysh6FKpfz1AQpCWxftCcEvGiDrF4SgL",
    "6rcSaarCFgnrZT7v93gLQEv5FkFVqJejLato78Np8KoQ",
    "6rh97cmEfozkbfgMqDvXEqAoHe1mb2rm4kFCKEgc7dbb",
    "6rp4aY8pfb1H2D6SPYwJs7q5f18jaqTp5CVnL18VV1gG",
    "6rrLkioS84mwiXW7hyf14HZEgCvpmyCJX1Ce4joyWe4n",
    "6rrPjz2RArrmk87gGnX7oY9AaPzEz7PeusgQveDKAzy7",
    "6rsgizwQCAcUjvekEvHY1Tyd9rCUHmQepD2wH1cTQdj",
    "6sd7sjPdYxLXzpSkThj3exnwk6yFtaq3sLsutSLHpNQj",
    "6shNWQ46tq6FYGJ5KSiAyFKAY4JA6DZ5T64XnGuefma6",
    "6sn3c94nHiDjRbnxpeBQwXpv5KVJdZDpRQ94DrK2waMx",
    "6tGSmpnmKNscE9C2PV2nA8F9azpR6KZ5WCQ19Rinfvcy",
    "6tRmTBbU3FsRtZ6o4vzP35Daqc3kCT6boJipYT1HWTKo",
    "6tUapE9AqJDSWXyQHcuusWNZRM6AqGxusRA4ERvdgpnW",
    "6tXty5M6v7JmTNaXWVyiNTraQCFGKxdCU9oic9eAwDMW",
    "6tkARuZS9V1Md9WpKeQX6XcA1WPG69wMs37ARZmZtVMj",
    "6tpoJLJR5t7NR77nciNwrEsJvQrj1mbeE4KmYdVUQ1KP",
    "6tueGvjWyajaazkvW1XWNWbc7hzuJi1GYbTJ5PRU1oEs",
    "6uAGXdTwhf8kYuEMrsT4eTGHnnqZo3eNmGrZHZsFUmFo",
    "6uFECcZaMMcNEuSfaaRpXndSScGmpRG8f2dBLx9HLBCP",
    "6uKkGeGzWSV2ybYPPyRriz8Kgn5C5Bj8UpZCK2jjpDzc",
    "6uWxBsJ4ZAetz1rJk8YE6qGSZY1MtYGYdMvp8EU7VpFt",
    "6udgZampG9LA6P2bzZvuSvmtHKWnb6HpXxcAMGiG8af9",
    "6umEFmXBMhJQ9G4gci3r7v4hKsQRUTiPyWousV84iW44",
    "6v3guBKdNy4kiSKd18uaT3qm5aLaeeCjvABSbwJKMLEM",
    "6v8fwhNnN1B5k7VGpzmbCkAZnjxmWvCsawDXQqRvWL1J",
    "6vRaBFyq4bYjnUPAuTJVbhAWvDyw8239QBaq1odKVMPr",
    "6vUjGGu6hY6yTYjT4tjphb7LmU3RDdoKbxpot48vMYFk",
    "6vfpTqADfrGS1LWRLqnneoka44vxqj2j23N3Xs1nnm84",
    "6vkzhBd49Hwa5gn8Ys2PsnGQRCK4hkrz47npBC77b1r8",
    "6vsUnSkAkxme8sRwoP8RszjAW8GK8hjN26Ro5grYzdtK",
    "6weMDkM99pNcJxupa75dkHJ5kHnHL2pH93aemUBWzE1m",
    "6wjnrkq7GRQtoo8Ard4rfSc4gYHMKuMuCaXZE7rosN2X",
    "6wupBVV3fzocavJPPy4LaD8PJSZsT2pYN1THAdV43ePB",
    "6xKfG9asviU1GJqTci4ToYV2S2wLSASs8GGcxvES8anq",
    "6xXqi6zcxrSroz2g2JbpKU7bwrewovyd8Mj2qqT3SbxT",
    "6xa2QvvSYhmxV5x7xAbvCqoHgbk1aaGhi9J8Ht24vLNW",
    "6xecA1gWTZCWX6AuALhJ4HxR8c6Ga8znSjTkyWgJ7JWK",
    "6xgKRWMa4dZ1csoDWw7RT1wqnBVSQwPe1KTU76PtyzTQ",
    "6xkyaJFhsyUYTZKN8VMXYVG8GBYQHf7NoeUwtBZmgeAr",
    "6xpUtC8uQbvo4sdh1gz7uAJtgyus7nmbYt7xDABrt4Ne",
    "6xqcWQmZJFvjNJ1p4BhMyYY9RdAxHDwiuYqTN2MjE4mx",
    "6xqqijKrid74TTC2XfaDCE6EbFoDjRfszL6gnNtHQpTx",
    "6y5sF7ZgJNyK3uuzausVpAWZRrcjiqZxgsGpgcQywrJu",
    "6yAGv4qkKCCNmME9SpND92yBsuLvZRENEaYRXCkCUY7A",
    "6yKXRKKWFSAqKatFoTbP8u1Ku4XPKeR9bgcPK4dVq7pk",
    "6ybUgqjnpjfH2qMCArm3oH39HmT2WGi4KXPjrZgcjvWg",
    "6ywMNJYgF3GtS6gZAmqpyT5m4kcmDLsAKKDy8dPH3UHY",
    "6z9ANpTJwANxpvZMPaiiLbf6q2ivVPdLaLPiE17WrXsY",
    "6zFGJ7ig1rpzSHGh2iVZvWQ9MyHX3vXyPdx5icPbYYS8",
    "6zVhsXqwRYpG5DDscTgFU952ebgRFH97EGWrhkn4cga6",
    "6zi1yXFzSGPJSQ7B3Yx96EaKTRpSTEgvZTE3RHcPacpZ",
    "6zn8RY2NjBHoDoVCbi68BXxUYFQ84CFtE5oVxgoQQcJ1",
    "6zpPEmZoipN1DikSizebWQbLRVsFiYXahbdG7bkwe2Rf",
    "6zpiDcABmZGMz9zqQoiEwKpr66ToZgqCyqZQn6D2Aasd",
    "6zyubvejAdJ1J7oCPMSUF7XvioPcP7e6kDLTkt7tVXyG",
    "717azp8UMYjo1sth5G1fQ3qoNnDUrkM7XLTnksUTGLkd",
    "717jukFFuosCg7JuXLJXkYJsduXjDhQ2W7R6QkKRPVix",
    "71Xj28qyUctyqDXwX7qepeRbwpoYhd836Cv2ndpsutxs",
    "71ik8Kxma2xbhq5XYzRUuAhqEDYFdvhhERqNigRCUfiL",
    "71ngdeUACCqt1kQqcLnbMDt5ThBk4fTCAVrWzj13rsbj",
    "71rD8dbDcsE9LaPFbkCkxSfe6RqUVULH2omL919yzJgS",
    "71tNwju34jStwD5RmJpmjv6pAF9wfX3VXpjVAmpTrNzx",
    "71votjwy4FUH1YWXPGUUonTpnUcv5ZtWoieiqiVzHtkQ",
    "71wZD55kYT3RzVgHtxaR3dceDYtXcb1Qdoyktp6CR9Xr",
    "71zuJn8497KndpMjkdQcVgieAtrNdk3VegNTiR6x4TwN",
    "72bBDqUNG5AZ2nNQW8dg2G9uZ7poSXx7ty6oecszdRgo",
    "72bfmgmHTZPLN8jtGocctmZWbgK6rMf88bKYNMFVEhbk",
    "72e7uQXcfeY2DyzvEhKz9RnnAsipGRrJCqZgeKqdtyL9",
    "72ex7WyvFivGs3KYrbcspcg6EaktDect1eZrAbawY38u",
    "72mLFnRxvAZvCxGvgiRZ7Qk42MjciPPmYRRwQeGLxg2E",
    "72rZFtmdRNYjfj6YMUFXgP3hDMAs85sz4dbUiRm9cu4K",
    "732X4XeK8u6MkUXgcnMBFLSHYg9opNwSrG6qRMcyiS21",
    "738Uk5i4H2RamKSJYnUogsgjFpHfT74vfvunbSXqJLaw",
    "73dg2sP4Qc5UmpJSVrqhoFUQbazZphsZG1kFAPwFn6G2",
    "73febes3LyBWMa8gj5tUpuWmRiQP5mWCYjkUtAT9hABB",
    "73oNoZBetrFDzes4R6mqoB1SDRs7Cz9ag2WiyZfUAsY7",
    "73uRRZDRoUZrTGbnnapy6Bczad5btwX4fLp9sbegHXcC",
    "741WfGZD6zciJAjeA4L4TE7LMEBiaTmYXjgTxntd146m",
    "744zyDC4Fsu7FzmzDajkW5xPFFodP1mj46yauPMyXP1r",
    "74EcYr43K1bgytrv4V2kKRF31jhWbsKpG3X3uXQE91RC",
    "74FkWsesET1H5VCFrRfxx2UjWgTjwZoxfe944yAaisXb",
    "74GQeV6Gy5c8bKRpp3t1yEYf7Fp6xMyvDsQXBgYc2aNw",
    "74GzRDAq2cAfqDNZi6Eu6TkGuPqRWaetN1tZhUmYvsVL",
    "74M2JFc7G7ZQ7Jq8vLbw1Ch8o3Dq2SZPPqGux2m4emyt",
    "74Qpn8sUGgUSvx96k7n61X9gfnUnPsB8qfdg9xEfxkJp",
    "74YiQpQo4tWmDucztbEB6EvY8krFGBk9shf4619LtwJm",
    "75SjkABB54sshmbhXKVKeBE4wGXyzEyWZ1imHooaL9wz",
    "75VmHJYcLDpRSYxEaMyp238cqYpHpjgphPQboaXdpKq4",
    "75cyctfWYsyLssyrJWCVaqr2CK55wNnGtDyMcvCC9CiK",
    "75okGDBq7Ts1HmdvifQ1j88Hj3dHEi31Hu4W3fMmo8Pm",
    "75woM8bfiJwTQ7Y8wWAaBpXxhx1ysHZD91JVogLhPL9x",
    "76En18AP9HekhePhJ3SbPYHPXP2BhsFR3ZVax2NMoyzV",
    "76NgNbzHmRcV76cp7VS32qVe9q5idVz2skK6mRMgUtBK",
    "76b23jvxVrNM2Qdh8HyQaQZXsVM97JX6UNvYfMRqLziT",
    "76hW5SkDVc7cqgYSm8QmcRPZYqi6FRgFQpXzz6MqajFk",
    "771Mi3DKqs5U2r3kS6RFX4AckEusDcDoMGEeFS28d4Jw",
    "77PtNTZueLKZqttduRwhbXXbQYoUNHxKMcqraET8F7yM",
    "77cbTrVYBEqQ9ZFaFBWauDDb9ysLbQDqdRhtntKzcXWs",
    "78QYyFcNABAJUxmDBjYXEn9QrHS8rzyEDKX8hDtqG5Bx",
    "78RhLgwddSYb4j3Rsp667GVoBuU9yy8tQGhZdAMpeDUv",
    "78W2H7FfMnTeMAfzyi4pw7xwjeQFQU9gR1ZZm2p9uLEJ",
    "78nr7GronJQ2qREaRiLn8VD3p6kfQU4wd6B73RvVvWjP",
    "78oMnQUz6DHJn2RQSuWXNCrjSFgmu5HoktVUpJRZnMYf",
    "78uWtk3oYrkPSPftni4sMHRkUgisWSsvPPDAMXLcHTDE",
    "78xuEvLKcJfvXZcW39WaAaEWxFypg41pLjTbY812JQ7r",
    "791KFf9s7tLhpndDfxW7hFyZnzA3Vdrp3a2sCBwoH9ch",
    "794ymjNhpeJv16QrUwgZfjsWxEr1e6tJziKZrpHoVD5w",
    "79nowfZ73UuT7xdUpWmsdzJXKsyKnFmPEJS4a4w4WHSE",
    "7ABVSTmdyXHn1cSsr5agVMDsQiGbaCTe6Tg5Av6ynMdv",
    "7AGaBjx3SsstU8zh4r7756Ruuo7Zupqxp1UCTaZw9UXg",
    "7AK35Mv78wUvdM5HWVL8KyovneH2fPb1n8nK4f8wi3rR",
    "7AXtLHX4dndGcondRBj9ttFvZuVj76nMHGJEPXML2RZi",
    "7AZN6g82wWVEwkvEnmUPxqAiLk2XTq4aRzknS3px1y2R",
    "7AjWs5DxJP8dUmumAfPTyGWHagecGPv4ANxh5VPZdQY2",
    "7BEKmS4DD3qasFLuh5JwLZVuSEWTSfH8y28aQgSLb2Rm",
    "7BFN8kynJETNpepu7QjRs4itQxBT6iXhzTBdC87fH8hy",
    "7BHV7X5bChnqa6RkTvbrwRCZGJrfhNzjfvk4JyJx6Ybc",
    "7BNzcbpASnVxkz8nRsRtmEABAhVxsCfcYPsqbtnCTi7a",
    "7BTsWx11PQ5CRg1L3GJUpGGaR5jf7dnBNSAnr6jzsXbs",
    "7Bf2WBZXShGT5Zk2Lm5Mr2tJ9JZ4aNbmGufTdbjr5sGm",
    "7BxnMLc6dcvXJU15DZ53evKVxgxZDoEW8QHetng89Rt4",
    "7C2AVKF1HxzYfdc1Shq4byVjqrFqGbTS3u3UPKPVhFDP",
    "7CL7arfFfvb4Hm3whKDRJeDgqxqgGzFU4H655rAw2A35",
    "7CTuYFKiTw128qE19S8ptVLQigLJWrEJtphcZ4JC4kcj",
    "7CZzNQduW3vfwsL552ajHDyPv32c4dprBrEV2zwuXKm4",
    "7Cq9ANrXjazpQBCU7V228h5TCWHrVP4envoDvjT6niDS",
    "7D3NBrGaYoXVTR5WyPSXBBDZHxd5zvqgp61Y86hazWWB",
    "7DBVYFeMMEhkxyNyMKQXBh5KzDyzhPY9fr2mzR1rYZyG",
    "7DP9NuUUV4s5L5WWiMidGhj1SdxUnNZhMWhDx4Eh29Y3",
    "7Dt8RqQ8KzzoERGuK3ocP7zrYSjjFPYpfRAnEpaKmGQJ",
    "7E8FAFvs5PWLdPW6ExBdabszve94yzwDnQNvrTdJxRdx",
    "7E9mLVa2wLdnJVXiVMKSKMFeqtcAKK1SdUxcEdvp9Dqb",
    "7EBYa3NDCXR3Pz6PZeMPTiHVRe9TzHENJGz7FZviQzz7",
    "7ETFAtX9iV9v9WabyZvXNgEZLbo95gvXA67AwCQmQDzi",
    "7ETtkbGWdkBh4Y9JkoUKkSkgTgAuJhKpS4rVhgha45yb",
    "7EcZZdHwfEsKFUDvJhPSrsVoQpooLpuPEoGtczttNw7e",
    "7EfCSozQiio4d3tSGRBEPCiTV4SJcpNKwzT1qnfTahpe",
    "7EoNfU4kEfyYqM9AqyXnwRUsoaBmsw3t8YzJSKst3BZR",
    "7EtRg68iSx9v4mK8MYN2uqndXzywLku3uAVFFMmTKDnt",
    "7F9BC7XZ74tQB2kC25ZARWbXqHSd3szaCbGFrfXShV9i",
    "7FRHds6HNkoeL22VK7UpGa7ht65P94LfxMmwByaxubFo",
    "7FSqHfDytwbuasmjr3JxfvRvexuoGhdSS2TTSRiz2Byw",
    "7FVRMXRZ4aVk4wP1zJMLTscW6uqB2v9mP5waFLp4TTv3",
    "7FkTqb9JNS7voZc7MgpoDDnB2ch6vjD1aUc2nNZAJfJe",
    "7G3LDfmytfaMJBBnvBqDrWbkqzvXfrhJ8fagPoTMabj7",
    "7GSZsqvw2LZmB6My6M5cpBcaxPceMQSsbCrB5FJUpNBp",
    "7GUC5TYD9vMcnDc7RY68ZqM73q8TEWBFdkfC9y3FsiC9",
    "7Gd4hoRoySQhY6PL2BZjMbaCWQeBzMoYetfkBPRLje9D",
    "7Ge9YgVgiL6gmYkPgzRCFdYAMv2sdCd8RPwBMdjxp5QF",
    "7HEGJUDCj3s4FLKmiTp64AKeEVJ7HyHWBnPDoXcpB6NR",
    "7HEGumHX1FbY7y5JMd7JMBoWaoeUTXcvEEcexfXkCQp6",
    "7HZ2mL8HnrBM97cqnn1danEzVFMjm2aGrw63rhuWVxqW",
    "7HscfKPYSsF3h54MBWiVPVQMP1VRRgAwrS4uwZHPQuJp",
    "7Huh1KzmAicy5GksaE3dyT2Ubasc7wKN62K3W1VkC8jk",
    "7J6eHBgg9XnVdiysqja55myKHS2S1FRHPTfVQ4VSn7qm",
    "7JJWvXTTE3FXzDfsoJutM3aTDFSxabQ2aZbb9nCT7h4r",
    "7JNgaforVTZxDPENkJHTKLt4BnMAWgLxTyKdrdR3kFzN",
    "7JZb9hZBz3w2fMYTbqtwC2DbRsDCADtNSFCNcmWN3rij",
    "7JzXMnsocYRnVrGQNRNGPy6Muk7RNxAFTNTA8yhVsNFn",
    "7K7MAqkyFtdnPwWguG38rdFFhKgTovVSburAadzyujAD",
    "7KD37ZTYCX6VcsQYDos8CWi1CPpGBd2cXHphvTH3VaLK",
    "7KYGbdW9mM1w7Gb54prRrubtAGgwuYg8G3qzY4ApXwFs",
    "7KZqugT3aW3Rtjog7cWtKBb6Drjw84AZNG66MihL9FL4",
    "7KZwsbRAYHtwX5bLCGBNpTmsHGQnY83qBFRVAYoHQMYe",
    "7KihsXpKJ2aqUheFz4AU21orgoX6KSTcUaYJBJNKdcGQ",
    "7KjBzriCMWfT7FnXgMdokXUfEVnd3RvQq1xRgHzivySG",
    "7Kjrb25EnrhAAZpLUDYZsMGnEqqaLEvKpGsJb8TU7iei",
    "7Ks6z3nq6gunigpWEp9E9JcFa5Z6ApKrMAesBoM7h8QZ",
    "7KtwSh4uo9oiW43RSTYafGTKn3M7QijJyj2gj1Qu4AQG",
    "7LEiZDx51FVm22M4kP3mPkkQzuwbUKuKByuTBmRAhSEs",
    "7LJruE5ZhNtBzqkmGZbGmaKw2PwpJQ759GpjrZq5Ek5N",
    "7LRFUVEEicZgj7EBwHfGhaXAtMmruCxAjkjqF23hjXQN",
    "7LUJXKZaMCM3Z3RKrmjCJFx8ZjtkAvMcwDoNUNJ8paDd",
    "7LUgD6SYEaEwcnAC4xDDvNge2CZrhKcViJ48ATQyYJPA",
    "7LaEvkCdmjcan5zCJsbPLC4coCyd4Ea1MJnrkE2hp79o",
    "7LcQU198rquQs19wNiVo9VLPtou7rV9H5YEzSXAo85cL",
    "7LhLo5giCbXSCg5dhVWp7r9Qmwrz8z6z23X4zerY5fEq",
    "7LjG9kcgfjub7rLm1QBk2ecU4pDLCKfcjTTucP3iMU9i",
    "7M1ARUGVVHb8baUjPgUw2RenC7uASiLXhMvyc1xQE8pv",
    "7MY2bPsCa4Kai2uKpmMCf7yDZj2NPokLg4aFM351fpBc",
    "7Mjm38vtojbVN1PYRpJFM93GVMC4sVacUqLtaDWf1eK",
    "7Mmxbu7Bm6QxK8AsWxbVdgMN2bKnyNH6EVCWuSRUnnTw",
    "7NCd3zqZajgy7EjCs3f5rfZ2JcbpLN8kkprr7J9FRyGr",
    "7NwzXc5Y2Q7mRJuRy1ZnnacdQqbWcyJde5wTyVAVFbgB",
    "7P3XA95bGrXHVd9Amz2UJqgg1Q8JjfReLKRxxgZTSWEJ",
    "7PLTEWiB8nauqfkJdBeCkfMZceVa57hxPqKCMqCxeWTu",
    "7PMR7em3SE8qWXXRnT4wucBynS8WqMpGD2SpPq3eje7b",
    "7PQMPhvnYXKTF5rLCCDSzAHZWaUe3Wng46GNDyj6gHdM",
    "7PrkrofP5WpbYErjtaSie5EAD5SUtbJj9Xivzuoq7ga5",
    "7PwMCvHLd74LkiujJ9J3Th3PophmuZLM3ZtWEDK5GtL3",
    "7PzusGCcCWc9sSxvnKbC8qdgaMyBGJAgQJoo6HwJgTkS",
    "7Q44nRX1cESXoQqXGEkLZDYqfFwxAV3KSvSznJfE3J7A",
    "7QAza9JU2WpTbD5WewBpbYsFk1Y2nFHfFh2yG6tNq2jU",
    "7QBNv8spSUATssMBth2pUeP2MRC9Ktxfv22pbFsGSR7D",
    "7QNzRd2vQVx8L3QppVsvU6Br3XpWUarKTzW59KUaWuze",
    "7QTfEBh3RRX2qgWurzcaJk41yNrw6hNyxDJUQhXAApJo",
    "7QVvNFFiFKomtwtuNChTYZaats7wuhZc8evUjYV7AHTk",
    "7QaFXUxAVhXRNobXjnDih6keitD8CV92kQbGXwHwb3R6",
    "7QaJcjGbJ9pymgWx4QQR8TGnyaMB2gvhAg6U4NhjdURW",
    "7QegTK5WPwWhEXLL8Nzkb3ykGWkqYN4z8HuQ3T9g8bmN",
    "7R5s4khsMnVE81MFzxtsijXJ1NgTXxMfL8SG1MKXmxq6",
    "7RLeNvBqBbZLqv15hrF6mdycbrTVyUsAZBWGLV3yHRXS",
    "7RPZyhrpizkwsgofAP62oSzags19thiRrVrPJu3vCH6q",
    "7RbzrepZ57jtGQ1LXxy36BBaDr4SZGGpdNCaKiDzHg6v",
    "7SERiR5bwnpwy68nCGb8swFQqU9wot8sfbzkHobdnsQT",
    "7Stfsk4xhbwTKye8QUgsdNGCaVG7RqfkKBMgFkRSGQei",
    "7TCA3jqKaPcVRVb84z3MSbbHBmeNzibSpqYCVLQduraY",
    "7TD7pcsm4AhWvisu4BEjC6N74oXonmzqBgq1nfaTwsyN",
    "7TEWGnwVxtQBQ5k4H9v5PMmFqnvnzJPT6Mi6V3ZLx1zq",
    "7TFDNriuFn8wGXQCa2JbS7yv7yKZw9GArmUM7hykrW76",
    "7TRrvKFQ6h7GN2MtdgC3tdXaRvYGSuTw1Wr56M6PnSG5",
    "7TajYzy1PRFYgX7VW44AnfxMLLsxHoarMgWKr42hZsn3",
    "7Tur8QpQdNG8BQiutXeUtYtaeRhu85da14Q5AxdGJSYT",
    "7U3XZEYnAsiUmTCAjWdrhtfBASGikAQspXH21NM35Za8",
    "7UFxyYA2k7Egrf48HGbDtcirr3PLN3KUJYNE9EGkkaoF",
    "7UJgh76sJLwgne7Uw3JqAg24BMJfMji6CeHkiickPvTY",
    "7UTVbpwjnpE5ux2htMkam49NBddXef9zwNZPjQ9F831k",
    "7UTh29Z9fa7UtVefJA9wGYJyPWbf3s5s7azdy8JDiYh2",
    "7UgKqLtWuSQ1FsryhHBfFG3PGtf5rjd9yLVkUFDWmnCe",
    "7VG3WjQcdjsS3rxp6uhAVUnpjTuKR1R8Hwpb1ByKoMLL",
    "7VGvQbDApCGsP6VhxQJwvwNa5EERiu3Suuctx6vk11nn",
    "7VHF97i2SHiQZnRSrys5L91HspdENGDirnLQGFfmx8MR",
    "7VdKPk2M9fCW8Aoo7U2L81g8CaifwdooXkgq1auVLLKr",
    "7Vgc75oJGc8Gpk2qK7rR9d3wPZiezWv7cYLJbnwWTvfL",
    "7VhhoJrsVA1f9bcLN3xzqWAXhTpDDRxnWvooBhMyFZqZ",
    "7VwSeLuvPGkAGp6hJwU7hFyrtzoDJHBefPnhhTX4AL67",
    "7W4KpGpx8SsM8PiFmocr4rdAp57h3ZA4NGaKNL5uVgYu",
    "7WP6ZyXXUcQU11CoQcMndxxXJqP4K5M6A3kCzG8YkPNR",
    "7WdB8JVWpV48MbCA1iUFbnCvLcA48tbc7CNCxJcEfCiK",
    "7WwL7Vv3QWxkXH7YgzWwp4nr2XzVxLQT651LpUWmeice",
    "7X7Qfnap9h6UCRNYN84wGZdvR6U834fSdLUDDqZprKBw",
    "7XHt3NRxwznL4j25KYDUyzsr9QDxC7zgY1tfidudykXu",
    "7XNEij8VvbQ2yJw9MTjPXTXv9oebB95CGHA6PC323LeK",
    "7XtMF632sb6sd6RXTQHcdiULEA4kXb52XFz6t2v4q1ee",
    "7Y1BkEVNvNqZNBo2ybmfixyQJKhM35cvYkrmk84P2YGU",
    "7YYsZGFrCRfFMGZR8Smfheh5rYn7HAPEcXbhCHAAtyss",
    "7YbsifEohLXY4AVyr6A8chZHtHLuTQGZ7JxNSLEbCHic",
    "7YuQhckUDcDx4gyJipHNSL3iUFjJsp3nm97JXmUKHHn7",
    "7YyACTegFpE6UUE4JMmRhbMCjXsaSKEoXnVmW84PXc3U",
    "7ZENihsseqsiUbrKfytdHYhTEsv2CoAt9iff8h8ANX85",
    "7ZVJxM87YsQJRo4BmFizJ4ucdv1TmGarjw7ZRmGbz2rM",
    "7ZcchKcSTqLo2KUs45eUCirUNs6iLDEdpeGaLvBthrWP",
    "7ZcrUe2MMH9JQ21aeoSSEiDkHX7a9PYeARfbnKjwjb9b",
    "7ZetXL4K179WZa6NRJcVmKXvxnjEUv7gjRsUQRtMUGFS",
    "7ZjbDEDJk5xtfWnpAQSHuiAwyRM46qFAJ8AstoFt1q1m",
    "7ZrexgfyyPU6iwosZ44UVHWhv3hMbKcmhZKwnMBUhRDt",
    "7a3yUHTiirsKYqHa7eyUrHGSSMmx6a7kJEnZhCa1TCw7",
    "7aCwWUeNANXMifJKykEDKy1bvi9WHpgfoX5ZvZmaJsUY",
    "7aLysi5wRdvnWh2qdFAQ6uiA5X5LqR9PGnk7mboEm7Ji",
    "7aMnZVrMp6N6avnRQv2TH9pRUzvUM6cnWDgsm4vB1UaP",
    "7aQtQiCURrBCfpFMrHqzBit1wmWJ4AtGhidrfsQSyPxn",
    "7afuFxKEFEDgivVHUmaBvbYXUbF5Zudj82qGZXrXEB29",
    "7azJVCZrbWUuZNcfikVpZvo4FEVH4sVsby3KjUCLNZUj",
    "7b9m8bjarrU1BpDvUhh9Q5jN6mwW8bfBVr1CLEEUupQA",
    "7bXZzEebFcbTgdjpPkJEbWhu9XajTKFUYdx1apEhUZ6B",
    "7bdaW8gSreb7wy8A3Ac7e9YBND62SVzmBmp9uXtCm4ZN",
    "7bjbDUZLGoW4rdHQsRiDJY2L6aRMwyCGX3odjsEWDZNT",
    "7bkmC2HHWRmagzLqhivWgJb3iJtAgLmfybG83qyS9TvT",
    "7bxcckvWj5hfSHpX6vqpGVSCKqP3fXgSSbNHv3k2sEGR",
    "7c1GjQHo3BWacpxDpFkuLeeMHqiEFt1nwRAnMNTgiLZ8",
    "7c4K2enuPxHrgFWhahE1iwkEXMQBf9mg1aNgxp5GQXsF",
    "7cEnaGFakZ5VVPYLgwKnxxWajqT1KUeQdH5pm2sZxinN",
    "7cG6VhwVjS25RdJHZm5Wg6K9e3uNe1z8tPWnVEgSiChD",
    "7cSmmfS3vmtftdwF7VqxFMYMeE49RB4SYx9fmsuQ5k9G",
    "7cTqppHLiiwCRPp9ni8HxV8KbnNGerGLbsXyPsp63Kot",
    "7chC99aucYRbke2KKiswAcdaj448nFQZKyBMihBtTisi",
    "7crhG7akvgNcKsPVyyn5njUQv7fLwEh3zbmmz7ZBmhUx",
    "7d6GdWHzdX4yqUQVJErrcgZLKp9eg6Ex2a6WRZWLMvu3",
    "7dNDnTk3aSafhEZYNn7Bs3emVk4NqoTvCTgs1QMBsEo7",
    "7dR9RAWUTC1s83KcS3eTXKpu5yYC6sMdhy6N8Gdjx9Mv",
    "7dfT9qMw1RyRWoLuTjAPh7PJpYJYvTf6HWg6MAcwdASB",
    "7dn7xEmBSqiLdFzcGLxkGZnhZ22ziBtcdWBTMNsma5AT",
    "7eGg3VKXc6JUppVEeyVXAkevqvRLJjA8DBBMqmcgw4Ax",
    "7eHxro6KspuRxqNdUSf1Y6XYLRv9dZeB61g5K2mw42oe",
    "7eKe3J9y2AKVz1TgSbV8LAGju9iBrZrj2dWCSm4ED91S",
    "7eUsCxrxPW3ZH7RNvNDVaDpnoYWNez7iw2h4cPYth8mE",
    "7eYiasnq8Nv2aTk2TLq6zLUvCT7r3YfXP6HVxsa4sFzq",
    "7ehZuruwDV6E4g4sTFAdjzQJxzwGoSPZ5zogwxFCbBSC",
    "7fHcBYUm5nEzKHC5q357cgz2MhYRQEkx3ySD5tHimdHq",
    "7fMrTA4DJdqmBncgdjtSrxRMQWyD4ucCFwFe46p32zbM",
    "7fQtomJ4tqDVLsErxmmu7n3FqtqQye4eHhqpoUCZ1wDH",
    "7fTsH6nZrcn2PLxZ8GM9Rui3D2KVahRDVxxqGVgx7qnR",
    "7fUiSsjtiQ3Rw86Rj9r8UKAii6DgJbZzwymJccdDWjN9",
    "7fZ7HV6T25GibTgh7AtbgJVx6CSxV5ygzcyhrJahqBbs",
    "7fgZ985eNxphU2UunNNUCZQhMuEtGxC3JfLXspSFxmFR",
    "7fgtZBTBhSgAqNQMjsm3EgyaRBPd8XRV1LoASVPiQRH8",
    "7fmmM2nA5jJ47p4Z7kbkbrE8ZHAP2cVK9YPYZYo7JWNL",
    "7g7KM4QVMBNmuFdr93zdoHGjRcEN6Hds85FoxGugDruM",
    "7gHU2PwFAVYMqy1LFwES71Q5zSkfE9cHYdVAYpe1rP1r",
    "7gZCrqC2u3krcPoMcSaaNaX4mVt1Pd17o4Rj4giz72kS",
    "7gxtUScwYL4eRa7sS11HRW8XCx6KUDJC6e5DmQitisE8",
    "7h3xUdEHiAvZtx84zj4eEpz1LrbLFqzBGiykD9ny62pW",
    "7hCTCtVF2B2JqsTgk8ztvEMGp6DoeJiu6KFZksgpF4fq",
    "7hFk6ZSpNj6jzNUyS89ESq9CqCBHbPu8J6fG5WQNu6fQ",
    "7hRoyRbbCXQ5VQTA7uPqjaE754n7pdRivzhuQCEkLyY",
    "7hVqY4qbWsCixxJuRRG1DccCKu1oMqXfN1igFyp5iFUb",
    "7hYnCv119MaMep2HHdx4A8fgrMjowNXmhe8dQychcuL3",
    "7ha1ZASKppTEoDjdG9zQPUCg74xJnotjrbMgr1fn5xws",
    "7hfQPUrrJd8Nsg8XgTG1aQrAswuMXm8BfBM6L1DLRCER",
    "7i7fn8K5JMLTo1qmb2TwyHVnzdpqjoYHQZ5azv3m2fCk",
    "7iQw3kzMqkSySiAMyGFGPk8Nf18uzHdyjkELKFpizSU9",
    "7iRAQE8UVhR1c8xphuG5nWwNihf1ufYXBpQE38vqAN5z",
    "7iZPCB7KZS4GW7C3mJv5Dk3Q7cW8AZ1AatMcHNsjzmZ",
    "7iex54reefSNdLrRRNvNcRtHeFw26Mt8NeYieBJXTR8G",
    "7ivSTvaZK6YAKMQ54uoKVnVpEAh3raxLzReRyVxfDfqb",
    "7j5AsNhvzeq54265spSimSVioD8eUohPgY8pmMYT83wX",
    "7jdqjw9VJWvuASEyWPYhfNsQEiVbfnKSB7fipCJ7Wx8G",
    "7jiJYnaCVGhLwzCZFixZnUjQfYWCZYFjuU9kCX3vCECk",
    "7k3Gp8xNj3NyNLXsJy6Qxg1FMmpTA8FS1eKv4uiEskYH",
    "7kCziNUx7GZ41Rpga9VLfJB9P5c996FcVweZgnNg2tGw",
    "7kJB9opQXWpehzZknEkUbMD5BvxAuY7DCwqLtqUwMERG",
    "7kKznBLAtqFBh5fGhctKCK7Hgg43F5ynXgjNypb9k8nQ",
    "7kQeBPEujeYyaaefhVFYZDr3L6iaKGem8Zz4NNNHuk2K",
    "7kdKRDhZT3oMpEb38Azxb3MY5NTyLcB63Mv5MuS9aWai",
    "7kgxZdE9LpToicyCyQEfcZfwcfQUdXxYw3jNdcoxduXY",
    "7kmvveLrLbHKkLTciueo8Gazm3DAwcrsJS3iAUgFLCQD",
    "7ksSDWMyQbkGHyZgHta8WEH28h4N1rXpuhLqHd4Wp1FH",
    "7mAKsVBd1MxFpeF8BPRcqw5RCe5V4pKeuKW6YB5H4iUa",
    "7mEtR3Z3KFAvpG8qfReD3nsDSWMRcXvLpx3Y6otgS4rS",
    "7mHXkkobdGKXtrqsjTpeMYMURJHjBaxdPpEi6BEyPTk5",
    "7mKeJJu4X9rcHgwZPkRBu9JiemHHR15JPJz6ygMB466P",
    "7mWuLWv812yvuBpvtEFhPd9NYn2C3rsCvDL3Q2EPeTLa",
    "7meAjXrxqwwzXED2gEu1vZnW3taNDUcqvxkAwN2pRVDB",
    "7mkzjda7FQW245uoaLN6LngrX2CWMhpL3KNGsyt7j3gE",
    "7mqqBEVD92mP767pga6DH2BUmZ85JJoubMg662hiDPyt",
    "7mstMaiLJ296z2YfJha4GMeCvMuM74RND2Xb6VcpfpzR",
    "7muhnCyLuYt1i7RkqMnUYMPt6wKTVby6cXyE973BRhMB",
    "7n4mrbER9NLDoMQGJRmviii3ehxuY2iN5mRCy2xL1hAa",
    "7nTbHqVALEjr8B96SPBRTTTfkQjAdLhJh79KFVL3XVwQ",
    "7nZ1Y7gjUpsrKwYCnTw6VMmjgJ8MuaDKEVHeYtSq5kZx",
    "7ng5MZGNA3nZEaXi4Jc8R4RJDv2yQUvvug8Xh2xNSVjS",
    "7nk65WXQqq1AXk4XSPYjmwb8mrzQRcC9zENxAiGJMHsc",
    "7nkCwgMLhF5GqV5Q7TFacHkWiUQh9iV8Cc8DZfTv3N7t",
    "7nkyspKJhjxao3LSLo6eKFYVEV6xaNaZ8kD6xLEkNouP",
    "7nm8PGZMgeNF3s1tSTsSkBRcLdB6pEMEfVBfomfQWDwT",
    "7nwp1WygKVpmVw5nRiEWbBaQXw5T2mLKXB1LyjcpD4Y3",
    "7oAbMZBowW1A6eEBUxjWadNzV61VrtVTumssKDbAeb8f",
    "7oVzU1myBpo2oHmk6i2pSUU7UY6fZsATJWCq9seJ7Rwx",
    "7oaJ3xtq2uYVd2Dq84H9ucMwTxkAijT2tq7BWBhzXzTH",
    "7obdfN2UJnnnWUn2qPdcu5SMjTcGDfHavsxGP2qTDsp3",
    "7p9AQ1m1DcgRE1AdVvVzuuqhrNJcmmzSUNg4S5AKPWMW",
    "7pCV7bQgmSsbVwsRDtHqUzvmeBH4zzmJKeeUkLZUNae2",
    "7pSfUzweT5wf4de3HmG22cQcwBePybQLKFk9GbiKHPRz",
    "7pTJteDHnYJUppUgcNRFokUUCbSgdikQ4piUSndbMP46",
    "7pYyVrGM3jVA2VdtB2BZ8zozT772Udv6atxgoxGSMXpV",
    "7pkXAzbcXDZ2AAAmDZUJwnb2zeAYs3JUyRoZNHdf6vNu",
    "7pnAyDKjXLAScXrmigYdU3ULLNz2cqEv9FSt31VHpuSe",
    "7ptfAgBJnjo14XPQijj7DjiEKUVUvvQ5p9JtGcS79kyK",
    "7puY97awqLXyB67yzYTS1y9Nno5Xpu5gSj6pUoqsC6KR",
    "7q1qUS5Xmv9fCDxC8w4aUjpUmm8CCupfvrqC7SyAzVEp",
    "7q9DmCbzwJpP3cDG1JndKkDs2op7QvL5oEe5HJ4ZhfLm",
    "7qU7BfRKak2Z9Duzwb8cNEo6YUXqofnm4hMhvywZs2yD",
    "7qbYySgjXSorV7FaeTnUvNvxgTqxUM4FtSipccmjnbKF",
    "7queCxhxqkHCGr5UwMQJJxeRk9LbrsEHMz1k5N6ughqp",
    "7r1G4C2GWUBZsW2wZ4sWrDA6Zw2QtmnS5VeXfpBLCcEc",
    "7r352UNE7wEfB7BrD4JBgafdnwmoXS8SeqcVtcQ3zRak",
    "7rV7wDDhXKCkT38kKa9fpgXK5zLJoHk31h6hj1rs1Q1c",
    "7rfQn1DVYjNgLvASEzaoSY388MeaUBizEaWnHDXi6wrK",
    "7rhrgLhDXZgnHEx6yEMXWtnh1JXqifBQX6C5yyJWX3Vk",
    "7rj6kzhxoeqdrhvoUn7TUJ4yg6XPeLuzSP3avhQpMKhx",
    "7rsanHY813pCa1VRWibcMhaKw6YDKi1TYDZFHHdP5LSh",
    "7rxMHMVtADs5Zv8Wh8sZmBcNCEmf5u5KvZryM16kDiKr",
    "7sEXDSFVkV5cC5MeGEgnV4MsYx3xMkF1NFwny9rS5u2P",
    "7sNeqCZ4QLcjQ6SR7soushaoHh7nYWrmFUziqU3RTbCd",
    "7sXGcrzs9deSjMngjpKL87DKHPwaTpwMfP9XTqoo9S4J",
    "7sbgzoUCoEoPF7Yg3F2JTz9WjVgB9jwrpDGrzBJa2euC",
    "7sbx8JguM1wgDbsAWSf3emhCoy4ohJwJH9WzSsFxuHwB",
    "7soWVy6skFxeV5oqvd7mrFJ7fLVKBNbUg8x2ffUrp254",
    "7stYkoHPbaypkhqfh9zq16a837uoKKdw4wYRNNVXKeKJ",
    "7swPAa2nKGMaAEiXN1LDV1QktVxVkXVv83AFXxw3iuis",
    "7szpLfBQHE2jv349tHSDpzVQUfXgqauKLgrWkqgCkCU6",
    "7t3aZiUKFnszM9NMzTwmHjwyM8HjrnLwqAa8vWQbtUYY",
    "7tS7W5RTcpiTyC2GM9wKjZuWMsuVXoQczCbkXWGTpXMz",
    "7tmvW9A913n68CRVoxz3g3Lvgw9TSk737UuhCw9xXMQo",
    "7uGhd3pTxkN6jTkLgj1wUqQVo4VeqGuUyFatx4N9XdUN",
    "7ufBX9PjmE5vjMDGjVjenPc6EpDGqbzaEwaDMP2PGADv",
    "7ufmuLyEG2ictMERpD8btsTNTrCej4s42mH17uzZqWWv",
    "7ugMaAiGEMedM9CeBnmo7teXy1kMZa6yJ4DsKoNFUHEh",
    "7uo9zVfBtgM79XkpSBNVE5zEpgtW6YeK8HomZMN56miC",
    "7utuDZgHTS7APCs41LyxB5owTphTE1pfeuuMVpaY48YQ",
    "7uv1FiGDrtMogaekrCk1LEyb1dtGgneyTvsDjusxaF42",
    "7v15jqiWcb4kFh3fKpV6rkVHEh84hkzLYtnMGZmSfjyz",
    "7vfsSteMRN71g5qFAtoSM42izd1KunePF5AVtCX8h8HC",
    "7vgRLnLTgxd4EdA73cmDiYMfPxFCNWwQPe79SaZeAbE3",
    "7vqbeqHSj88qNbmLoCTUbhX2ugZwcdjKQeWppvtwmWh7",
    "7vx9HkoBRmy7MzwGR1UmVi9otMZ4rBrD5mqGhS96p2Xe",
    "7w2WK7qNoTMHgJe8nVdvJUrePTMDMMDZ8EUA6Y3qtv5",
    "7wB3iLAB7q9Lf118dwBTELEmmsscMhJ9FqqyxQP6YiPW",
    "7wJRJzL8yZo673G6n3nASHYGHWWhaBHv7GgGTsDnuLST",
    "7wTpB9xQrPKeE12KSdqKHTJCRVWCddHUwuLBBtp73ob4",
    "7wVPtkgrD2muW4Ao4BxF4AzP42Wx5mFbpKBaopGHBLW9",
    "7wpiufXwyKksooDZQofAaCwX9YsW6UUdNpybTvykeiLR",
    "7x3JBCiaqBATL2z88hZdAfW53iKfhpEazEdYSex8ckuF",
    "7x6DoD7NG8PWTxhi5hGDEqcrmm6hvBQduP7ikkj2452V",
    "7xKJcGRHuNUx1ipEDJxKyPDaquDWkTZSYXovJq6sUFBs",
    "7xPQnDmr7mZnQbXiytoBWDFHmsXJ5mUBDUyZgfwT2e2S",
    "7xQnn7mWHxXTkZFYvbRQr82x2ZBkYYbUj2vG7NcVLpHM",
    "7xwUCc6Z1kB86kdqUvEKYCyKsJguoH2CXeXozK1u4Mfk",
    "7yAaMCTKNb3xVTr6yHJ5cUEbCbAMsRUrbsDnq9NvRVgV",
    "7yKvHQZVqiPVZ4tPuEMAXBaaS2oRMNwXA49L9rNCpKT2",
    "7yMEQMtMbNYghjrCJF1Q6Yqj7uHpjzxPYtgzAX26fGBq",
    "7yZNmjCnVjT8oLHy2HmQ1E8xhjj52b9FfrV2b3RSRBPc",
    "7ycEvshYgu4kDw7KNNNSWsHgN8qn7nWUADVyKdeDYKW5",
    "7yyjgFooXWJL1noQnU2mvogN2PFamvtApwML2sTgw8YY",
    "7z3xAnHTyxCynih9DjYk9i4UdMLwfDKud7d16U8L46NY",
    "7zboFyY7Fk4rtPRMqLwoodUswgNYh81C5PY2Ppg5TWv9",
    "7zrGrBjkHrLBaDNfx3pZNhV3dCkXQWV717scjkaJfU1s",
    "7zt4WVqGKhooMMsbUAeFr46F8L1H73um6Ww8LAGb8LTZ",
    "7zteZvhUhMx7z8bTzobinAfjjBDbCBkKgxEn3wCnK2W8",
    "818ZZ4vrU6Xpv9kVohYZstPNLmM1RzpTT5FFAvcN59gf",
    "81NNV1LQvQJ3GuCSwkr7Dj1voLWyuHhCuqbRsbAoESzP",
    "81P4PzatFdyrEVUswcc3j6jaVx7VxLomowdTzarFJHZh",
    "81eeKJy33Dm6wbmpFM8EqJTgk6iRGvsG3U1puDN4a1MN",
    "81nhKDtaYz2Brakyn9A7E3eRU73HhTK75qVEV8Xbs4rK",
    "81tGRLVXHhDTXQhqmMC3baWBAybYaozVQQd57EXecvSc",
    "823mFEGnXksjqcYjv7FqsYB8ohxqdw8XtCU3NMLbkhDa",
    "828iTzWwfhSCGvEZYtGAKGQNshAuf97hwGs8Fk2SLCnn",
    "82HRPRPNEhkAWUst8M9PDaN9vgb8s1DWSJUhjA7Fnf5g",
    "82TkZ6Zd1dJUKjrpUuAo5aPAUj3PKNFGYa685Aq1x21U",
    "82jG4PsN9wbHWay6s2QWExqcjcbWxScuUGLHsCufuVuj",
    "82qrB59eEuJ6Un8Vjoq4GUFMezLfSM9TTpPgnkHHCMZA",
    "82rLH5Ci3sXXDD1YwZ2jffH92DBDoBQrV9GUj6abzJJ4",
    "839d5mFNhd8rBDLWk3F1kHcD2y6HmyPVjaewmCW5ycFz",
    "83MFDNRA7qLZrzpSBmfyYbvudB4q2cvNaq1JzcQsQEbD",
    "83NJynPd2dLpuo2vJ7ssZrxQnnmEuCmvFCHYJVg9RK1T",
    "83VgyryG4XnUEhGQ9x9H6Tqdpo21tPMwDR8rFcX2r35V",
    "83XMUei8PKURDFzZpY8xCoz6ws8hqTVdVBe9CUFKbrnK",
    "83crYK6XJHKVuasRFyHVxSTtStc2sLHx4yHZsFR2teiT",
    "83sj2a9eCfXxJMBnzTrUvqRGcJDW6HM81W7XpGihugRr",
    "84FKHq2qfFfsQPdEFeA19ZMXWBGsia1XCbWNHHpvJY4c",
    "84Ng1jW1oQ2QRHs4vAqFTsYodd8zHyvQMwzQ7fiuAUsj",
    "84a7EhMNvdhdhoSovCRre7KDM2UAM9Cn3yci4q4o1Sxc",
    "85RmzxqdwnA7p9e7zJAD1aUtco4vhNJWJSv97d32zV71",
    "85W5FHY2TURAfnBDUf2pwPiVuPBPaR8BhgfErj96gDVi",
    "85cN6wZVnMPaTK2rwm8TkHL8PNuUemWcEeLTrLAdRR6Z",
    "85mVExMbnLqGcN7QVW34YeqEBMfnekgX1ad2hhTnmeeF",
    "85stT3DA9Cn5wHEUnwUhNFS4VFuT5pm1cfH384DPmxX1",
    "85tKtrri7NQTYJyrHefzLrE8BjNPAr5TAuNPSCEAHw55",
    "86BuZaT3ajFkmHcy8bs9zbA2nkFrSVgDHUaaJo3xV6G3",
    "86KR52sdSYeSgUjD8DSbV24jNyQ7iJFK7BiSathKkxRV",
    "86Y8ci7BzY7T57nSKCLXUCsgsre4MYA4Edu6rTYre4jA",
    "86gsvxKaiipDzxmmCavFyNnUd3gYwXFHgT6kS6WFBa1",
    "86wH1NsoZtmijKw1ucnDAzChwFXGQNZ52CjUZCBKRZoQ",
    "86wnbVF1FivUhcWvSL3wCjYP9TQBMqiW8Tc1TjjDccKU",
    "86yvWi4LdrZ7FGHkyofKfrEkXAQwwd9ueHz93PMEqSS6",
    "87393uper9GQAxq7QsN1bpbJDDuhEVRcCtRGtKoLYi1q",
    "8741eXvBdZ3jU2WnKmqQkJschmxXK4otb59NoUoYSFum",
    "87QLCHzsCU11ndZNeTzaWBrmknx248VWaqCu6rfz1hG8",
    "88nGat2nKsvW1aarcM3QYWQmxqimF5J1YRZ9LAmwFqgM",
    "89NFDjdL9Kitsz4iwjgTfuPe1Hs1BkhNNFr2NyFzqurt",
    "89NtBaGctVNFsZNX43ceDB2W5TKLVUoK7KuoCFxeDatq",
    "89aMo3VSHhCSpuEUmRaCgdM9cSbQPTSKd9xb8PR4Ufcx",
    "89jRWfwf8b4afgAX4mxhjAbkjSLb2mLBZKqekecXaJDY",
    "89o3tRffGprQooL2mvj7oHZ98q87dEfSrw1gXoL3ovS",
    "89qYyeZA4zRoWRtEhKWcrkYzdwKrgqFBM5iFh6pNkaGf",
    "89zTUiSJ9k1zKi56dY2Y3sVknw2e9AM2V64tJgxzLkRo",
    "8A96soEVBuLKuXLZAWzgtKXXitUg6QLmDMSaU5LemSyu",
    "8ABvDfLac3bWaYnudhc4WF88MphhaU8REKXxTLX8niYP",
    "8AE5k4Mxip3yup6QRLhpkGfiSdQkyWuNntToWq4NU7oD",
    "8AXB1A35Pk5fA7TukGALf2coeLGYYUQxPcVZFaRfKKvi",
    "8AczV8B4pwoNKoXkk57UWPJCodbZ2k4qUEox7Ld5kZb4",
    "8Aee23fz2jgVWSdTNkeYdzw9D443L3H4UwpogWSjA43U",
    "8Au8bU1RJoPEiAPZz6xTPnyKVnWsYx84Hqq8yxMbMUgq",
    "8BL8sua93fCtCXQXHZz9a39ChzFiQDEyowhaCD86Rqhz",
    "8BLnuFkEF4QTxMoFgb2gYh8dP43coEQMa3wotUt7zp6D",
    "8BrqYiVnGY4q3WrgwocRbyJ6xk8ckLqkXkiErGphNWa3",
    "8C2FTuqhGquqx1UTdT1qd6CdsbmSs1u8rdmo2iJ84WNo",
    "8C2iRoyvszPuDv15PoSAZAEroGEND6GKjqEhYZaaZpTP",
    "8C6vvghTvf4N1F2jeUpcazNER4xh6EebdojsnSCDx7mn",
    "8CFYTpkiDoQcjQZTmimU2hDvMMa8JhLKq73Fz25S861q",
    "8ChhxQJXBZCp5sSrjveogYMQdHb6p3trJMmpe7u33S3s",
    "8CrvR3uDNnGZpMB5jHeW8dABFCKjoTe7QJXvps36hx8S",
    "8CwaXyoFVVrsV4oNoDetd4UW1CcqqXJaVsVXqreEpzmH",
    "8D2uAGbXfDYNxEvLuKfwiJLVPLfc9rZzoabpkDeqYYeq",
    "8DGU4vB6Gb3f9RXyPrkQQ2drXTbF39w3MvYL4qLRhVSw",
    "8DHZRMPZKA158zLdBPen2ks2xF4FMygV4rkTSJ3MxFyp",
    "8DY5UJzvwQMwbyBKYQ9AYQw661dTc5Uz6BKHKbVM1W4",
    "8DgbLehcEe6aPpehE3qTkFzQpUJLEWKQaGY1aN6uWEFh",
    "8Do3aQ9T325rixn387d1gNyTNKmLFXwWim7k5mZsLSJj",
    "8DsHUobVy1cHdftsPR97fEvnN22PtnBgSuVQxsGyDkZ8",
    "8DszFwejy8YmR4hamojtboGA3LrbLAs14uvBiqyJQ6E6",
    "8DzEBGgXFUBixjFBtSwMJqiEDNtFs8LYnq1EkBKAiYWu",
    "8E4P2331ojqPeyGComw4y3TBx2roHiGC6WcWdCpHiKg7",
    "8E6P663vnnkKecFTUSAGwrgP3ZmXBh5qXrD7WBRrDX9Z",
    "8E6VCfQJrTKU5JSCr8f9CZnrcC2xXtNe7ughcHgBwt1u",
    "8EPAywZRmidNkKShA2qwbyFnaNd4EbNjnXeNZrWb2Yz4",
    "8EPSqipqH3poiUxW5oGho6Ue2wBihwtSvAcLY9yCGdp2",
    "8Ed1R5MnXtovnDkUkvgPTp4zSBFjBgSYqWYhJWPv9tNP",
    "8FanMS7Mkc1PbnrfaVRzFKz7F54XXb3DPvsSXvt1mVNz",
    "8FiG6z1DucJaujQSt2uCCRbZujvaXyD2w6ULbX2JRtBC",
    "8G2jssBWuGq5JKQoyihb9xMX3yUP7z4EZuxYPDCU9zER",
    "8GBtwVBAeudjFigGoLcTQY67RcZFjrxoQ2hBqwwwu1bo",
    "8GbG2jHjt33cRrb2DHs7Vu3KphRQ45DLjqokZxHWpbBf",
    "8GvxPoFLGmSySie5xdyEsPAdRVFDKcLjVMsPFhNayoob",
    "8GwuD6yBnbzZbno7toHFVNqE3nNyf7KTSqopMGgtYDy8",
    "8H7sn1GMYa1Ya24trDPF3H2ynus6QvVnLJNZyQffU5To",
    "8HGxjh8aosCYzdsKbdKTtgYdXL3QE5FFQgWLS3PTRyft",
    "8HMHfL6M8keM6QHKWii8rR2FPtJfgEyYvEziiqUjgjv9",
    "8HRCj9SkwQ2UHpzQ8ZvEQhssPrVSJsH8mKAoki7r8xiB",
    "8HRK7qjYCKDWr3NoSg8FLq1GKVfTrN6PkYNuKTnEPa9o",
    "8HRfF2PF7vMD8XdSQg9AKLZfm4YAfV9vnY1GdqzPhzPp",
    "8HXz4qAqe5YwTEpvZbkbepVrMsQFc6dWbLQ4d93Y8847",
    "8He2nmgFuPmmEUDs1L5ZMxwqknsUyVZDFLspHQS9Tyfy",
    "8JN3aSnXmgZdK92LEnENp1yAwXZFWC5U1weWcQ43S9Sh",
    "8JUvaKoLsoja9kaCzxmAd7p2jLzowow72EfMMRpf9RsS",
    "8JV3L9rfwLFBw8Dyp44WxG5sZxLgnbQx1dfTaNt56FRL",
    "8JczzpGJMrXa32S1rCQ4HkjWNpTLKmwRASbAodNJPr1Y",
    "8JfGfdBfop3hsEsFtDArcZbewjzfYhfeu4dMRxgdYTyn",
    "8JhW1FuLL7eDZHVvSmWXHwGBHYjFBQ7mjVT31AS8bgRN",
    "8KnxQjnKZQuhi8DZ2kA8edsGPr6oc2KQdQu9LbpNeVdQ",
    "8L39dK4BfakuyD3xBwfkmsupdHSZFMEdJFkY1gaXbj5m",
    "8LBLvpAXfceuQz3NoDsfgyRh4u2oKjsDrv52hp6rnH5U",
    "8LP82bVBjmHHdHyxWpLr6B84etyDNqWELz8NQ6R2sMHF",
    "8LmVjB3qHxikp5GeJkGhpEs2hVEHWxmkpcR4eX2d1dDq",
    "8LqTWVnuqo1iQXCn8vH67MrYXtTqAzZqp8sy5jufLbpz",
    "8Lqye5jb6BgKXiY1WESW2ujoWzNEUjj1LLzLXZUQMsGX",
    "8MmHwF7nXQTSDjfkuAPwBBfLgVm5UaManMNZNQo6SJr6",
    "8NT2kYsD5KG5eoqpDt6LzwXFJqeU23RmuxGUE4EDzUFg",
    "8NUL9Vs9uv85NfFD1TZb3Qt9EsbNDWz5tJ9Az1TgNhuG",
    "8NYKB6EmV1NxEf8ddJRNLxQjE7L4HkKggZpMcJ6XmHjw",
    "8NYp3XtQWp94Ztbap3Kj2CVz3usYAft5Ct3Rk4P99t2t",
    "8Na4sHYgaZBXJdCUuy2La71nWWcF5GPqj365b9FAsnGH",
    "8Na5Mdz11HGzWa4HKHwDuMprwS13igDJQKopmreHidT5",
    "8Nsbxi2dZYxD5ETVfERdMcG9sodps2J3PcbyXvqqEj3G",
    "8P6csUcR73DYocrmdQpZy88QmUHmx8CHo4af8Ws8pX28",
    "8PAKCM4WoNZ8BYvXD4scorrdJKkYdzay8HFDSPwFzxmr",
    "8PUkZU1oaYnYLzP5nEuCMYBEVH4DZ5DiRHt3cRd3q1CX",
    "8PhSRWep3YYA6c7ywfNorvvc9zbwmtMgnMK48KJsT123",
    "8Pr6N4puu1KkhwRq3XxvHMZweY2Ye67e6SV6B3dUnKQQ",
    "8Pw6TLCuEF4Ev6KocqoDoUxjLAsvzhoXBtRWi14smWFC",
    "8Q78XLCcTkJNU1qgCcJupxJ8Wpn5VA2vr35BxoAXyqFi",
    "8QHojHor6mQA1xhbJwL6iBLunVqVhX6tjpmD3P5Wa73s",
    "8QQ3RN36Hin2V8jqf73spXQ9AprEnvUkThZHiSeHMEHb",
    "8QRfnQAQ6nVUmutXuGGvk9Yz7vfMzYov3nxaP4xuZbhz",
    "8RAx2QZggKvAJyXQdevu12eCqHKNUrwmKnUu9iGUhn2T",
    "8RF1ecvz3yBVrpZbjXs85bE8c46MWx36GCHbPJhBbGgz",
    "8RKMc9H4ovPahDkExodNF1wnJumyKty6MSuxR12b19Si",
    "8RRPCgU5XDUUBKkfY3dgiSkUsxKJHM7p4UKq54VBk5E4",
    "8RoZida4m5CH27wKD7nRpukw7UP6Jj9ytVz6gbfMvBCr",
    "8S1RFRqwCE22gt5X5QmxpRBZhNUV3Z64pYb7K7LR8ewe",
    "8S41e2oDurfhXiWzVegjf1y19phh7vrWcYAho9k5QDG5",
    "8S62w6N6QBn8aTbBe9rx9mwZQ41P3rLYn1JpGYftQFLG",
    "8S8b1De63cfiz5pXnt519YZc7EY1oRv9C41GrakKdBRZ",
    "8SBn3iNgLT6zqjNSCEFGvFnGeQ4ZXcsh1o7W3jwyoux5",
    "8SSUC2Vp1E5AbkKar2AihPHBB7otSxaHbjfD9vDvV1fc",
    "8SXadR2uisttVHWaDBczYuDnwvCty2WqPkJfQ1v7zRCP",
    "8Sc9R84hsXHGydHAy8kua9LiHsBRovZtzBRbTzt3jqVK",
    "8SoVktWWZS2WMNT1L9N82ZpZuZXwx7tJCiCYPXi3AiD2",
    "8SwWXfpYTVfJX7CocEsf1PzVyKASgr1X2ATrn2LsnsBk",
    "8T4Qi9WZKi9BLPWvf66VcRz3cj9BgmaPXK5YXpHJ9cui",
    "8T4jzXjmZCp85PUjmVWH92iH51MxqTqFvHpVG593KryU",
    "8T4uBvGqMt7wzHeA2A4BbZ6FugQsqsabdexu9uNQu7Sb",
    "8ThsZLnAMXa3Gr7CBKQd74qtzo82qVaEtW915KZvFZuZ",
    "8UL9FWaapQmHvnbQzxztA6U9XAAwKacME5a7sNUMsjPw",
    "8UNX4bsa6dipGtAfNSASeZLA26dBh1EcENkurRVwh1SV",
    "8UUmHvQDMsMFQVqrpH5PckxbZYhyY68NJRXNgj6hi1Rr",
    "8UYnMcqTM7QkpvemU4RPDG4FRpDNiFd6zLEkqmdjstG8",
    "8UZCVHmuHhKn6xrdpeS7zX9ntTogt8y1mAuHDpwXTL1p",
    "8UZUh8ErUi4fmoFVqYGH82T4hLWBGmVCskoeXXYzKaPK",
    "8UhHhQtnKnSVv2x28q7XgV8tZTvfKqM3LAdJxcSyrwxf",
    "8UjurRMAGmEpY3nfKLohckTTX9V2bgRGv1KUKXBAA6in",
    "8UvzGZa4GFBkKyksAx3ydzFS4CvFZFkJVH7w7fQsrWD1",
    "8UzpBjZiRX4QaySBULtvephkeRAkBjb7CyGDBJaHN1VJ",
    "8V36B12ynBS3tGahwh8chdUMAKgjArL1Fry3FBVTCq1Q",
    "8VFqUNZQ9SSRb2AvoUG4ooso9QHdbT2qZkixn2koG9hf",
    "8VZx2EbAYUSqW3LRHxvFnt6q8Qx9XtCUVneGUMF6iQXQ",
    "8VyUMrHsbbseddniPdwqRko27X2xGc4pQFAnffq7YbBq",
    "8WFqGiw2kZH3Z79mZxkd3R4GEWuXxd7TWb9wWARZb5PH",
    "8WQ14WhMyPKvYfomhUxHXzVTXeW8o6ptVMm8qtSG1tMG",
    "8WXF2peP3PM1dXiY7mMphWAwk3NBVnM7LchNPNxTHiEZ",
    "8WjWEhgBPdR6F5LivCQFCF1SAtEie9MiocnPUMqkgzp6",
    "8WkeQChAgJcDbMYya2VXXZs2LHnqqE9w1uWnianKSszb",
    "8X37EAM22u1rBLdM8XzX3UZX7N1B5X7tKRRpVMJawaA1",
    "8XXjwbBsqBs2s1UHZkNDcqNQNPaCjUm1Buwu11mD8BpV",
    "8XdCeA9JqQUfrkUhAjYoCtFdPZQ6RtdChUykbn663Wwf",
    "8Xq9hanBCZhk99gmbHjNuWUimV6MUT86pv9fg5C1vTBk",
    "8Xzng6qS2bQxfVehUSnyTJoNU82mAAa7ffXACrp99p3F",
    "8Y3t4gZeMTopH8G2RyFzVncqz1E4cTh6MsFCN8m27GpN",
    "8Y5VW3hwr9VbRHubv29k65y84rLqUXuoFCm4KxjM3bPm",
    "8Y6Tk8x7TqnRP12pZ5p4ZRBdvmtmECVyCkMkME6X39pe",
    "8YXujSpHM9BqFQr3DpVKMKir8CTvNQ8Rd82soZwC1qBT",
    "8Yi77yxGBxABdNPsTHU2YxpS5nJnsjJvhLqCcenYKPXL",
    "8ZJNAkbagWRx6bF2rvM173MjSJhWiqhrC6BESeXgC3aJ",
    "8ZJhYBNdp9631fDL72xfUQ6KXcme1efdd59urgAQ1Qfj",
    "8ZPd5jBBuCa8a4iNsLHhhkuMAP2TMbFWRH6LAZjiUC49",
    "8ZQAmUKbQrTrsQZnrDQUqiBGgTRgUg4UeUizzFqZ8KFq",
    "8ZQq8ra3CQXHZK8QbQzXzMNXnRvVnNKZXLUUQHQh3SCf",
    "8Za279etEbpxQchFFR51dex412z78gPkEc44rYuDvHtF",
    "8ZaxjFkt2jFu5ZMu3esmEra8zZQ82nLUu7Q9swms1SSn",
    "8Zk9qcg5M346e434rFBdkUYRjin2GofVLXTq6SaTpWhY",
    "8ZrW48iYECZ34TiGYMgHpreCwyZxBJCSVSQiMC2YcEtF",
    "8aDbr212ctaVihAHPyBzLTQbPMiLXzLwX4ekEoJCXDCp",
    "8aRK1KEKSs9fEAawbUh8sb1uhPFqV2wmYJvrQUDDAciM",
    "8aufb5Ux9PyQWsRbdmpFijbBkZWTP4hyzQtw1DY8bGym",
    "8avBap6LxRX1Upugy5WJQuk7WrvZRPbzvzzT5cA9oK7K",
    "8awXW52NPRzsipG44LXuFGWKT1xQMeCmrQUV3TTHy7Dw",
    "8b7igN9kP9XNgsCfrFsWdAUepEeNw9388cwxJBp3hE4y",
    "8bHy44tTxfFRDSjUmsCBy4dtmH7DWcVLLvSGFRMZcTYm",
    "8bJT1DQWpV73DYv1TLQKAregXCaD57E814eVWYUvPZeR",
    "8bUTz9a4xagtbnPwaAvXQovZ5xALSmHz6WN1ZSCs39f7",
    "8bcyuWktZD47mysUzufZphn6JXcN8hrKLz9K2DyZDiT3",
    "8boSGQw9z67yWFS3Who7BVg9Ho7yPkEUNHf1KU34pct4",
    "8bpNXyTzGZMSbPtoiKYoP3NNq2EvxGLxrBktYUTBokwt",
    "8bqsgCze8fgbf7CGHmLT4Ja9Pie133eR2H3GEM37QxNp",
    "8byodmyWBH43b3o5LmtZ8bxhcSt4qR4JRQc7McAAST1F",
    "8cBeNiYKXJPKoqjDLgtWNbc8nkzyudAfg6anNoA1uMeD",
    "8cxdHx28gC4nJUBTMQqDutoxk5ARXzpZ5nyBTY234q6U",
    "8dPKinprdD7WGv1om9v7pPSmYWqiNZHbF2iBfm89dg2W",
    "8dQA9i6fcDn242fvMDBcAFVHEc2KfX1atNVr4qtWrwKC",
    "8dRkjVYD21f2RU12LM3TxLsiP8GgcNLw6haAStaT2roy",
    "8dfndkvgSkYG5cfgp2Ps2Ru2LTgKUPuFpy779UMC3ect",
    "8dmhNcjPWZ7L1KqrDTNiM85t3Mu1iBmvzmwJnQczFmEG",
    "8dtx7tWXeEFJqHLiUZZfw3FAvoe53SSP4URFqEWpAqmQ",
    "8e19gHSTvqPg5Cqy91HR5QMn6xnGVPM4UobquAuqYWPh",
    "8eca564Zf5xG5BppHuPoYY67EfxxEMQmuWK6tE4uyTzt",
    "8efQAJ5jBUV69X1bxqTuaFqJqnrbCoT4C6fJYJRyyRTm",
    "8etTHMSdTKBfxPMcBbquPjAU8Mi2AK9aWG3UVJgzS2RM",
    "8euGRhAPTgVBzE5nLTKV8uzynbaVXCsFPjSexD8L1nAR",
    "8evwsuMrNPtPeknKJrigcnjeEETxVVpUWS1sLfWqW64Y",
    "8ezxjeXWxHwp1jENqQ4dp9TJagJeGEiDN1k6PhBG9Gje",
    "8f2HZJ4D9mhN3Mz9VN9pftRmAoPYyVSCcfKvFxCn3zPA",
    "8f34nrEQ5FcAFx7bcKz1gDzAqqEJy4ZAXy3D3A4B4FPz",
    "8fjXANzchL2dNj87MKbpsBZSScSNMzj5HBVe4Jm1x7Ys",
    "8fjnrshyvuFYBhpUqwJgKN97sMFc3rJK7ZtaLhLmCwUe",
    "8fpZVAvhs2TpPt4yhccKHF3iMLzBdydJJQbHKuHmEV6u",
    "8fvmeFbEwk8da7VE7VXErvEHq5gGw2WmCzpr7bKN2Sgn",
    "8fx9fpDBH84RFVB4nguDsTaZ42v6vgy1cdpBCzpvx1vF",
    "8fxYssdVuFvj95Y2Lx2UqKTBKZ1U447FTJFUxVA9EbUb",
    "8g1rQKr4uCVbYhLCnhX9bQcWu3pgNE7AqRu2jvUix8c3",
    "8gKHgdr7L48dtsdjjZhTWzLy7w2XK4qh5F2xNVAUw6AM",
    "8gLpbco1ggwzkd6FYJh2eGBf2tzSpXZoApnrz2JQsMDC",
    "8gYSgbGPZf71wxD94bMmMr69PVBXNh8qjAergWt5D8RD",
    "8gjHviRvsg9bdKQQBSNB4rfRkkGwbNthPWz4H5KyzXRL",
    "8hAZaCWpVBaN6ErcDVXMZLN59X3F5ibKpvunmYzody7b",
    "8hHti4ynkUNBjkoG3WCDPhAqR6BhVg1foaxsQgWi1uPN",
    "8hW2Pd18gHCbsT45moBYFwgmxZ5isgSNWxbhKEYGaZBK",
    "8hmL4keSBD8axetzPzF2m895Q1pPwpfcY4oGVBXYZXhX",
    "8iVS3wKSNXy68DisgZj98H1kYxSrqHTftL1mjDxJM7J6",
    "8iVxL6BGAbovc8Pf4EfPzFYbmr3sWgS1ibQWuJ8K6zbR",
    "8igHWc2HPqddxtsFvvikUtbo39AL8k7ACd8oxdN4CWrv",
    "8jhVdEnS3hMe7DtfKoKmEQdLHJBNMYd1XGk7EzRiiqHu",
    "8jhwB2JiL9L9pnnJfmJkPjYfWurCeH9knGGDatfU8JNu",
    "8jwF8oTjuF5KuZ8cQdW7VsHdVXzhioSyYcSgiEMNqXcP",
    "8k5kZHgrVYepgA2cDNaDHK9xmPJBA5PXPhuPusvktcPt",
    "8kZ1jcV768LFs4Ki7Fs17KRKNXWNzNhmDkbg8vKMRrDL",
    "8kZma8zaMHqCmV9HUdXEJtchxeBGHm19ffxPb3u8osm7",
    "8kcDwEMvUGQVu53Txr6wALAnw9GR9pZGbL1PTpR7ovSc",
    "8kyC2g148nXfdGvYzSgoutFUJp4CjBUHX4jFExpkvUsX",
    "8m1nEueUMStiQWUHBDosLco6um3pETZ52kjLLSuQhz8c",
    "8mRLGTEgLXaehsZgUw1NRTEznE1mPzEq5xpsJD2UVRAA",
    "8me9AuBVbAei4cJEwVwcGx7hRy8dGkXitHnM6quBmNEb",
    "8msBmLEr7Wib6MHcNaht91AXuK1pKjyWquwYWGTmFpsh",
    "8nQ3VtbvA1QqbFnxfaQiW4vpjfCQretWnguajJLmuhiy",
    "8nUpHXHiDzPasZMU5zApHP5bU2WZju9RpBmkLw8DfWhp",
    "8nnya5gvXukf3XHSzaGnogfFAoUg98f9bXrqnnusaC1d",
    "8nptMufhqrot3QNNAnsLTJaNk2ndk6VdFQcL6gAGGFsV",
    "8o4KaWibQjbxTe96VEFqhUP9KVWtLsJhvg2iSUosf1vc",
    "8oC8N8kTeyyAGFpYENzJVkVToXKvSGZGs6454qnDsqFS",
    "8p2eTi4TxfaKeUY1Jc7R8CzFVVsD2jMZ7J5NFauqQs44",
    "8p6aDCXf9ZQW5oZPSWDAXHcj6yx2kJbntgqyRDCD7dnN",
    "8pF7CwaPCK3HEN4zSdWPEhX2k2Rh2cZxzGzJoUesLuYT",
    "8pmHdPy9PxtK1uhwTxeYqVUmR5Z6h9x9WoHYf5cTZXCy",
    "8qX6kiUFE1v5h2g98rHmHrHr9ddLbNgFCajtroHSwU1H",
    "8qhZMzUkCPYfdoowic9MbAoVCFDRtw7NkaC6RAJsfE8z",
    "8qoFUv8jnqzUZQnpjLeULHiHo7brTWcC5LzFpe5GFPP5",
    "8qq77ZhxbMokjk9SLPpHsmgwQZ511QcSaaefq7k1SE8L",
    "8qqsBqkDtTE857Njxiha12RicnVWapwk2XqEHb5x2nBh",
    "8qs294SUyvR63CwUxq7EgA4Q82t1J1k4KDsHTDz78DsE",
    "8r9ivhvGXTx8LmczzdtPtBNrkmz9H3cUt2zGyXEhrNQH",
    "8rHsav5ux6nkDb4SPob7UaQaFkAtt6GsrSPrZrmFhqbc",
    "8rmFFqnQxkqYPKtXsLAaEuRsizWkeo1qkdPxdAovDBdL",
    "8rtnknyJSRYcjvgiPRG9Ej8pxbT9sQ6TMi5S6sh44dTA",
    "8rxPss2dg7iJp1NmWUp1DVsWWZavA3koKqhAHZ2EcQ2S",
    "8rxjMiVAyoAgmYmzmdd6A5ZJEup7w1rns7iJmKvsjxxP",
    "8s9xz9yGgFkbgVRq3sk1psafKbN4qDkCBYspVnQV861w",
    "8sJgt1NNwMVU6oesh6FDC7uDZB6a4NhTrdHSJQjSsHP",
    "8sSEakaJcKzi8KwdybHz3ZNyewsgKBpyWYUAzpbYrQwB",
    "8tLqe6NtRuNEMZJ3PofFEv75aLyS55CNwxGCgT1Qf1aB",
    "8tQMtvuoa5JZeoQbq68YzGuFLUVjNkpwVbU6hKYL6dzQ",
    "8tWvCMCFcDPUMejqtNbkz4AP2DtGa4roQ5Tg2gCxyTo5",
    "8u4UCjAJJWgmKTgNY2muqAaui74JKKBxrQimTUxfU253",
    "8uFhNN2AvVWFu3xUdEWyHG1iXA9XA1NqkPSkwaZdsGeW",
    "8uV3ZnV4dbn1aTJZurYekgSD8foXUpweKq2DLVW8JYJn",
    "8uVLmRHedg9j9m41xftYvGYTw7wmGugygFyzuKtNmQv1",
    "8ufAgZJa4Yb3DgX9orTpCj46qcPpDk8p4xKdkCNbrBAx",
    "8ut5pFZFDunREhHfZeBKg4zECb1wQNiw7PdNhANjKbe9",
    "8v3WWygPAcUNVDmYB7qDpfrgctvgzhbLz6v6YdSdzaVA",
    "8vLNGQEYW3sFfY17R3e5dKGsNV89yaQj4tE8CGBGXKQW",
    "8vpAh1LnpCYw3FnQnwrk9DczcHftqMw838Pg5FcqPrtk",
    "8vtNqY2g2aZ5T1JHDzqbQYZyatxGLpam67ytVK9Z5MSN",
    "8w5rTVr6aLjGW5JfDRNnG46dNzXMThSy7HSbxjGeddTM",
    "8wDZCRdbcksgusVDUG16WKUYgmm86Er9WcurnkNwuCyk",
    "8wW7Z31P4vS7PDowcdEDrRvV3zspYSHBmkx2fiuY6WtZ",
    "8xCgPdKJdCeo5LpwgurNCoBE4zVrNcqUeCZG1U1xnADy",
    "8xF81nnYEdtme6tn5n1FQph2VX2xoUgEhZ4wcH7beTA5",
    "8xUrvT5Swbo8QuoqnH2DUP6GkDGe78R9GzZu1eCoAQp7",
    "8xtty4TVzRUBqGzYopo2WduQFp44wyG6zUZ8tQrRrgLL",
    "8xuPuwcc7wsef9MFJPsa1ev1C9b9QfE5Y79M9Sr1WDk4",
    "8xxCLVuZAN2HoHKjUhqopzUXDq7ak7xo3YfqA7zG6iqd",
    "8y4ZUDdwDCkaJ3kPJ3zPFFW3sc6VbHHnqEiTeZN8A8Am",
    "8yK5qBkSinwccqvo5EQSCa4GDo7We6EcLVQKLQZQYatk",
    "8yddgEvBxWBz6goC2TDDLome6c7PEbv1CFmGTMWLH3mE",
    "8yeoJcbVMYsLz3KjB7gHwfrG8aUQ6gnCZeurB6bXuQzj",
    "8yjRuqpyvg3kVKdTuPP73Sg1VXb6NG8TTRwCTKYpDprL",
    "8ynG9GQjuirHdAnNokTu4eKGpsJh2fQVdfdCafFQ7epD",
    "8z5V486iHvNrMfpW2495tGQ3oFTtzbmAru4SYyQVCsuY",
    "8zXVoDSEztmkRJVcsWEwtFMgVmFrJLJAFd4bvmwYotMZ",
    "8zix78jKKVj7rryXTPVVkknbPKBea7tBmdgYgfsjcyxy",
    "8zkMTpvYBtTrbBJgcDhEnATv5r2eEiojQB8knE2EAbJL",
    "8zxWCbeEsjdRgZGFkpBD6g9N1EqYzqpipLXyL5ZMaYea",
    "8zzQmcUKkniz3go7SbBuPYEtVd8VmAyu6vhpotFv1CTe",
    "91s8maj4QMWo9DYye3fYFXDvXshgCdKVcrRhc6ZcBgz",
    "91t3EE2S17csHaEtTwaKWyarFfUETwuQc4DXaPchSkUF",
    "91uuZLTcCgCeEdheSx6Bz6vcGFRSPwpQgqxZbCjPo68S",
    "92UjbJfLZ8HQDnWoP3jyXoSgW9T66r3c7MsGQqjJbmty",
    "92YcU6zUPNLQhSfkADtU8USVDXuv73J9RGuJ43hXpxR9",
    "92pjvcKtuCYfZTMHnnwM9pe6FK8oHo7WK74Pe5w716mQ",
    "92xNWrUBBXDNC6LzyYLDPXiXjHyiH7NrPCSFAFvjrX7c",
    "939ewGVY6mcTk9wNgiHxW43EYR1fZoiwb5uSPtrBuwp6",
    "93K7GHZp2h9oa1yb8c3LA4s4TwaYR6Dzm9Ug7Rr46oHv",
    "93NTx2tpV4oz2YHUt461jnQtzRFUuwGNoqqjWGnr24JM",
    "945eG6vrSU7sqRiSEAhRvSQNVzPiJBXFEGsycKafLRfq",
    "94k58t3e991qsbbgp8Ud6MzZBe1sXZXb1qAv42UCy4pS",
    "953CYe6Md1oNcWYK1njQU7kvKTwY1cE4VeE3fsRiVwG",
    "95Ht7Nr8FgCu9PtMGbbzn585rGDEHTbbqqcJUPHWyQs1",
    "95WbwAKdAXPuEuxmZNfi4WYsnfi1i1uJSNaCW6S4sL8B",
    "95YuFdTgBFwJ2wp5wjjUG7HqbgGsY5xd2Mn92BWmH7H8",
    "95hZ2gW6fGeeFh4yuqrVq4euk2LPpEVaUtvjK8ZgECGe",
    "963FRW6Af579SHSEkPzw8FJJp578PkQesCf99mw6H1X9",
    "964y1a5uDimGjJqRhVBzfc9DNutf4SVconWXMFxdU8AG",
    "965okEgYonnCfRH6xXtVyRRzj26nqt3BiM18RjuhCJfJ",
    "967Gvbnzhj3BTEEb7jtQSiKqv7mvKtSMLQy91WrMPHhD",
    "96BMYRMk4MjFg115vHW9skzswJAaq2UQXrqhT3gYaJCS",
    "96FpFZYDpiHbQoATQDJcBYjNBXqfT8JajtWRvztRmLKo",
    "96LKLcyEcee8CPd5yzPUtuLSLNphSFbQx9qjxuEj4uie",
    "96ciDADLKv2Tug1HJh9k9mtDg4jn48ES3w5fbhmoezbf",
    "96pHFUPgX5DkaNkS4NNB7gJKaaPH2TChqV7td6G38Joa",
    "96svCDUFTEeaXBMdVqnHBtwQCaNWAzNtzBiXScQGSqpb",
    "96u2vRf83mUuhcGFcEz8s8a59YUsGMYqH3tsdPi2MMmk",
    "97K6kdLS1wNwiT79tZb1aapKVeWoH6uvMuUgHoiGz44B",
    "97NdRhCZV4rvkTfKafpSXCw9DBXo5ShN8zffoXYZXabB",
    "97QBFnuoyPtwsH3Sf3KRA9KxBKBtxuekwzgSKViVkLVY",
    "97Yx31sEL7qf9jwNw627qhRzGLny79x5N8vkFu9LJAy1",
    "97be5zyxwrWYxNzRye6vg6K6bDhqQQ2dhsgJ1yTCymEP",
    "97maKizgcrNbUss2XqScLHRe3cvgbn7HDM5MT3VwcQnK",
    "97vjG4PYN9NQT5za1Bv5Qcwb1FJcjmPuneVYkEH6TN7o",
    "97y9EkfKW33qrMRscNZiWUSEVu2P1Sdz7tEpfkdwU2nx",
    "983WkvgMXBdWvprb32j5yLqaqV1wnM9idz9ZYWcJeAs2",
    "989D5vSzKXM82cgLrEaJPVnD1WatmrzfmZmVw5HfGgX3",
    "98JeKoiUwaNVtdRJEzaTeKbpKDMtbHRSH6VUpqKH9HvG",
    "98QnUBmTVpd2A2idmFzaPDKkWvAJEzABhTgSjcQ7rkFw",
    "98V5FL88y8ibpRVyxqEH7iLHSTPQVWcBFJPkSSeC1uxR",
    "98VjC9yxUrfAp22HGqqPt4EJkhhvRb1z2p7inxi9Rmzw",
    "98Zq86MpkLq1zf8XxHeyKB8GAKMzVAF4r5bGbWRdDweH",
    "98kHLM1ix3cDxuMGFwVdMd7zXbw3Y4ZsEUKZo4Qy6TGJ",
    "98kVt2NQyH2qKgpqg5atV58vzBAPwpAYV8umofv6bAUB",
    "99144B76DCtCv5JbUdnRJ9EurdG3Y225FVF3pCJXmKaP",
    "991MUk1QUgthjAcMtppasSbPotV3Ftr7qKzpZKTjCa38",
    "99EFtFjCTdo9ZdEX8LgLAdhei5s4fULL35DrpEpg3Sqk",
    "99h6t8wRL2vg3a43xVsrXKSkygQpnzXEbPe1t633kVG4",
    "99im7aeCoFjzDKn4ENShLCSSZtXumicksgZLubkmmMkE",
    "99p6QZTJMWUP13mrDfSjf2QJSXxJis57PuFXEbgnXjY9",
    "9A4oX8WfxLkxdBdHNA8vFWTeYA4CBzbAXUsXNFbswSP1",
    "9ABTsD1kVpLRqMDi1qtHapqieBVnB1rqZbRGUZofLSU2",
    "9AWE2cWRTp6DhAzqJuEA2fdNM7sbxvp5w1UEmeThY1H7",
    "9AbqeeKsesqpj5Q1eZFkFkSYuySP9oihuaLqRbj9FC8w",
    "9Acq6rtBaMS418DRF5oEmR5F7tNUcqtheJu5u2hNLJon",
    "9AgkWacLBJQB67228LyJwpQcUgUk9RPUDZJUprKQyCke",
    "9AqBuVUC9vNnQX6fJ35jRz2hdzAurQaqGvNtUMK2oPsh",
    "9AqVoPpEmm34mYMAReg7fWH2AR1GTtds52SFXf3hbz2q",
    "9Aqssa7ZRxg29tPJDQcKSoUXc3FfASkRgNUWH6v5dn8d",
    "9B1PSYdSqAJHjZodY1cBJUHyXmxqso2LpENoeuXCbgwb",
    "9B9xAE94xpEcxBEkwWTYnoAaFcjuSDwdyzmoKzh39BuZ",
    "9BCTMK1a8BA84YpPLqRErvLQnyZGZu9NiXyFvV8dCpau",
    "9BD9UDx79Ei8yCVD7kmTTvexVWEMoXY3m2Yd19Zxwohs",
    "9BTZRn4eQmiX6CTkpXCVrRUTA2nEBczHJvo1Hz7xMpDN",
    "9BeafWnos5xmN2mZQVSet8egtvE9L9uWNXdH1e1qVkmA",
    "9Ch93DSC9UT16N9v81qEzMLBE1jtMw116GYu6rNKVhsM",
    "9CjziwruzVLz4hHJoqtSMvYQ4ChEumSvvf3dbKSvBCM3",
    "9DPbhLkzipyr5NKh69X8drxx7woeTtJVYpDc315f31ff",
    "9DTZbFeb9YfXxVRDk9xaYfxyV19rsYZNR3TymYXwSRuf",
    "9Ds3DM9pHnSfAsm9QKaWzrdKbcmWjWERUJ93hUGMMXPf",
    "9EPytxZv4ok4ghbeJ2VeX8Ee4sTpG2nn95bzC75US49k",
    "9EQJzxkeLQ8RJNfsWbGK7f17nqZTR79suHB8r8bPFMdt",
    "9EXR7F7X32au3S1aLqhqQAvhRto39XferWfYA5Ff5Uds",
    "9Ea9p4FNvM1QhYvNT8mkYgjLU95KAC8bzR95937aUjE1",
    "9ErV45QnuCkEdGKm75ovLA6HRvdAWwwQP7Q2G59XxGWr",
    "9FFFCA91Ug2o7SuYbVVwUVttUG87mVbG9gemrg1NNxhk",
    "9FbreQSpfaz3nNhRW1bWRxUjYcLcmSH27jdWi4e3JLyr",
    "9FhYVvM5FZt9318pST3wZgLipak6a8spUSysRuxtRfCF",
    "9FqaVaPqddF7Xyi5UuJGyc1SeYGcKL3GNVDf8RE6WEy1",
    "9FsiKNvuVEcvEF6EKA6uyd1cJADDb1mqw79iaYCXbccN",
    "9FuwtLzXvwGcVG1w45Ho9ihWGqmNDiWYBFspLgj4EBPQ",
    "9Fyd8iLVdZ92ubG9mhJgAk6TXFBbWH4opJckJo3TPZYE",
    "9G16mcpQNwZgfic7TjMLZcd61xJYnRv76BZmEm5Ri7UJ",
    "9G1UypNtNr89F41RLAynm2tpLDwnhUdnb2n3dFUn9sX",
    "9GNj4sYjVtpEFKZYy1BVW6mgbNu58a17gNHC5S3mVoZT",
    "9GcEqVVkLYf2VgxHsoYn4FnZL3yaLW4TomZT5GVKrtsw",
    "9Gt2qU4Ppzu2ZifaQAh7WsgqqjQtuckws3wrCWYTmsGq",
    "9H95446QvJ1H11iG25tc9C5EcizTSrXGReUbrdMGNRsJ",
    "9HEPNhaRxGGqh9r8iduD2jNB7yyBt19gtYWcPa8NNM4E",
    "9HL8G1zs3aHkG2tKJVSnm1MyHCKP74ibAFNPeRm2NiD2",
    "9HWiQhuED61odgKbzC3jXyKN6qDcv4UetmkwQvPfrDZi",
    "9JQfDfVL9uqzxN61Pm2qAnBUZuumYksq4DTNQzgh8C2Y",
    "9KCbgJEEp3Prnj5nzV4ixL5oGCYF7KqUtqojSakESpyD",
    "9KF5QX47Rb4Q9q46Vih8ECBiV5sHoT5JKNp6fzBiVzxh",
    "9KMYJsAycExvfnwDhcAtUuYAYjobVHGZrBe7SiGHuDe",
    "9KMZmoMAwqhHP1r8B5MUHuPj7M9JjcR596CcuuDFkpvw",
    "9KNLVaiB9p3QBb9i344o4JSSDBPXsFgJSCSqsN2QaS1g",
    "9L5mkaTxBsgmJnPACQNiiMkbbc92EzeiD1SVUMoQgALB",
    "9LeiFGqPVNVnxwpqYUJuRNp3obX2eK1eSX3q4VSahoFP",
    "9Leyh2zS9yFfiQEVdwxiaMpmVuzcQmxCzXktF25K8U89",
    "9LmzcktwqrCgpdhtoJTM5zE2eYuqCPz4LDgPtxRnUS1K",
    "9LwLddmTUZYrDKvUqZtd7AsWKo2CqHMY6bX8hJvh5Xuj",
    "9MFYJXprVtpYFznG8drK6NhX85mqd12r5ccdht5QQhBX",
    "9MGC3U5LFh3ZRaLY65MN5HqhwWHdvUNfpYqWeyoVmAkg",
    "9MRLd3VSMWeK6aCVU8V6Y6erYYDVSf28nKEBpf6B9MrG",
    "9MUKukYWDgXYJPgVox7mdDFRG971hfiS3Woxk1Rw3NMw",
    "9MmFWGuq9GZJpj8r2MPS1swueygsUxExM7ZtaoyJw7kc",
    "9Mtis9hCLLQVjTkmgW8YdP8CnSzfipv6AdQQwZdfyLBb",
    "9N3wpS1PwuAq2QYGAvDzxwgHAUbjwssf3UhJXnNtNGbz",
    "9N4QMLpgerYMwu6zY6DnnhZQqY5CHEoBGfgYjDxnD6H9",
    "9N6uSjvc3z46f8fvoLboCa9s5WwzcUUrY6AyrtbWcWUh",
    "9NBrHkg5DKGBcrx3LF5beUb9VGd9tp6N6eqmZRn2sskh",
    "9NQBBxjwwBGPD9xkWti6GWLDzkgNu5g8d2BAXCF3hosF",
    "9NcuySKYSVNv9dWdcmtccZj1DxM7K1izQmmp5wvVeG9i",
    "9NesKC4oa1Tdo7Diwbf2WdeUAwc4XQq4s636u8ufTaUw",
    "9NoRCXcytUMThTBeAxS5VatySU5T2QFZj7bxVDBY6Yrp",
    "9PJZAr9wtFC1wJoVf4QifDEZjg7d3CNheDCb9wbhp8uZ",
    "9Pdfp3WRjJGEVGM6shTpmMk87uHkkaBpZpjtyyBTX47m",
    "9Pi8jRJxdHF19YGyG35wbPZsxC6cp4d8LaHbo28BjAK8",
    "9PkEjm2LLv139XLfEf8tRFQjEP8XPTYqsv8nSLoNAB4u",
    "9Pn4sV6RCtugV4GjoDTnpvWCVSWQdWDSqgQmGQYR6iGb",
    "9Ppqcd7VSHV99gNbByUqtpwwyp3qMPXkP2pD2asQLsDa",
    "9Q5Nb4DfxBTjguDN5xftb18q8kBF9w3tfbR8NBikThLN",
    "9QWTEcjzW5mQVC88NTDhWUYKRUVnWpv1WdRezCk8WME2",
    "9QjfKKzTFEpJNhSSZHbcL4KUeurBTLn7GBj7dXoscEm",
    "9QknKd2VnMEoRJJBzs4EvQbncvKWBApEBesdha7ffLLh",
    "9RHdczPB6pxVKm2GvE5cbBD5wzz94H6JNQc778t8rvYG",
    "9RJtaUtKp15AajvHDZCHLAcYfCZdAZTm34ji6rUXzFZE",
    "9RaGU2cxNj4KA3ew4aRDXqM1t5Y7YKnbrpuq7Cz7LnxS",
    "9RgjFA1AsoNDbemmdVb94fS6nvycsixZ138U2qMHa217",
    "9RspiA7iMaqJouGJe2AWfWneFpAWKPUASfkGr4SDD83b",
    "9S2mwDoekF4xgpo2df1Ri1VN8h1k22MH3D9YM5dcCNJz",
    "9SAZs1dYihaCXwBEAPjyhKmG4bJadsnJfobG6Hy6fWWY",
    "9SCEpuYusMHP6ovtLzMLKXbBD1HPShjBZfd9F6APxM2B",
    "9SCu4Qx8FTvJh7QjjEyWpjAWhMGZwRN4J3TPais56m56",
    "9SHdgn6NV6SQ7Qe8JjMWKcYKMJXknCFsBqEVYZwBPkz3",
    "9SKGv2PMkJdMDPzEYMkw5mgHHk2FJ1isUJru2iqT9cPt",
    "9SLPMewizGsfTY1DBsp2PCgJNBdfqEgw9m9Pag2xPuG1",
    "9STbLm6tcoeJxf2un16susBGWpsEGkPLSPefKiEpFJcc",
    "9SWa2eRrSfjNmoL6QbzJYqqNTFAM8AfNQJeLhrcwtDEB",
    "9Smmcb1mB5MujUJXMEChnEAD88ik9r43FrAFExu2G3Ra",
    "9SrJPSKfvTiihuMMXKrsXnYJxn9EJ3RkpAYQGMq6dYvM",
    "9T2rRNQ4F6mpcUipYGV7FvAsPLr3YKfBLdw3Dj58ijqf",
    "9TKVXvTJxQAbYDCvGcvnKBNnBoqHAuv7uJFjLJrjz9N",
    "9TWWpDX1EHdrmPF3AuNBnuK3AbMGVpobdWiQ4fV19nNg",
    "9TbCfmd5ufrnJKnciHg2UbmvEMpWzevmCffTZnB4H2Kn",
    "9Te8KapC2RVWhspdt8qLVe8vQP1ugePxsrg54CLGxSiN",
    "9Tii5BnAPRK711eDnoGLNVbJD5ftGTmC4PLEaL1gViNr",
    "9Tkxw94NhP2CvSyGoJAAPjcwCjaPWwYTLyJ2yGsnHrFN",
    "9Tt3p3Yg7spMJz5EEZsWfamJH41j55VmomHiwAugx8Mi",
    "9U65SQmEzgUH69KijSefDDVHtu92P3u6xNERqTnYpeMX",
    "9UDs8Zn5weKu48mqsVVPFhQ7P5Rbc7EJTX1zqmHsekAR",
    "9UM7Az755gE9mxpjQYcaPgxzbGvNaMBcyyPbTrGGg7HJ",
    "9UMMsXWjt97iXmcofiUeoYbHZ4qvu48RPwRUpyRVgb2d",
    "9UjDBbFNExvZYB1YgQUHXYUbNwjXDdZrZtGXxSMqpSqE",
    "9UoLbCacm33YWJaGLA8QkwiAcNzxSKg4LvhNmLs2HidZ",
    "9UobCbxwbSBG1CuaxqycnPpDXTNCuAaFwUenERumDrah",
    "9Uup5gzQXjcVY7kWUMVVywR8vrRbknjQApgutCYXbqre",
    "9VEV15t6DPHvKen7ovue81pf9xQhwkJyd9dQLWosaBE5",
    "9VKnwrc2cRBMomwSnzHBTDG6h5XXkowmefrcWSQSuD2K",
    "9W5sCfKb9dUXonCDE8duzrzT76aT6jK7s8ra3VwUukaU",
    "9W98Yv88s8v9TGPqZa27dn1g1Tx4gMi9Ntr2Mn727VCg",
    "9WLTgWSAZmyb11fy19kSGtAvwfrtpt9758Agt8H7YtxX",
    "9WneZcsaMqDdTBk5ahjW2PeBRZmbMjhceAHnqxGpW3Kv",
    "9WoKEYbRgP5ypWxgY6wgdnzmVn24eEi78YJyCAGBMEx9",
    "9X6VcrSdWHfARB8ZD9a1arCoNq5tuKWopwPUHzvYqbpC",
    "9XPRq2d49RL8dVCUUaN95RHkxZLnUWFJxWT5wVyZ4NXq",
    "9XR9M4Mk7mak8N6SrARVdRcv98yMX3XgqZvEzN6YeuZU",
    "9Xi8dL2QC6ZDDp55LxdGpzWfL5hYsSqmw2xdY2vfcYH1",
    "9Y3uMSnHptgGQrVU5R2JweJt6cuBqip3CMRFd7fnkNB",
    "9YAHbn71chprHtHuqin8MY9ZwEtFhQ4tzfErntMT9NQY",
    "9Z4LAqpiSiuh14h9ifWj3dXNXJhdbCviXacc8Pewe3QM",
    "9ZB8jv2VVyn19PYFyELeT7ege3wFySpHBzLo9WU3mb5d",
    "9ZBSLLnTrnauA4cwRcxeBeBHajMpbhjAPsyrtm3ncp3z",
    "9ZMhHEm3uz7rbsjrGFpcYRbH78nff6gJQxoTr63vnymE",
    "9ZRp1BftdFU4pCHiCRgtMuFbeze4hx4oZb2eXfrc2zFN",
    "9ZVZ22jYVReg5U5V4d5NcibDhDWfbyyJQiyMyhLYZkfb",
    "9ZZW5DPtn4iU83y2nnrNHmAftZSpqenypCJkxg7FVEdZ",
    "9Zgm6QF7QT6BkEBYeLLYW2HBb6ayw6AejisANSfg2cxi",
    "9Zuy7H8wq8WBiTJgJoNfX73GmFnibF9DSH4nTWMbxP1g",
    "9ZvSsQkoZYNxFtY8o9TuX1DmjbuzLWjM9FwSRuRVDJSg",
    "9ZyD8qArr28JQXLXDnQKu1tSKJsr4Xb3fBdBdg9efDFK",
    "9a2dkL9SVqtvZRmY9T21PmiYdRtZ9KdhKJ7PFukGcz7o",
    "9a7BS9JZYKVwxY7aNvmg6pmy9CxoXkdXmLXCuUBm4f2",
    "9a8ebD2k7LF78AqqHz7iGf3h6mmwGJCCwR7Vz8ppPxaj",
    "9aGVJR1nP9xvd1NF2n2MZcSCQtUWVQMqUSrvFRn7CigC",
    "9aKYphV1ntaBfzSoiyhRf69YwXCqTbFe1Xvx7GCqwPjR",
    "9aLDLGYtJHGsXUrW3N2LE6nPYtEDFQAAwSjqwExjQAWH",
    "9aY6ayE4afWRV8dqdjMhYsVG1qFrr1N8HDZ8q3amFjpj",
    "9aaUo6coZR3FtFYND5cZvzcCc4w9E2ALizFzsbMsFvRm",
    "9anNFDZ65xgzAC5caEzTLzk7KczoPMJkhS5w6oXsW4jf",
    "9avjAFAu4nG96u3PHKpBrcVxbjgbhG37znTbwadG1Nd2",
    "9bFRU9kUYTBB5W4D1AT8uMyQDinGurrLZ1TmezsvoFGQ",
    "9bLQ2LoURveFVr5ERVjsZ2vZazgmwS8Pa1z1XAfnWk4h",
    "9bRadvUjHzSNgJvjiLXAKwGUps6Zd4pwkQsbADiLeZew",
    "9bhcyod5MRkioAQGZMgmYdNEErPoU1xjQYzXNLLXMTNK",
    "9c5bPnNUDRueVgr3ybWXN4kSy2WM3d5CdGSGUwmtsYJ",
    "9cAiw27vapVKZZgtMTqrRQmXxCcfXqhRQ8QMqNZX8WVd",
    "9cGB8buPhYpGmAst3Fg1TpKNLkrbtZLBPryqutuYXZdx",
    "9cavXqe3zmaXqpgke9vNvELU9ThKQGRVHcU3nCyokuEb",
    "9cbvqXD4uHB3MbtB4Nr2BnuAm6nobhhaaDizVqR4uskF",
    "9cdAcJtSYGvjdDY1vWFaPAKEGRUCBCjvDwour3xhWn4G",
    "9chiqN7Nodvn8B5ZT2tqaHTKuuMuoa3zEkjfKD4ge9wS",
    "9ctbFzJzuercbxqcu5CZNqu6kzrHQ3XcTy4thJJAgUBK",
    "9cvCVVtu7NJ8hd6ZEfm8NietaeqvRD72eGqE3aN3zKwN",
    "9d4np82mqcVvKUba1guWmJcy6viPfB1VPNFHW83ujE8H",
    "9dKxwfx3M5YsvnVcVvj9NHUXsP3ApirS3gRhBmWCDxz",
    "9dL6HNTuKhH59oEg4mxCkUA6M1uPt6pq629tj3tWRPQP",
    "9dPGCRpBVG2K4aFG6TCZijdqpFtvbM77SFUeafodzyS5",
    "9djd5gTQwKbUe7uHDd2sKbZM7uzywYniuVMx31zrphP4",
    "9dr5LgWJo2xjfMUf38d48XDWxVWQt352dAzq1P6PKQ6c",
    "9dv1tQxANqhkh17y4UGHV4QimuH3aMA6yJNLwjWcFJLB",
    "9eGxRmiUhxwXwP7SdbdsFH4JiuacqP7GF8k9ChZT5Q7x",
    "9eJifVgd2nJrjS9yipvU8oVdAYqbmqeKZTkjrzBgBZai",
    "9eQUzM3K7KqdQYi5EtyJbKqhPqewDhJ8VBvi6M1YAZcq",
    "9eTdskF7AU5n9QLLXMqLYr8DE5GuKG69E9zxmNgvk5Mo",
    "9eTzTGduT9RWt14YBStKS7TbVzyd22UPiZ2Tfe85KsPV",
    "9eWmRDC97ov9TrhootmJabViuKCDTQqaUp1Ff1UUHtzS",
    "9ei8JKoygRwyGZjBJZ1mAvuAXipo8eMWgHFRmuhSYFEC",
    "9engcHbQkHdmGJ9xKoDjFdYbL7omFaMsRNsbkZaPGfwC",
    "9ep3TpEZULo43RC29mcNusNnW2hz5EPZPmyGJJKSKaRu",
    "9erHZDGrHsefWNc4EBUHoHaLL4LbUVyvTYM1JDgoZnDZ",
    "9f6PbmZQH2ot2Cr5Yxq2kRFZa1SWqyHXtC8kw5aUR3A8",
    "9f8iwpYRE5ufLDXxmZmi7Se9hPcDWRmp6XtL3uiTEwZv",
    "9fLUxP5ZHZa6FEX5MkTQBa7G43CE2aABwZpPS2z7C4uX",
    "9fRo1fqzbp6otyGrHxL6CreF2pytwz1pq2EQBX9k874Z",
    "9feNtowkHdQnF6T1drsDWodjrKr16ioEKuFdYGyWg29e",
    "9gDgtGRqPUadheXCcJ2ra6gY5i1NtZ4YwG1kEGqNH1sw",
    "9gDtCDxKX7wvgEtoLFchh9uJMxDKbJashWu4eAM6aA6z",
    "9gJWQYiuu2sG9c7jeyT9wdZrc5nVaeRQDe6Pu27FT3Qh",
    "9gYbzukh8PdH8u3BqGKUX8fUsYRTNpWdPy2Q2MWq435v",
    "9ga5Qq8JsHHPsfyq5UgGF6TFgvHnh2iU7BgAL9ZxxU1x",
    "9gf5x8i7jTpqAhxR6FdRWQyX9yD8btCYWyhvfShbng1A",
    "9gfvBEkXZ6LQn3SYiLnD8gKDKYYNq8AWhJ7ptLheFDSW",
    "9hnSa8ApaYiTtvxjrQPHXuBJbWmJXfWBpquybirSmVVj",
    "9hoU8Zyjn1ubuGfbiLQiRuwraxyAgJh7qudFeebUkME6",
    "9hpkvUHV1UhRGYvBGiDoDmLrA7zTALFF4BcwqnXe8paC",
    "9i5Rb1UVcJUyi4xmcHLFcDj3vwkamyqkPR4PoM9DDoGg",
    "9i6BKuzQT7uLQDYxXK7pqqW7jMrxX5bLEiZQy5YVrvYC",
    "9iNYmmDKqpJE3uZCS8pDn2GG6UnfbgYktnecUionojTn",
    "9iS4bEoR5n1hnQ9nBRvbyFBffcQWADYYaSPMiAEeULQL",
    "9iTnFy2NQNpHtu9VJsik6ZU9D9zpSg3aj15snkXbuigy",
    "9iTouPRMp64k3FT5QxLEgpwn9cwpLTtXcx2bSLFibwG3",
    "9ianFPYQRu69M1mFLBFjHrbkTehpKoPz8Z4mKxKCvq8y",
    "9izqnQY9MHRQ9argvk85fmDxZjzYSxWsJFrwQgzuELJf",
    "9j6DHF6CqBgjvvegVDSW437cFgUbnmjBQ619jmmN5UkW",
    "9j7qNceo6oTFZ5px2CTrYQUSyryh4iKGEMvKeYD2eNsy",
    "9j8cdvkKQwNTrY2ELyCa7MWX3mmgfg5PMAxiwajM6Fz8",
    "9jH5Bsq77StSc4fU57rn6ok2R47yeK5kRNeied7eNT9f",
    "9jLraqLadm4mYnYw5Tg4CWPCtJCfg65DujseFdtvXPBa",
    "9jZ1v27puX2Eni9yKSLtfja9qp9dwqRkdA5anW1PXkjF",
    "9jkf5bZEBWqrDeDwx5nCDyBrQf73JxrszyguQ9mHpTvj",
    "9k6t9W6gF6YPYoLjRY65RyiAFarr1L5E7n98e8m27KVm",
    "9kQ6K64pfsM86BsFRDR9irAbZ8E22HTUw1GSRpwkghSx",
    "9kXQXkgekEBGvVz95vccHewPB5zocuBKVFtzS85XWLof",
    "9kZkkxEaM1MdxHoTwrnPauoJXo9im9icGLpQCiasu1XF",
    "9kpQwM2HbvYNeXKLR4BGqGv8BTYuqyUBVCXEMZT4gYK3",
    "9mPLKopR1HyaKaSbnxc5WfUp3pVAyyMukkomEufxSCv6",
    "9mYneTvifizs76VZnKPrhGYZwjcgYfAtwXCcnbMRfn6e",
    "9me764Db63XCLh5FF8myKj28MUWXjJwffWs5iL5VUrs",
    "9mwf8Jr1f2ADFdWZYTi5XEV8CgMRfHDaojd5PBPsq6Ts",
    "9nQoR4sbaiQPnvgyBgPyjVHQ2hmqzB8LYaTc34M5WMSu",
    "9nXTC2zQWc6RvhUa6sDEEVL5cUC7rEfZGnwf7WqkfDaf",
    "9niYWpHxrYw7AUZXPn35ypwZpJwAnMvvpiLDBmBzTK3S",
    "9npHdeMApdsPyaBg15Dux5Ug5d1kMo4EpbXZj8zfq1SX",
    "9nq5gMgLtwTwsdSnvgo7JJ5ZoXyRMmS7BAhJwYb7EY1s",
    "9nsgg2cVNXgibL6BmtNVDMGgy49P7cYPCLcc3yvK3FhJ",
    "9nunyY4pEv1637GNx6D1Qo1ksd5cAs6iKcVcCvUeg2S9",
    "9o4zWNHce2puZhX3p8EoYkebbtbeqAM8JVUv63dQtVvr",
    "9o7dB5qtz5BMhvTEChEK5uHgJLS1pJgc6Recur8EiQci",
    "9oCjsMGxknhq133ZQUpUFz6Tcsdecds2vEqMiCJNWsiC",
    "9oDe72HHwiUakLTbZvXfCPsLCKzCCuYbL5VRggFuEXMG",
    "9odDRvXxhtSxjSp6jGAaJFXRjvSGSkrP64UUtkDC4ZnK",
    "9osicGffuLqJXynxm3MZkQu3m5nRSMYaG1Xw2Yfvxq59",
    "9pv1hNJmENrA3YdTXZZDswa87qg4mLwv6SmowkrVjwyp",
    "9pzuSH3guzyfp7g5BYLB1C4FNc7MUDTTZvvDatRgygay",
    "9qUaHVDm1cghpiSusx1PEsjmKu15ppZtebGa9X81nvvZ",
    "9qx2NJRzPP2jgexBqrwRsgLxgZrVcLocAyfugmHAsKbK",
    "9r6p65u8CUKLfLkn5GYVjGTzr7z2ARx4iGaYt2APsBhs",
    "9rBbMvXfMTWK38xT5JdiCnz7PZWcdVNwwJiY8TGZTTxt",
    "9rUFLnTUxqKYA4tXKndKTHr2Fv6vKccd1tCARFY192zz",
    "9rt9z67mDBBRBMkQ9LPKcDg8uod3UdyKuZFKJoUcRynT",
    "9rvvNvFKuyPUTkz6yp9wD7CuUX547eh3oWCN5NvzHpfj",
    "9sGi55wswQz1M2MfcsPvLsWGoAwRE8CbUJCtQeMCNhaL",
    "9sLjgJvFkKaSdqBoWdzSqiLM18jU9wiVAGhVCUbkQbN7",
    "9sQfZTNY8LMvC8b4TurkypVyZSQnbSKonRg1aP3mWuzn",
    "9sraX3213sxJWrj8VjWe9C6Ek6MmbQDav4tVBFzxbRzi",
    "9stQY7hUFbQK6kNgR6jKxuBgQbHVT9qbngYjux6fQois",
    "9swnRS6LrLPu5QnpGes3hsyHK2175r29CVgpgVGD6KB",
    "9tGZHxAvAZQ92BdY4NrAga6pBXA991SWY19v38j8KwWg",
    "9tLSgGxNBgScDvuJjEzJfNNRwyZsUBhSd1eEkdzfdk8K",
    "9tU7CYvd6nEsMGZKMhYyCebmzDpUTK67SZhtiedwL58E",
    "9tYPo6AJXpHpVYJBBRGtBXZTTCdh2pMNAhbPdCEjXZ1K",
    "9tZ7kFj3L8WST9uNUe9PPuVhHW5doZAZBc1MJVfvzeTG",
    "9tZtbAggzxS3Jf6L9Ko4QABaN7Lh7eNz2mDw3EfA5cfS",
    "9trj5HRNRfwcc63KyHktHdvvKxvexwLgXLbmLvu45FAH",
    "9tvVZPcWYNqiZhT3hGAFNoQhYsawGCuUZmwStZSKXKsN",
    "9twMybzx3EspSG5n6GzDVcZSWbhypvozEfbQRnJVkbpM",
    "9uCrn1ZbPxs88tyTngQQVg3mfSELZ1UfmvUYShNWtJrW",
    "9uDVrCcnFjZsX1GuoozHXSpgFPYMCwyBKWeaXMfZURbH",
    "9uJ8Py2HFbWzM3vHMd6QEq7wtFpF3g9RZSWuPHtgFimu",
    "9uKjd7X3s43u2393UquL4qPrcZHVxRkfesNf7gY4at7F",
    "9uLuXotj7XHAqi4Kh32SVToVxgtWJYURHKZxG86kBfCd",
    "9uV6XPv1ZxiVwiDqHHw7M4UNpcWHot2jgWSmrqEEtgBu",
    "9uVSd9UsoaPvJdYxkwXtUANCouMtB3mJtTtQEBPi3QgG",
    "9uXd3u2wvVbWinERUmHbxhiUCg3D4B1h8cYvMwBj4tbe",
    "9ubhs7PuzYWK5P9inGP8V2Kgi2frfx9a6hnDPJHaQXGi",
    "9uh8i42e3pH8GSMLSLciS8c52WLoh83AvQJw9Rx2Z84X",
    "9uqsAFJY2ejxZZamwtpFK9Ezh7eBhpUziZ7ub7HPdWeo",
    "9uwvtVx7PP6HdzUpVc7QA35Qsj16dZEH8vjGzcEogUic",
    "9v22Se3WdPHMUsjkqogY8hFtcFCKJmFDp1c92GLbr3Kr",
    "9va7wtdNZmfE7m4UKtYmsEJAZuSp9R795WUyjzqaJDdo",
    "9veZoZVCRDA2JvvD4DkiykAjkEZRDYiNxcNvPbasTnV4",
    "9vrwmWvy3ExVV3y8zLLSuD4bhAuqnW7QqrtJ3ybr69bb",
    "9w61wzZs9wtVepcZJNwMYDMNC8QzyRG88f9mtvs9yTYL",
    "9wAjjWkin7P5CcyCqM1jQpZ8GyMCEXK6wb92YoY2n2pW",
    "9wDkc1pqDmSTMRJdQEaJVViBjGa7Ypw4SDLCXqt1MXfX",
    "9wJFSTPaEjF2ordVagt2ESBr7GtLdwuZywYhgkmyRKzz",
    "9wJaKosC7FGviyvynhJ95TRfURTAcRCRbpNEXN9guKbH",
    "9wN4yYTE2bL6xJTbBQCBzSTouNdScHJn6wrvZNDwE6XE",
    "9wRzpKDcChpLgJ5JLm3btahDMAvG1ksz6gtDUb2jJJ6R",
    "9wazk5e1FW3j2fq3eQBrkj5mP2cFuepkqdRAyN3ax3F9",
    "9xE3XdLFQHkwjpLp1tMPUjwpkVNRwzUxaF7oWx69oKn3",
    "9xMzDgHosbQwoLpzRE7bwpRR2AeB5CBLwPjPtUA3gVa8",
    "9xSLNyVYuPxZGGpiewYgmumTfDNWCm2izCsDEws5RMxp",
    "9xZydab7LJHJschVZCs1x2s7mGMatYQ5VXM4av1aLyap",
    "9xhWYDCPrLhjHYYZSQRapoFUKdPgM5p1KbvDCGqaJu1p",
    "9xiGeQJU9d2GZDwARKBmhCKCAGzpJhQXT61uaDJPNd51",
    "9xmjxg6w46WkaaaL1UxfjFZbAbNcG4M9zgzVXJPSEn4C",
    "9xmrTB8gCuuKpo2pgZCjzGTEbG3TYfxapFfwm1PxwRZ5",
    "9xziF69JHzReTBq9qHW1ehxkSwMkaSgZ6ZGg739uwwgJ",
    "9yFfaAvgtgvCypMe2ZKW7KYAJXsbAYYeBcKGHfaSiRnW",
    "9yJk9iuGSJap1f6RigezpuPikZHKudDR7N88fA3WEq9q",
    "9yRZkN47cEB39tUZBvKbQgBFc4HuDhpCokp9QobfAZXP",
    "9yfPcEH6L3Uqja2zMVujpcWRmahe5ctVdDrZPKAkWqz4",
    "9yznvgTVJK7YnyaiBbJWo7g4VmDSvegmJdPuSnEgm1uk",
    "9z14kdhYwJfovrfxAPhL9m59mMhDDxc6zvbCA61GD3ny",
    "9z5iQc1rmsKLemNMztzpuxo2vhvkE5V1jwuwEYYtKJ6V",
    "9zBDYW5dwLtfdV4GQd6sFqc3tG2bU7W5kwEYfF6ijeeD",
    "9zFaZY2rSj6U5Go67AdGG7eXR2QGwJdJrsxc1z45WqPa",
    "9zMhzjZPNrRSoNL5HdBic4gNfHN9FwUC4pLvjJRaT7hk",
    "9zNa9wRe1dZ2RnQ9Wtog5Cyc9nYYYzQWV5aJbM62VMo",
    "9zUVLsWKjbhQVfYfyjwdYeYW43PU2i6hCSHazQ6ntS44",
    "9zdqPiYz2oxzve1K1L2SsAcETmHHfE2txwJduwR4ngbK",
    "A1518AJLcY9vqsFdk6xhUGWmGDUxjZWTJR4BFy5jZeeX",
    "A1D4wwwTHJNsKvK1Ez13TMHswntoQPt18ATXoZUtkTCm",
    "A1MPTfd7TYkHJdfqJCFnz2eR5xT9EmHtrag6uaRcP4BC",
    "A1XzfvjTtgY4WrmJL6V9pmy6cao2Pe4s4NxWaBdjacZM",
    "A1bUUF7gmJ9GZq3zZ49mFb9FmMRfbGiomcxgR3SyqGcG",
    "A1eoTi2TTRSQUfnU9VPaeHSTrTMRaFiJEKTo26mkeJQR",
    "A1qKtSKN38kYqviLHk2M5pp5m2wkCY9kZwkQSQ54vM9b",
    "A2BLT1fvSEZuQv9cCgkSGYzKbVY2kcxnivwWPfppQfhf",
    "A2EwPJgnWd2kvgk7vU6jjwQ8rf4JoqBuFh9sLKJfjMxq",
    "A2Kg7LsXcn2u12U6KzJSuL75T3zwLmT75kaKyRwRRngm",
    "A2diStS7fPhTYGDrVLbtD3SURmMtSEPAhrRW1x4MXdms",
    "A2pcQXwHVKczjV3kuN1SX5bXoczvmzUA4p9MQjXhmd6v",
    "A3838wPJtAwJ6EQ2f7X3j5GSta1X139ZZq4cmHNB2Lxj",
    "A3ett5AN9Za2hBhRTegqBvJN4dfvGmHYfsfHxTm3LNev",
    "A3oxv97UqomsmcRoo6nGhvqVGEqLwUxnJVWMoHbakqxo",
    "A3rmtPFXqrFVsLouBjyNdXED6mgSWzmnhkfKQtFiySk8",
    "A3vYfkc1G7VEBjPa7wZqDG6zGTVqUpikRcccK4Leybxt",
    "A4E623p5uAJKwrb2vv2sJnKrRS6cLzBRNyDeAq38tiwP",
    "A4PGAa4HDSGuUFmqZDkEFfmHzocFGeMi7TNLNygCAfh",
    "A4gp4RWSd2inhv7MwHHajxWGtQD2dqUNbKrUVXicLEcK",
    "A4mBQvEc9fupV4Z7NKbc8YB2AJzbE6hJZGMgbaXw6xWq",
    "A4mpmDK73GnjGHTXxg7hPzvc654Cwxr5gLuKmDjaJeCF",
    "A4uqXVxWVLcDCegCsy648Y2amibzFga9cHvNJ7NWQcQP",
    "A524pp4wFRUSntBbKpNQJBG9WuV4YmLDJcsvJFnEf4Dy",
    "A53Y4gETa8SsRnPku67FQhdD6LbRJp5L8mV1oeTqWJXv",
    "A59dAzoPPyB9NhGW3JSkHaP24YDtNLvgof5gGPdk582m",
    "A5Jts3kngwpCp5oFXQSFE1YrhLYfEvHTdY7NCbKUhyEm",
    "A5Xnj1sEVS3ny1qBNRKMSHFveqtfQ7vpPfkboAR1vohd",
    "A5sjns8vpQ7e7fXwFjgAn8jJwZmz56ZMz9husUYaC3J6",
    "A5wthhjwAt6gqZL3isw9jsm7C7mZZkEMuAStUTfcgCnP",
    "A681w34m7KhRiEy8VRwowPN3mkbiSmsgH3kvg64ygToa",
    "A6H9pkKSGtKAZJAxNz56F9CVseCAWKwzPkx7UZFsjZGb",
    "A6W8kuq9LACEPwXCzDFCgBTrXLbiBNK9KMEkTftjknSo",
    "A6WJnoMSirhqeGN3ctq5DTYf3aV5pghujB7FN7FuDX1w",
    "A6ntz3F39pKYEvCrBHSzB16QRMAXQsX8BcGZ8iwVHQzb",
    "A6yVHznBJHEiUyCZ2gcBSDYoTNjW1x65fwC71mpu8578",
    "A74oNRcWx8RnkCBypHFMpYZDvvva5zkJJXF6wrmvgiQZ",
    "A7DKc6k7wzXW5LTjrvhB4FDCAgvW2NCuUS9eoz2Zyg88",
    "A7N4aPViqeNxH1zqfo1akRCW9tAfMNBcsTcSVGQJDwxu",
    "A7PCLGyLHena9rcAKWXvoCSXmKAZ9dJNSj4HaCaKX2cu",
    "A7VggkFWjYWWZoU77BphEnQzBFG1Xj7ygETNnToff3GF",
    "A7gFAwYuowuJVzLYqhGiQYqyYUqn5hktbiLRSinEj1CT",
    "A7hqwXtpRTJTURzAiMsDKphDJJiELdGftoUZPPFUTmVi",
    "A7jYuBNVuhBtnUsoR2ptVEmaraxLnKx4vSMgutCoCDGx",
    "A7uNYmss3ite7KMvNDknqhA97No6LpUYc4NBdTG6vaaX",
    "A7xYpFMRUCeicZsBPbsw1VgsanQtPK2LM2ma5SpfZMkU",
    "A7y3H8SyeVcyoLYJWYBxPXSaAsNQizTeikQMxctSDAmF",
    "A81XPnBsGuchmEEKQeQoEm38Q5djUUqWSQxZC2aTxAFY",
    "A8B418V5VTTKyTdy46nkzQjHf6CLBJeQ8snCN8jWwH8o",
    "A8DbmUKZ57EMtuesLAX78CSG17gCZip55HfpxuhV6PUN",
    "A8FNwAJyj1Soi8R3xXY3QGA6HxztcZ5h9jLG68cSKzB9",
    "A8Lhwu5utzZVD7cGPQW6Dz5SATRgqxrttDn6rM9gxADq",
    "A8XsfVWUhx1XnfWwiz23N3H757ti1gJEywUWihGh8dgk",
    "A8cZiMbjrHnrRUyQ4goQfFhuEcFhe6CHkgw57WGRySVy",
    "A8j4fkVMdCAkqdreTtj3N4Db7k1Y5mDnPavAmQtT51EE",
    "A91fDjoV4DUj5sCD2dt8kLNuxuErfM5xuiHXY94NtrLj",
    "A9Hcefzr435WtEJMinqJEVjTXpXP5E7nNKSxKEfRU4Wo",
    "A9PMY3q8Hott94GBywdBTZxNkQ1zdkG6iLC9Hd35p8nR",
    "A9WDgsimfXCjGkh1SMxNb8XFke8qZHvUBLQzKqJ3ArPG",
    "A9tVwKrx9VTxiJyxEaahqfETN7QoLCj7qN8UK2Z7BcwR",
    "AA6p3hLwtd224tkYPz3vNVCWVC1d6KmGcg2QFiwckEEo",
    "AAF61TWYcC5SkEE1ptE61U7C8h33NuFaGX3oKudK6LoQ",
    "AAFeYKszZWPAAhvZTeb1PbcHBVhBHfuM6sY3RYtWis3A",
    "AAPB53YcuYaCZ16ScQ3ndJPw93zJFoPNE65duUHaVtmG",
    "AAf8e2gSsfJ9SWVifTE2ToZbiHcU113dD5zVhWHoXxKc",
    "AApME12XzbhHhh9McnH4MmoHq8s2K4dPtfQjKw44NrnG",
    "AB5LMwUQSKSd5JvgEM9VGGhcYmi4THEc1qM9PVvNuS9t",
    "ABJaxVosmHK2JUEjUCtsUD5x4Mqo1SgWFZvw9Yt2spFD",
    "ABNaStCYscTzqbYwse4cPucZPZh77UfefZaoGQ21oL44",
    "ABdNJHhhdat775PniKKyNraQ71H2tQSEG5hfAaGtNmW5",
    "ABmmPbhCaJg46we5jPXCCNGCUiSSuSkopckEf5dTSzY9",
    "ABtrxwj2qa7xHq88QX8CLZKc2NEXyPmzfRQPKrdGZJF6",
    "ABwGR6rkPNwH1wCigbRKVEq8MqDuyNoM3h4Regmvx78S",
    "ACLvWiZrz3ksX3wkxxg1SKka1cQFiJBV8aneySEjXJSA",
    "ACVGC5SsT2UihU6BAWiTciSKVEzyTB5mEiPvYqbUvwvY",
    "ACrHrX26yR3btGhbWFVWPwoearRYbi9FiAevXTftCeZa",
    "ACszVtWc1Bxu2v55iyYcgKkdUregD65qWagTPbrQ6L1t",
    "ACvFxwrJR584jPMMQaJEBWPqgiTZRjSckaBW73HGqKDz",
    "AEHueZZ4zqwDXFxNZ7RnT3WSGatmPa1Aw1am2NxSXry",
    "AELg3pVWHpboBStR9U6ZJUWM89Z4ESZLJXKvyEw1HM7V",
    "AELhsogbfW7QP5Q6yk2Kr5wYXYxRmLPW1ZRnJMZgBmb4",
    "AEWzSp4JPy9518bSKp9q5N8jsz9xe5xgBdJKzzvXs6X3",
    "AEaue4pYRTrbqybXQwJTbCB2ADeLGAcy17P26nhCxywh",
    "AEkHSHreit1Wjd1TrvLmdzrUUCtkVfNxRYRAroquZxAR",
    "AF8ci446S4JGEQXr2mtfHLJoksh4NNRHES7ejaLafnh2",
    "AFDmVAaChG1ky1B5CcLwR43yNt3XeYMLjjRu51TFuDf1",
    "AFEAtqzHmudVfcUw4VpE8e2mEypJDLWVYecHs8E9mdvn",
    "AFW9WRrQfsz7uFGs3eMwP3v4BhELUADEtXk9UUjvNm7A",
    "AG36coyGMCy86bQM7gKBN3XNNB5US3LNYqGLrhCnEoeP",
    "AGDRehoMrMh98bE3NTesBaGExQCvYDWhHKibF9z3Z2Nx",
    "AGb2iadp2yrRxejDDkgd8A5yV7X6UtNBR1BChF1h3WJg",
    "AH4acyRLxsgXAXD7uWonsfVxHJvk8b6tHhpA3be5H2H5",
    "AH6hsCmEfgzWEXPmJdYb6j2hNUoRiWTdGKtzSCYMr5Gp",
    "AHM4Ws6dmRSvoDEvSxjJRUYhWU75tE9KyKLa4iGH7skZ",
    "AHhpjZGVirAKxquca3c2x9eikLmG7LTesiURYvmhi8Zt",
    "AHrLf2QPfh2Nt692DmX2HgDAqAVVfkVb9SjADCEeT66F",
    "AHrf28ZgdVzDsDcvj9MhULruxoJnTnAMRNRkKBz2EJiD",
    "AHzubjJAMxMkCFdFyiyJjo9MUpTJpoHHVRJsF1VfXkmP",
    "AJEyL2foCdd9Jda3Uper52XsSUaV17ns8S93gCggKv6E",
    "AJSBEdQNzbj828dnbVXAVkhr2W4daXowLXyLTYCQh1Cp",
    "AJdibDw6u7xAuYcttR3pXPNBsbMFMRZvLyUw9h6kf4Mv",
    "AJpptQfwxZGbxLpAfgmTpfDnZkV2pnRWjXkxzWs9hmaV",
    "AJyYgjpTHSdhmJqiEQSrkdhNMqUJfhMC1mdxCiK6CgHs",
    "AK6qfoxxnqNSdmRrrELQDGSvqzLnvk8wL98TRyRSmxwx",
    "AKBqsxNaF2LB82H1YMPqtk24N4RKyL642nZiwNUb4cHf",
    "AKLMXZU88hjpieZTkvddqs6m7odM6AZ1a5trPPRbGgXr",
    "AKaZpiQVM6VkydzWKDqVR7jykh2kqq3rETqqeZQvYEtt",
    "AKnG22YftEp3NtnzYhHC6R3cEbGVzDTshGR85RTNV6qK",
    "AL9RGCezMoywyTRZY1bTgSgmMnxN9p8HGJSq7qkUouns",
    "ALKwdNnbjTe2pmWWM9TXGvAQ5dgnWaMJHBCGqaFyA4yw",
    "ALQKzDeshZkJ9kdUR8ag3shshJmXYGTnUpydvSQ77K2K",
    "ALaf2xxJJapGD3cWBBg5rgx2tRn32yR6SsoAHuQG34K8",
    "ALgMkRAFTWwwsAh8SFaKJwgcVLfVymoHemGwvbdMvkN5",
    "ALtpsQ3p7dykW5S66CeQ5UV1cqjg8x3mV7Q7VfCGiVqc",
    "AM3QxGktMpr44GKjuBVeokhyv4vtnDRGoBhHd7fNuy9u",
    "AMGAsbMeaUXbD5qKquvaxsBXTLj8ai4hBBwzFfC4M7Yh",
    "AMPgm2d9DXfJcdh2et4ws87ZDNnSYMezQRXzjNS8JYFU",
    "AMaA6jd413udhGbSPNVH7NEmK8P3tkb2CqW283Xe1NKp",
    "AMbXQ7Y8jsCfF4cHsesEG55ZJo1VnKx8jHb3VC6jpy6S",
    "AMpy5UMCbg17vAZmxrG2hrLVq79jah331SM6j6WzSHjH",
    "ANCXTwN9YEQgYPnQmsBmShcGwjgzpN9Ab4vAfo8DCodh",
    "ANDgghGk4eWpBbr5ErAgvZA6XXkyRAgNb1TuZSy8Ysc5",
    "ANbrehsbaFCeALjVQKFPjsfDebdqNXvVCLgntknvcnTJ",
    "ANi4n3H8kqcS9w9PCXvDGETqbTZE13WUBGTRQLSKm7hj",
    "ANjJfN5VgyAajpDN44naTQdVyHsso1eHXZgmsDp5foS",
    "ANqM1AVFhV67PndbgWygT3R2ENU1E3Y57YUKmujJ1XAp",
    "ANzQy814hFgzcaL9zm5E3pd5E2xh3pc85oPb9Xhe7iv6",
    "APEaCXyyYHLy4fv1Ys57vZpvxxJjtvyXgHt7yXx1n9hf",
    "APNxhYmcxzKBDXEctGBfaMuE5UaL8t8nH2CgvN6tjQge",
    "APSdo8wqUoA9rpeHeGmqTJdvWeWrL1gg5wMx58CJ93CV",
    "APXnZgRbPYFnFVLKaxV93J5MHhGrjB7SayRLh5rzoSA5",
    "APhMr7ME6Vh9qqUet48yPjXp1L83goJYkpy4GuurKg58",
    "APxeXf6TWXAYMWKy3z5G1ZM7tHW5ogSrcrzSPGnac2EP",
    "AQ6LChxWECqb7mgrDCrJxzUEfUfknGeJeFxQ6BMnKxV7",
    "AQnTvRNEMBMEJ8JFkCjqHWRLXynh4rAcxf3rMJxTqARn",
    "AReWrStjKeFxJc7sZKcGJWp6nyjzQt95W9Nmj13jzGF4",
    "ARgDK5qCDnT2RbKY5HD2s9zQEykTxmmvs39dWJUrxBUe",
    "ARrqEu9qQempfuhJ1az97ZdPMDnNRX9Xg85gvyYJMsUt",
    "ARvbCobYceUPdoimVaNprX82JuMpDuWG2B6XTHT6N3a7",
    "AS1Co1Fv1ezawswvXWScK8JVBRrMvuGy6wZk2xKBdAuL",
    "ASExST6SG3ebUt4QtHhT2muSMVY6bhkeN9dvDeRfhbGM",
    "ASFPEWBRNJHxttbjMdr9E6Nx8YdYUM2DrhqKZMZHsTpT",
    "ASSrHDGNZDpd9GVRLuogwkZx8uRyDdtDxGDaZciq77Q",
    "ASU8LeiLx21CFc4gWNjnV35RBDMandsqNNKZVYZcqGbJ",
    "ASjA9oGij3wy6zWzAWVEiU8wGurXS7eNFRSK5TBiJoXf",
    "ASnJSpeGyX9CDxiUKbGysmt3tTNQRux4T1xNLucHacYU",
    "ASz9f1Uwo1mzoP5nE5WB7bKTdsYFdCCkC9dQpxQPuQ8c",
    "AT2CHDKhLA5ZoKHXAv217Ed46xLnFApbHdWNU9VCzwY6",
    "AT8Q8WG7kJhUzKj8XJZLEj6gHCXSfGoDch6Q99SzyQPD",
    "ATDT2efhhr2j91MVcncMqkACsSJGnhfrKMtqZcJbKUVr",
    "ATHAzDVAH1YCmT79wehu2xSxTsxnfGmGg2UcAnAQyxjk",
    "ATJApGeb9sXRue5okkEisTRS4d1D97wY9wL6XiZnSAJh",
    "ATYtKEthmNyKmR9RQ2Z7gpjyFEKaiDLyWsWvFs1PwGax",
    "ATp4knEYFgGMkeitbkGtRTfBPpUvDgbrUW14HDdZSaNV",
    "ATr415UNamwtqhBTH3E2w48joMNqGewnUah4wus3K81Q",
    "ATw8E9XRXXnPenne7bqKTmw8iYn8j9wUeAzvvpmBmRcW",
    "AU3B17tJoPct7GXydnMrALsm9ZGaA6GTi5nQJKETs8at",
    "AUYd9HjDyngprC2GsReuMTCc8ZacwUC5KKRj4WgbVUkJ",
    "AUZjU5hmF1YRx2zG9c3tu5Diq7VU8p5Vp8pXC8Q67Uuc",
    "AUaPDWkDotrzf36M2yC85wqt73PJHqK7K63JAwG95htR",
    "AUcDx8Gvq532RvbK1QG2KvXvWd4V5J2SBBMWet1mXgbk",
    "AUrNhGMzYn9Kz2oJAJev1RioqTrUdxNQMmZoAfzRd4s3",
    "AV9Thqu2vdRW2BnYRE5pCc2fZs2FK4GZWY2Dm4BVhvko",
    "AVJy64ZfWQ6sazZAsJYNDk5u5uFWYGHj5trTmxMGHb9w",
    "AVqRv9TmFn8vqnQLRvQFFC7ocRcbghiNv1rnG6PQZUms",
    "AVrLaWmEBBevhYTsMVkGRj957R7gsvL6VZgKBHtf4E77",
    "AW18LzXRZ9eUqwrszbojTVzKha1DzKQECeCZYEWTUkkE",
    "AWgSU8qywkoBMu3SowTE8bVUtPU9fARrnZenyNcmk94D",
    "AWgpVEhtpoeivy5vkpguMHf4x2XQST26KL7cXyuTTLn7",
    "AWi7UxBzmX31cZJp24nyecxt6TRVEfXA1arkeYpEHPhU",
    "AWvg2oBvCwgp1GcJGfwvRF3kWa9AFo7gDM8jJnH98ydJ",
    "AX3MhxpurxZoofztZQisArcLcbG2gq7sBkKc2ibvHeci",
    "AX62Pw3dmCSdJzSidyF95RZBHy23L7Vr8u9TgZPtNNLs",
    "AX6MHSsa9iXnSJptUFcMoSNa5bUpGuKbtfVEqbt6n6Vv",
    "AX8QquHLuDNMzYL9sWNzukxTD7FAUPtisrzpENTKidpW",
    "AXejbmqyVeLnTjsxLFQV1jTVQbiRAhDmorwoqfzA3Fep",
    "AXs1EXDt4iJirdfsKm4ypWJeBh9QYhJbd3sGKXa3qt6o",
    "AY18RSEtEibYFgHnufTe9jzjGw3EYJ2WrTuHhjmQxqWk",
    "AYPJgoK5h34AhwqPnx14DYpGLr6DnXHBEmwTtnNQxY93",
    "AYW4UXVVzSfu8LTKHw5qWcbge1QE7DpBntmr5CpWSPYd",
    "AYjdVMou5eFKwhgEvfsLDX8Y56ZFMqfmbwe2xAaeJ3Q4",
    "AYtSiTobJu29KjCy5Sbqz5cASttQAaFxiqMTFVzR8KAP",
    "AYwfk2i5dYxFcg8QhHvnfZQBnnaZEACz3HwbXfvJMtAa",
    "AZ1HaNys2mikCkbd7AaKZiK8u9XURrAsmd2Bgoyngmxh",
    "AZL8kgzSVfqxsLbzgjPRmtZSsmWG746nubJ5TMUeF4t2",
    "AZXsyYGBVQM29RZDyi2cj57TotmsThLzX1Ze2X7NJ6g7",
    "AaJmqY2pT8SJ4efP81o8JY3wnZP679bz3EnPt7AvAp7s",
    "AaKG8x1zx83Tfub72LAMmUYkD9oGqYGJN68v9WsudtK9",
    "AafkGvpUMTvgQmA78Ph5FGaDJherguSHSjuaeEtN5Lo8",
    "AbEz6nD7UBehR1VXwmAEbf7qLjhWDF2a4H6wY1hwbPpL",
    "AbJJpkaYagGRH7jUSug8N2iHqPQm3ZgRQbLhJ6ounWCn",
    "AbTcYHe6M1CMVgKzErzzkWGyWDFeAhEfePxfmmh1is3k",
    "AbsRmYYRctxmNpKfUKgkBjegrjet5JzRJCPbXcM3vR9V",
    "AcCNCqvJzKCPNQBiR3PsWowEmZ7eQUcezrDdc6QC9DvA",
    "AcQrjfFXx8miaTSJ49uxaqZNh4zwqXCBAeZQzAKZXBc5",
    "AcgGDcgnzt42VX9LsMbvqJAh6KgAJ8v9chFFf9BmQqgj",
    "AczDCDrQSY7n4WcWa3tbvtQLDZEhGnAreXZfunqPZeX",
    "Ad45uoXz9dKyrRoZdD3gam9eezEJYxZ1ZofMp72Ny3MZ",
    "Ad7f2oVhZm87So8GHgLW4cBPpaqakQhSACSnsfGbi1nu",
    "AdBG3VkzsfUtBTmTPwUduu9CAs4c5tF4Dz2AXtbgtrX5",
    "AdJ5AYnfdtFCrRgkCMRhtYok65RxqBhAsSXNNHC2oDT1",
    "AdZJGrNJxyzkno6mM7zXzZnB8u97dg18W3PtxfUFNkFX",
    "AdaCXMz4QA9F7e3zVT6BhLnSFgf9jgiQENFQDgxiwG3L",
    "AdfN1RUVdixekrv2SSfMbqmAC9fEsZKAtUXhbCjm479d",
    "Adrgrph987LTiFUCN3hd6mVRue5ySmAvsbVX3Uv8Wfmf",
    "Ae5GiRXTytj2DQ1rwUDVDbGZu7zFMa9MMPtLNKbbaLrh",
    "AeRPQfkaUgYxTRDhayYJDUahrvC3etGjfN5mpwY5Broa",
    "AeUzvAdu5LE8Xupsgp7GAEcJ68gjTCkDXzN2egN7QoQ2",
    "Aea4neQBicfS1xu4ZNF92tQ8yT18wcxpoXibfAP21g5K",
    "Aei3s6sD49HSHR4MKqyUhipBFfdstu6ojJVW34ZohP6d",
    "Aes6ZxFcuP5o4cQC7xynnDuGzYP2RLkHSGsodZsgvB2z",
    "AeszTQ9FkhRjztcmBZHajpAQBtcCzs2Sy7EGjokUbKcj",
    "Af1X3dhv3scvJiWfdEuzYrUN8VJ3Vv1JE8uUch18qSDo",
    "Af9veu9wFMjceQUXtbiZaq5Uwfce6DsPaYcxfenYeAFX",
    "AfFUh7XbCHr54SuWpUkMaE3kyTvbwt3vSfby8v6ZTFGA",
    "AfU6by8XoC284myjUkkjoq7Uk5EKXZwhmYGpGFR7qTev",
    "AfX8CPWABEtbYYedAxvG1Futzr9EYeckgLwEZE4LACJU",
    "AfefTPWx7N5XYR3DU8Skrjn9gojLG6dupDMZ9uLSGLcc",
    "AfwXZfvigoGit4Kzkbgy79yBYeJr8b8ry4JcDeVVP5WG",
    "Ag5fiCtsxAYWjArpKGDdNNeF3iDXVDShSffSTpwsVi2q",
    "AgVBKU7VTtiM9ApdSek1YMTrpVqxQv6WBa9AT6RwyLqU",
    "AgVPfZndAYKxTVua7jxb7CXrm6DNkM9iLadcns2Xw93w",
    "AgeVAaN9R4RGmg5SVawb7GXzMxcbr2FWimNwdv5sQMU2",
    "AggHvsLB51ps3xCbpQzZK92QD6oeDopvjxkfycSX8Dhb",
    "AgqjB5ZsKE9qFzmuYxr5i47X61WLwnh9krmTsk9Eo1Dv",
    "AgtijiD3R6DQd4d2AWhdqFktcfpCw28A869uYwnE9MLm",
    "AgyHRFq91rWDPBprHVxU2ABnczTFCZoN8oVV5rS7yEmr",
    "AgyTPjX7N51R8F72ZFPk17hfzs857SvEUgMWUJq11sfh",
    "Ah12jjNKFco1bRKCTfc9CwJdYnauiiaxUWX2HFokb7F4",
    "Ah1ewrtFKq6CRzF7dmyUmKYsqsGVEUvuc69NZzvKd9BA",
    "Ah8GfiF9CWmBZhKAdocXMH5AATuratLJDoUPriB8yZ9S",
    "AhB5AEEQ7SHLDRbVsQ4T1q1yPMnce3HF5DYwGeoNxhJ",
    "AhFQA2eBvg7kQJxwMvSxWQRD5sqt3bEb9sSkdL5VuqZu",
    "AhMxbo1Q43ApDF8ecvLQihEz8txiK5v6ZKKiBXvTftyE",
    "AhQquPq8cnKi4xMse1SYawzxNCZXyCLtfX6jNhzbZ6Lh",
    "AhTJC2zYM9hVp16GDbrV4AoWLkz6Qj1evC2nQVRXqeWB",
    "AhgponUk1hbqF5H4Yt2oDZEjYtoFuWPae3j1N8jYnTra",
    "Ahn4YeZxPspYqHYKcWJn3fEDo3rhiADbN72RyEsHgbwf",
    "Ahrtr5chGpcZXWnQkwbXK9aisxpE9W6Kmy1FrYE2FSp2",
    "Ahu1fpD1Cfydt1MjRH47E7VxFXaFLPQuEfTnXDnWhwW5",
    "AhvVxaFxJYXSAjDRGFTvmpiiufJBUCYimyidT7exwh9G",
    "Ai9pMtspzCvDNpbhezjgDoSmiMv15eLArH5mDvYpWdN",
    "AiK29focVGVt3rL6sZ3wPaFAhpaSpbCDDKUD1ZSERDGy",
    "AiKXQsU6rAaZ1UzuQfCCzBn8CsV1JaH33BjRyYZbRqWv",
    "AiNhNmo6NQrEZumKCXQVATtcHnUbkq145vW6EBGjzm8i",
    "AidJxGvzszbxau4mrEXHs31UZ8FmMyezaDRhdrrUTUUL",
    "AigSRykHmFM8VcQjuqDgtADyTL2Cq8JbSYDP5uvX2ubx",
    "AiwfhqmEXuh6EJAEKkbaSQfJrfJQ5TE9cAPZfiubeaGA",
    "AjN9eoMTpifjaSvNnVJ8VkX8QzbUSeBzbgT2VtEoi4wL",
    "AjWo38mtjP32QSj8tYHrH35hbA4fg8iQnhR9ZcUic5tZ",
    "AjYCAdaPUEgHLfB6SvGJazQcgkqAtUw8VyKCZhNn1tKB",
    "AjZsm7fmFhX2ENUSQ5DR262isCgNf77Lxwy2CuyqAdJT",
    "AjdrPQf1nYLCST11qNjgPEYgVb1QMEqVSoBF6Cuzdk6v",
    "AjgsjNQuP1mAQPZ6WRdbk3WMkNtdxvaLSTYbNNQAoy9o",
    "AkHqZVnc7Knm1Yt1iVCnHYxq9XCqt2HNF4EHiUeWFfQo",
    "AkPC9WA92tjFpQMDSMmBnoYdtVzgJoUgF3vn49kVSA4q",
    "AkREQv5FRRhUdtKvVBRMHo28HZ5NVtbsFb9edkwT3xgz",
    "AkShQLg1aTtzb691SM3MSv4wUCUUHamQyYSMFF7dKVg5",
    "AkTuTGQqf6yLMmbp9p5szGmjt1VSp2f496VZknVbS1K5",
    "AkfB4GeufH153VLwARFUdUK43XW5cAV8jY8o2dPkyLnp",
    "AkosGVEqnMvhMZywrXMBSBp3d43b1emLvLVvvDL22cmU",
    "AkvmB279sNJeCs5ZXYbWFUCWLau9z4J9pKq3XR9eb8iJ",
    "Am8wi5D9CChxKyWFrPbUSjzdbYucRMKvVcTkdnaR9CJ5",
    "AmNTsCfo1rmtCsKC1HmFhHyxtNC2t3z4oDUhjtxzWS1X",
    "AmRW5KxiGv1SWTgHWWXr9vHqNpb7M9qzUjn9B4HhuChZ",
    "AmSZqwHc2Z8dPY3QPttdTwaYP7seoq6d8VotgdcKC4Au",
    "AmiMxDyW7pdUzNbAV3LSRuv1ST6EgRy5oUvvyUnzrZXX",
    "An3RddN4ydAgUPwZtubSycSXgRBRWU7u26bPtcYGsqKz",
    "AnHt7uHgdSjjNG2x9FXdy1vXe85ryGVWs1c8aaAAFXHw",
    "AnVqDgK62pqxELJV4KqA4gp2LderTrQbphhQ7At4oiiU",
    "AnhPPZwCEoRJPVFdqPG74KNUk9Tt1kP7Jg95P658aJXU",
    "AnkpaYqpCtwnahV5zbXn5mQzniijPYEVwVApKUKURkc4",
    "AntiDfSC46E3WFeLKSBjSeAjLDmtJXkChHpH7YNXgnJC",
    "Ao2SGEkSVXkDXhtPZrUjyzo4Z9GU6wppxrsb1hW3uM3Z",
    "Ao2mDV7yhuuVyBABrXeSbfg8zoarYPuJjbDKSnsJvCDL",
    "Ao6D9QCWXXCVrFMaYCbHwYNGwUvXWP9M9UTLUBVGKgE9",
    "Ao7x5orEUHgocieL5xQGkPDYhHWNFKtFeoH5DDphaCKe",
    "Aobiyoc69iDsn8FMkjGdcX4GBd2t9RHEmNVDMBCayYYt",
    "AogYd4h6nnjK3HQowvAzf8uP7KpqeXjM4SzSLJMLejRJ",
    "AohnWn6svfWhhe3UgeRsQRVPCMsajNJtbKz493WxYw72",
    "AoinCYTQUcoQr5nN2NviuBGHvrA9m5BQ9cTSxzJJsZd1",
    "AomcmsPRWhR4XTycCVbtwDW4BS3pM3o9JNB7maVYeXua",
    "AosWWKERMSM7ChSEyr9QZiCMcrKxFXX9jxqxqjHxvcWC",
    "ApH3VU1kGHYpVpyxV8w3H1EfHzZ4QKzZf5bz9HQchuw1",
    "ApJNrCyebZb92zjndePp7txxN1cStDmQhyhyi5mA4nyo",
    "ApUNisFegx1s8GYhZPE9gLznoNtQezkpgJzQpwNcumAv",
    "Apa28ygNuQobZUsbYkhTkHhEwVMFdpsENj7aLKzUFbPR",
    "ApcdPnDpS8Rm71nztyR4oSkNXGRF8RDDxTSso5QMe5eK",
    "ApktsCph5HvGJrsjzn3V1TmgNugXN3pEiAyrfnBfSn4G",
    "AprL3brFyPkNTqWpHPRe8R7FL8iirwweV1r3xUGm1YQk",
    "Aq2LJ8z366Py8MfMBfpdcWE4eFiRoAJUXE1SwFctJMm1",
    "AqGWPa9RVQnB6eQzPssEEhtGuK6TmMhKrsvefmSBNRHw",
    "AqHCh931Tq752GoHESJnTsRseuHTJS7m1cBdGDupFHa",
    "AqK1mRJZwjtTUcQWYEBD3s3zRsAbCaHfTaFhhfUT4WWD",
    "AqTpTjTRGp4iWmdKPEvjDJeztD3VfNB1gxaDAaT4fvfn",
    "AqVDw74fsop2QPUxgN6qsEw2Sxo9X4PaJrkXjBq5Yutv",
    "AqWf7FtuRohVtZUgrWajrQVT29CFgE7URMoZ27MYimjB",
    "AqZ7KMTYGueLio9RsLmSVJ4MCUrSFriBp5tWYfwTCrXu",
    "AqaKGbeC7CcAxdh5jRfs22TWhWQ9V9Dg3wMrDxudcYn3",
    "AqcsXahpcjnp1RoqaytYwKZyAxkwhYWyEbLvJwsXMYBR",
    "AqmpSbY1p4qHwP4EJnutst3yUd1AVQKL2hoFSGDE3jjC",
    "Ar6XTqWBTMt8hXfqE2QXn4Qi4vc8u6rP4AeK4baiX7R2",
    "ArE2vmfCezSAMfD5jAty62sPLZnuEBzCvjSntBGmfbeh",
    "ArXwD5G6MGT1SrniWCXrhASkt9AdcupxFiPmHdckC2iP",
    "AredJG4e5MP3P3e9ro5JG1gjsSgduVSsn38w2ctzs9uj",
    "As34wQDJXfT25CujpgK1RXcvBnY1vFb2UioAjKBWN2Dy",
    "AsBKRpXPJi2pzGJBY9oD1ix75ximfYB5PxsA5mWtNGvE",
    "AsSYneCEefBo2ghK8PP1w6XUMZNyzgiXd4zDKDBCvG9j",
    "AsXYjaKuyD3xDvjxgRMFewhkDRv6qTrLruEouwkmmiae",
    "AsafJr5rSotGuSK4aCQNYYVhm5Sgx8WG1ZjLM3pHpBFG",
    "Asbr824ZwEouJAgVqwV2CDPNbQiXZFDt9wtRP3PnVvgM",
    "AskzQ1Cg3vj5so4nsgpZZAJvMGVqyas2nRUj6NZBmPEY",
    "AspVdk5YXdzDGjLBKmXMm4mqEbuufQoxVAoVC6pHbvRF",
    "At69dmwpp2oQomhZp61Wnk7CTKe9Rm2P9UeRgNWuKnuW",
    "AtV9mm6isPrbC4WasHm4CGMsBokhG8Tu7QPPaLXZwH7N",
    "Atwv3McUZsf4FNrP1fKSrdc2LcRbwTiAFArbKo2A5b8g",
    "Atx1RQmkgPVdvYSHeiqbiyAva2aK5FLf5jJECVmoWTBq",
    "AtxsYnX7VoaX43iD8ydMi2TCds5oFA3VLdmKKm5SJrTv",
    "Au4bs4cLieFccdSvMMpPDRSGMYgwf9EmogLx3kN1HQE7",
    "Au9cRJUPn35HKpHyjiZbJrDrJUGjb7r4zMDjK9HiaKwZ",
    "AuFar5AEEz6NjBeuwXAGAM3Z2xiVh8NMJikiY83kRhfR",
    "AuMiruHcUaeGbg1RTpiJVEujbiSjKbGU6gzsL8HT8zh2",
    "AuRrmT1dRemumdQqmXdZXLJehP2moVcYnEAVsbA9RFtD",
    "AuUdEPwkeAAqaju8TWkrooDn1jTA7SMWRkTrdPp5bz2D",
    "AuZS2EbvYkgsC99dpocf2RSf2zHWAXgJKCL7dCk1gBtZ",
    "AuoJMb5VTXS7eo369FqJ8E1dnQnKJuMRzVb8LeB2JPQd",
    "AurzaYCdZpMqZNYhDJv87bSoJaFNAvhYtfVdik7d5ndn",
    "Auzi6FmsZAAeXhBo9NV8duyrQD4vkxzzAUugnEDJERQV",
    "Av7J7tEvdR78CzHHPh2oDU9JUsMwyYsRef2SfyJtRVaz",
    "AvCwoNjvpEkpt7a1HQpW9d6be4M7JJjnd28uZBkt43vv",
    "AvN8boH4uWtxL8qLew55SaKniYm9h8LYMnbGsUS9S9FS",
    "AvV9pNHpMY8aUHp3EU9ZfjhBtafQvpYk8SrNVy985s6t",
    "AvWjALFGzZ4UN4KFBtbS8zEq4UhymmU4FYWFL4QRgN5U",
    "AvbW1FvTJPoGkDbtnfzGRt5xschihHnvmp5qWW4xJtKY",
    "Avjz1hXNVZpX1NqHD92xyEnGhmnSEqhXnFWNfE27RYUN",
    "AvpgArPqx5Gur5XsCjT1WWp5mUW2i48dWNpAdKLr2ex9",
    "Avrm5Ag85yzHSBKeherYedeueLSMzLPMTwii81yZg4fJ",
    "Aw327gXPhL4YBoeF8oGnAx175ssZ3Z2Wsv8vftxVkJkh",
    "Aw3zx5aTUVAGvLg9eMhLLU6qkPfgSm1Ut5hgeRXZdY8F",
    "AwMaZ646EWubmg4iSMZpQKZwc1VpqzvioQUEyisCSa9H",
    "AwSws54MHVMma6J8bYipbHXN1RNwhsg5dxbUPhTRyqS6",
    "AwcyYoNjwuAAhJ5WruphmqyZQtVaPG6gcJH4GCq6acM3",
    "Awe5xTNMoDXDKWBmbDZFrCxReBxfnRgMa9ci3zUbsgSw",
    "Awpm3NrXEdRidmR3KNCT7HvuRz2GQnVqvTSp2xT2DeoK",
    "Awy1t8pGxAhvmDxaANY7XwEE2WP7BAcEdu9iQEXz6MQh",
    "AxCF9eiqVwGa6H4oVmtbZNTo39Y4YY2XZmQFF3Wc6Qm9",
    "AxFBwCnvhDqZcSoxsHwcqht2LcoQDV4MA181Dfv46NNY",
    "AxG9aSbUwZ88d1wUFULx4H2csuV6CAyVRoHdk9ADc7u6",
    "AxNLX7vwhCmTjMTXnXEL8zVBhXhVvE8DS9ZCYWhLMPiq",
    "AxPJzxMKRstgth1GAYCF4Y8Jq62yEH3YztcUy9BCjxhb",
    "AxREzC1GgWnomGVDcFqEgQseM18G5NaVyDhMPkUyNbZh",
    "AxX5wwJDAVRAQsEZyMGfdBgcDLbWBoECHNQMZhkGrbVn",
    "AxouMje1aapx5LLdcUHT986C17ncQyxW7Ldt9NzWjWof",
    "AyAZjCvzcQ2cc31iNNyys2XvppTi99DVgDzK8YaHxohN",
    "AyWH1XPhvXmwKaEi4HhXDfDZwee4Q8TucoQwHr2vJfPJ",
    "AypxRAPgMvaVS2V27rHgCuh8bt8gDnJVN4E2nk5LyJuJ",
    "AyqgRhekqV4BtZbMi1R8tp8DSmFqth2aZteVJWPB3zbr",
    "Az3MVQMn8tismLaSV5c4qwnAup9UPzW6io9vssTU5Duz",
    "AzBWj49rseK1wD77qraCgSxmv8umXHFeivwvUDizCTnU",
    "AzJAqJTneTdQoLuUvMNmTuKrpjFKZoq9GjLuGEikMbQA",
    "AzQDAU7xcf7ppav5jLaLPevoQc1XKHi1sqdJH8yBYPcM",
    "AzQv826prKEm9m5zBswTUiHgNNtPhWW3YX7U27NzcrMP",
    "AzvCQ1iwLQhXc6FkFfn2n8t92BLe4CnoAcfysra8tFLo",
    "B16RvG4oSpdfW4hDWrQkQg3YeL3HzWFZ2P3VJovDUucJ",
    "B1cURj31YNoWzXNRAorD6W97Fzgb2vp5FY4Ngj9CAREL",
    "B2FynHLmmhQfaE9F9PpkaDzewreP2dDtD4sqJTCsrSuT",
    "B2KnERNCz5aNwM1NJQZtmUC1ybifU7tszrRrf7SQYU1m",
    "B2SQNrYFqiHhxvCRTsKFGfsTekXum1gQRpvw6L9Z4v9Q",
    "B2VSzuXP3HEHXmeGJJNZUQ2LR55kXsxqmj5xtKAXjne1",
    "B2b8VLk9LQfTX4e3PkcyqHNosCHH1R6R4S6SBA1Z99RK",
    "B2coYY7i3auXjXmnrDR6HwXzdzubBsEYenU8sdniQuEX",
    "B2hCtwHp9zFn8uAVB52V87soGzLt9DkVjNWELJjXbZBs",
    "B2mRfHbMxcpLAbLPr5S49hnSzc6jMJJ1wzRT7uUBU1gt",
    "B2ngzqSTiiazRhpp3K5fbeLxrSqWZUdxk3C9HYDhHawh",
    "B37tvDtsqtCgfFjJXHkBUPJqi2M8ZPctEzEnuPonjXD6",
    "B3KowypJGWDyTcj2eUjfTCvnqdmXzBect4KbUFqYAcqf",
    "B3TZgsLbHpGyUXY3qWVSocoyWADm8XTrNixGBsXCJ69T",
    "B3x93ydrk9gA6R8rDeJrEhMiYHar53mk66DbRAsfd5M4",
    "B3zXHaHQVYLs6mUC1S9YnvCw2Rhw53dPSQR1wiPmY7ym",
    "B41xfx9LupwjeNNe8fBHYvT3hpw3si2QSGivWViMaBoL",
    "B43Cz6f2DxBDZm6UQgNs4Y6Nuh8B2VJNZv6HpnV7vUzz",
    "B43iwtEQsG2ZBGufTMhqxceMz68e1Ljt9E3be38np7Ci",
    "B45T8Rn9PDpE7oUnhTFmn877Dz7TFUdaXiVbPs1RZewK",
    "B49gZGiuacJDdvwSUiqoQsn6dXnMNGNsj3dPAQaeVUPR",
    "B4Gxe58gGzF2BVqrfNcbK2xsNCThCotPd3nf3VgTD8bn",
    "B4UaVKsJrreo1MhvtM8NsToEB6SpDAadRqf9RHxgstxo",
    "B4mBJ6hTfdRzSxjZ8N4TNJeYnpZVTZnPnvKCuUxCJfM1",
    "B4qpB9z1bHn5EsxPtDHmmBX6nXQ6x44DMKjfADL5fCJU",
    "B59qqNBZy8nJEkE3mZrAkTH1Nkziyyr7cBpUUB9WWGbJ",
    "B5BxGLmUH9XyRcWc9oW4AF31W7Fg6XKbPbAxujCJBWs9",
    "B5JEn9VuKaDkAYSddVWvTdbk8CLStmMowgo3kZ2CtwKo",
    "B5Mn2gAsaq5s1Lh183QRAcoNscCPe72UWkUhJFp6EkRK",
    "B5RDYbzdEKvdKZNz1x7YHyViXnMUT5MXxJyGLzGTrJs9",
    "B5Y1uqmmnwMzY75qbdM12ajJeXgb5HsEXHwCHctmu1DW",
    "B5a8Qr6ctSXGwVEG396rWGFwPv8XqCRiikifDJbhUARV",
    "B5dKYXj9LeUPVVkLUJi44pbhPEa54otaxeQbamCvCrnc",
    "B65WKGRCLSwirD5RhZ777o5HkCJhu5uJftBLTqxeQ1oM",
    "B65jZVdeFMzNRNzCWT3xkxeVVjeik5XYr25yjSAm5S6e",
    "B6TPKCsxtHSEYxhfjRZirgfJ8VdvCFLivyNyUXir5ay5",
    "B6Zbq1Sz36zvxZPVYaErroPiFw1NK3KcPCSR4CVmTvK3",
    "B6jYdBRmxyNVnyDhoy1aDWKkXoyKAuzVZZiX7xjTMpCW",
    "B7JJv5Hp49wBZb29o8ct1LoNpfL1Tn2shs8UDdHUv2E",
    "B7Jf6guknB5Q21zCDvyPXAFkfd77fs2obGFFowdYuev3",
    "B7P35TLKn7mNkka5KL8wMZKuMQPu3axAqJ4dxxEnF5sh",
    "B7wCsr9eh4ZeVkwZueWyFXjm51VvvP9jMaVU7oYUCCF5",
    "B834sGTEsqNufvShA1ZrvctYNbbKmK9RyiDtUbDjQcSa",
    "B8C9GWvXX9prQKicqGKU9Wzqnp5zz8PFJcjmV9AaTZz7",
    "B8X9NWPgTBe6kh8mCQTPM8oVtnCDiqyTy8Nye6JhDZNq",
    "B8XTMhn8pRxR5DLfJ1LYRMDWwJGKAfft7ctSXtf2xjiV",
    "B8YfKDx65DjvnRFtkyXeAmf2FdgjMpuYdarbCw7emZqi",
    "B8gQexRyUrFT3Q3LK99vxKUBZQj7xrngNCPgYYeaAb2m",
    "B8z7DzMYubhVwxC2V32tHfpHs5YTv9dCsF5ZVFBRypP4",
    "B95SY5EVQaWDykPNH54QpKn4ifBLnkuB5gM9yjXwBvo9",
    "B98gM6yZGnDqqMmZBfVfcbQiaXZ1dq6f6gzP6AwvrbGK",
    "B9MkenJjd6EwAQd8pNTH6SZbCfUDDTk4bPXWYB4hM9Jp",
    "B9pdTfZ87eQ6PcyCexjm4kk7Sx5NRf5mA7GaW7oNMVeC",
    "BA6Qo9kTcCdgXqaH4ubksrVogE3FQWJgx6m6W1sbE7jd",
    "BACETBqcVvry5xHCTJJqpPS9nrcx6FnS6HTwoCqqXwrh",
    "BAFMX9sGTVVjYrJdWv6wvq6XCHunaLdDMqBNtL56omF6",
    "BAGvvBmDuEFz68fBrsxTxLzeNUcGuWbi8nqeFq1tQdez",
    "BAHDTSdBAS1dKbQ1fA5F8v9MQ9gHXwDKGQGyuoCWV3WN",
    "BAJF1MP9roST7wFB5ZndNC8ZecdnBrsXtDSsgNPAi9Np",
    "BAJfofwX4BFnUhgbmud8VWxG8r3RH8epCujH9ycER7kP",
    "BAPJcHb9WRkgWsbLghuoecwpUSC2gGcKRx6RT2QpJhKt",
    "BASG8sgL4RyNxZbRTKVhreWo1wfdoxRQGNveskYn3AnF",
    "BATmA8vWuP8TdqRk8ogU8sFzG26o9kLBb17HXLxzZxrv",
    "BAbsbF1pYbQDfAgazgPLBfFKfN6gSnZbFiDhtczfUunj",
    "BAn7WaK5Gw7kcNFTHMrMYfYNFRQrqPZ6yABTbXg82Rtw",
    "BAwPhYH7e78hk3Cznxiun9LTykcc65b2GMVjZQCx2cEw",
    "BB4c4eSrK3mV2FhiwdQTCRkV5Hco8THu2myyPe3ubdab",
    "BB9qT87ARdFJT5bWYYibsogmvtGjrkt6fjckXEmBsFAm",
    "BBM7ztfdmqQ5SGTza14wEV1Ty21d38v4DDJrzCJwp6vX",
    "BBicW6mzCnWwmmJMJrHUwNPvyJ7Bc2piS1dPBpZZMzqg",
    "BCM5Vt3CQJhq7693bcJVi5zZ553o6XWRLvtirNJ3XwMA",
    "BCRMN5B3GFqHFfxSMcKXfEFW5cjsQQnTwpf8f9EkvyqP",
    "BCS5Gjoh1YBeqqieunZy6yvNKoj2tWWWztXBhfZC1Bwo",
    "BCcNSBhZGbVTwd3nEA3ikbpzvUwt9C6QjK5WnwdCFvHZ",
    "BCm2Kxg8oXhqFYPqHhAoC2JwFd3xSyqvz7WcAxFD3WEy",
    "BCmSUdEfdGx33zPf24ECu1XfvMpuBvSHps2cW1CjxG6",
    "BCpptbV2GVbmZoGoSiozqjkU24qaJ2pGHLSYiBSj36hP",
    "BCvGxgN3Z7xNfkLVqWVEwXEE2rVHwoc8p8RQKyicQpWY",
    "BDErUR3GKewzrhkLndhZJ72oGkXQ8AiMLMsAwc6PzAZr",
    "BDKWDKCeJY6RB193FxzJ6XmJELj3Qrg7kzToRUddX4ZV",
    "BDVrLTXj7JieBTJ51Yv1SedYfK8ddmYCFeJhnYCoYfUA",
    "BDcCzqgRBMvv31AXd6cYRzH68ncZi8tW7NZJ53e42CNc",
    "BDhV9qrBKQ2VMvRubDJbpQAFZ4iF9ngor1wFLMEXGK1b",
    "BDkQCQzL4RAyYrdqC24tQnLWc42maFMAWjZiqUpkwdDV",
    "BDy4QrpX1eSUukoUPUVKgbgogekw74WDejvcQGtieEaR",
    "BEFfXhHPFPMiEzB2kdPR8aWGwEAYuJEcueTQVzA8qX7x",
    "BEQuqFELDbS3KxxRauXakLuAZ9ss5vgCvXzWj1YiSGpR",
    "BEUJdETw7PkRgEKRa4bwiETb4Lkjvc7GMsP6M8V6FmEc",
    "BEZR3gnnCcdJCtdoXUGU6CGRDSXZ7zeeFg9hkfavQgAM",
    "BEbkFqR2VbNBfEEQq27gVUBKpxoY3yDfF9sF1mGPekxX",
    "BEh8hJJ8og88yosfZ7ipM8HsLXdDocF522hQJTPquTsE",
    "BEqgc2AW5RiJHvd7A8yKZmTaNDa19gitm7s4yqKrUCHp",
    "BEsN2KWHFTHKVFF7TiXJNaxiQKnJbbuSJNBdEptZCwm2",
    "BEt3v15K2X2HCT5Y89BJPzt8K4QUHHZQMeZLc2dUmM9K",
    "BFCxQYQa47Yw2gyW9rnERkSfmiRJcaJkbPXk5s9YaEhC",
    "BFMmo1FgGjJQYwJUjm77d3DU9NQZxPj1nRr1JWyYkmW2",
    "BFNg5UzTVqZeBTXJoZniK8xi1Tw7NMzcx9gx4WmZB9ej",
    "BFVKQeqJXfEsZh8szJqYx1TUGVNsRvhsUmf6uX2jRnhC",
    "BFacPjUDjg8i3rhxT1aJstiohTAutShQoFMxRthje5fD",
    "BFtBVgrRQPfgubJxUjTSoMM1NdqUzgEimbuYV71WhZkV",
    "BFv5P77oa1Xuv82CofihJgkNqu4VD3oEQX4UXo4Mfy9B",
    "BFwuPSK1JYeheS6qpqzLYku4ftpXSggNirbJ5GbVPNW8",
    "BFyYyrEwSnRbDPAChegZaoiDUqYTFztDtAxPRD8A4mex",
    "BG9YtuxgPo4E5CniQ9jQs1QaDFPGQoaXdLVQC7dsxAh6",
    "BGChFTKmqNqs4YhtQuAAR1PsYJ5fEcxFFS1tW6kbpJDL",
    "BGPTGLLaTtxkn3kdz6oB5SMT3bHphxPuZC7sfqaABWQQ",
    "BGQ5jNBy9YRsrERoAHPGyfu2a3EPKiDJA6cLoYUZvQNC",
    "BGTZ18ezPjNpGAnneMbkz8SVmRAHT7ZGEtNDf3pKaBtx",
    "BGYTQ2M3Z2V6XZYDbADdcW793Xasa92W6fjSwE2b2V2H",
    "BGivEPyWbC656akWoqetbrj66zq9iCDt7Tb6uk1vDwwu",
    "BHCV1ffLqhRWVHbXjP2Z4quC4gqqeXs2vvtRAGnbCGAm",
    "BHSgHtLgaDXBDRVp4nq2BxskZNRpeSoLxvE9ddx7RtV2",
    "BHhuqbae1JTPsZEPcwiokojTrpARW1RVVYvWyXuN7SAj",
    "BHiwoz65MJ2JpMxy2gj6RUQwtDhRhCLGuZPaT7UGsJsA",
    "BJ8BothTZhJjzKMNc4N3zLMF55AS4JdeWEMF5AQTZB6P",
    "BJRo6Bbyc51oFzLeZndpSLZLvk1u2u2nT9TDNbgib7EB",
    "BJpjhExoZvdEhUEcdDBAhyvyUaSCMwERAtuJpwXyPvyY",
    "BK1f9SGn3XtzsDdVzJMWP5TJUzgt8VC73uzGCbugeKip",
    "BK2BnNSoDvdRK4iwQenM5Dy8iCuLkhpHKqgBEe2iyGWe",
    "BK3ktneSSehFhNXwc1U4eHpiUFF3m9MWMLgSuycrHRb5",
    "BKH5JVMQKJRWSndYrSP7wjHZXMFJ7dZNpB8zAk1x1xT6",
    "BKL125qJoyTsBA3ydC5LGmmeMNf75brkwAAR7Vfghbo8",
    "BKSgcRDUXPpuyXNraJb4J2nWHCq9wyWYj3AqdSftQfuX",
    "BKYvrXt69RxczXqXdvKRtj5cvhiLaaA3UuYYLCZSMHHV",
    "BKh3aaCwxbw5XW8BUaznKxDJGJM5XN6C5jaRfiuwhBwJ",
    "BKkvPkLjRBipduYvwft7PdGGw4zXameDhRst57JQoaB4",
    "BKyPVonjs2ZiHd85nv8nMhJgiFWS64FEy93nAWVEbxXA",
    "BLBC3TeKy9nU5VRY4ckVMXA9TzwVWVZ3whaRSTihAt7C",
    "BLNPAutLUEuTEBd2m57oGBAaHZZH4g3LPUoHZbnKJvhn",
    "BLbcSo1grAFYzEAsm7MzUHX5M6YqTz28xqfFRYWsC4HC",
    "BLgyKbDUndYhsXzd2PiTSDW2DduUG8BdbKUiWjXnRdt4",
    "BMMrxoNbFCJLCktXtSArALVh6QChqM8DkkbNxrrAfheK",
    "BMRE1h3Bwu9yg6ipZ1SygiZMyiZ83Ja3AUXxmkvPYaen",
    "BMWrn8DtCCWamc4mAUp4fTVFjdNgdH9bzj5FLGiTRbiD",
    "BMr4CfTY1mHuMn861A4YUPyYoGGT5mUZXnnursaF1fZ6",
    "BMtyVaZMeV3TpcmBUCsrixAtaqkEqcW2xHd4H3yeKyP4",
    "BMxQnUwMkUZGwLQB6HoXUyCCk51dCCUH42SmVv3Fk9Qx",
    "BN4GC3rBfWj9yWACyFCzAgpauNkKzFwv1pRhe4EcscyM",
    "BN4m2HWvpR5LR2K2g8Uj1ShFSVnxZKZnDmxWWT95PsGs",
    "BNAX4q7y1ff6CUD4QczyBM22fcqGWZFRYoas77zmQRrx",
    "BNDNZaTVnd51MeTJgCkjtYWY3ckcEU6B1Pfwn516i37f",
    "BNWk77piDXG2RDFekv2WbhnE4wiGssajo7JL33WkoQda",
    "BNYjsdXCvhHauJdRM82Q9ioDVvSpoYQpxSKpAFMoeZmd",
    "BNak8HGTdVPAqkocXhpJ4rsCXzp29PFAAMuaV29MatBg",
    "BNf3DwTtsPV6hDGyzUw5TPLqJdwTPHdcA2fD6fmq6fxa",
    "BNvEhzyAwCJrJjPkLPuo1MXvo6YeZwnS6QaDnbtR3sBs",
    "BPSHqZ79JkkXjq4To36SvqPXD2a2mpcWFEgGqcBgcX1V",
    "BPTifFnQmXYGvZck7rjCARhadu7hkDgqm3Uxq4YJTssL",
    "BPnTd3hDh22EcN6JfotLT3ghvH2KZDis7abVrWHT31Mb",
    "BQ7zzfThpTtxDwddx7fvtEJZBeMJCyhwnbntz8noGzsS",
    "BQCxixyLxan1895gjDfsPjp8ZXwZUw9FK1sQbCEFjXZZ",
    "BQTeGhx1D4PXEUhwJdgRj5iKaPGjVifDT1xKgJKurNAe",
    "BQdbPR5EzHmsyqPh7RbAfnCPZASue5tZy9iZFScoSBjp",
    "BQfddY1DUSicvS2uCKj14TR17x1F9BVw7q477tKAiJLA",
    "BQj99cJVYGmQ69hRzGis28cEQ5f8SNJA7TByY9WLmahr",
    "BQu2nqKtUe8FFnQ3FrzqE3wen5bnYbGQeXRxgPgg4Qg2",
    "BQuHxefwTUHaMVMo2BzaAPi4aEKCoB6pc1bsBCvjaUm7",
    "BQue1yccjdSbbZkGRcEWkQ42xtg9UkNGcwPkLA2P5wvc",
    "BQwEUQ5bKNVXpbQJSyPdBgVjpmxeH9EdVkdNVdQfFb4g",
    "BR1VpH2SefYfpkJYdLAJQtaCuHk3n6CnyyuPwLsHtRQ4",
    "BR5G6ykcmRRttBw25HiMuGr6LVLtrq4DkDFLZx99MJL3",
    "BR8pbpHpz4ntuj2Y3dPusGUwDmwPmSeX2w3Cgtp9To2J",
    "BRWmDbeQm3SS9Vjj4eqabDhsmEzUMny9uo58w21x17eg",
    "BRaghgkTSD5H1rJWPKMj7UKw184jAfaxBpKsWRCTv4TN",
    "BRq8sbAxmexg8kGddLohUpxCkypVHREZMBA3GKPff8Rj",
    "BRuz1Nor48ATsHZKSRSDY4kSA36AY4kbYWUdScDV5j8b",
    "BS3iP1FwSLgaiqFKMyXebWXacTKYztaxzvzaJCMvVcuV",
    "BSTdjpwuz8wHSD1qgYtkjBKtz7kViUTUD4FqntK8jvx",
    "BSZzkhmFCn8KHqnvaFAdf6SXm9hPahCgjmba6zFG4Fko",
    "BSbsZssgUZC3ec3DGhUA2QGs9t6VE7taA17XUZZDGa3f",
    "BSgEMgVHNeVuKDnSEDag4d7na7dXTBHRnw1wjHcvH5HJ",
    "BSgW6JVSJJWZwvLxXaLjyHwkW4eQywzKRuZ4tTGEh3RH",
    "BSma3GfuTWEa665MNv8TbxyLV8gMXB9sAEkx5EsBktx6",
    "BSoKBQvYPiSsGfkHasDyFHxs9SZZYq7uW8GJSWjeeU8g",
    "BT2NZ56zqXVcTecYTyjSPkYPHTXQ8V3Kepin4vMbZyas",
    "BTGBurx7z2HaPWW745dvWyQQX2WEzce9vFcNFZmW8HA9",
    "BTd3g5uHMqQfbbm2yibzQM6Nr4mCiFcCVG1bbtTzgbiB",
    "BTmzpqRhcpMTu8AhSJM1NfJcyUfBd54AojycLfbyVF63",
    "BTvMZdybRzbNwVWKyXjo6CLM8KQy83Cfmb2BMuHZZP1T",
    "BU3iqvi9Ce4fTkiwu4RFNN6jnVgi8oL12KRy7YhTPDYg",
    "BUgzDSfkeQEr4F9Y2XjsrtMCdVVGAtsaozkQMDhX14dx",
    "BUsAzL84psD1CE2qWFvKDSV8ZXmFtDcJip6SjKDyoQZs",
    "BUxBjdj31ZCXRpVgSYFbwECMUKnJ6NukrorRbKPksSGd",
    "BV3B7mJU1jzdqp5K4PNCErByghyYjFFYxdAAyKLV8618",
    "BV6vE1brYAkF3qVznPPPFdQ36BRCGf9TErTj6ZtTY6z6",
    "BVbh78Wx4maKfBj8ZiPHWjiazEdmhQX81nEbv9sYsXd3",
    "BVqt5DjkRBDn2G4UsM5MMkemmmKcAkGDC71maGpuM4ra",
    "BVrh1tLP7aze7RhRB35PEfTFc77RqfnA1aS4CVy8DCXL",
    "BW3j9ypjRR4dvu8n4RgMSKWsJEwoaDJf71eAibXV94kD",
    "BW7MQf7uTjPNNWwynjLPr19Y6a2FPa8uhSRv21HFQNzh",
    "BWjdabSrKkTWMiVUJvNpneCTtXZoE6TgWKuxXT7CRJD9",
    "BWpmkFQaVYK1jXxWRhc47SS3b1huzEpVHXpDTjN1dyF6",
    "BWwqnakYVZX7zQioiRKJKfEhHyGkszf6ktePDKjdwP3o",
    "BX6LnGut5B4VbS7qR11sXeZJEQ9NNwAYe3vp9DVFM3F6",
    "BX8UNrycVjGTWwZi6gKPQhsTz6yZJgy29FbNHXKCnrzv",
    "BX98HPiNDds8cKdEu7uQxcscgNKPpbgayXakRU92zTFy",
    "BXBWVKXJYbQQDY7VJWaFGGm4ZEpWLgLSawyVCYH2CSYE",
    "BXFPq4ocDbVbN41ev4F7YyRds9SqA3emQqAV8MUh3zcy",
    "BXFewZVTAQ19zsEVJiv57N2f4sGiWhFdBzQVJEkC9sgJ",
    "BXHgGrwuakMe7z4KZhLwwrLhbSTAeG5GsjPgpDeUY3K8",
    "BXv2cYozfKTfwnwFMWKrjk1UQX2f9B7non9V9UH8eXnq",
    "BXwLsV6rgtjYQdvyGXnn4R29np6XWnwsHZnjYXvmL2yC",
    "BY33GTXv1sLT51cJxfvfEPAjBJQu9ECwyJiYCkbkoCvu",
    "BYDGrhGLxin5wgyvPbRCcBYSGPfVnmmWGvAUDcuFm7zm",
    "BYJsWRH9UEqZMRPutSkKFN6Qud8HbvcE9joV9gAMe6Vr",
    "BYNDQ2F1VSZdM9MqEAJCcjNhvVAct65HTYgD3h2VnCYy",
    "BYV7eMGVM4CbmBJ1Tx1doNSprnogAcqte7iSJsg8hgYP",
    "BYseo3YDEY7tC5tPVVdiK3mYrMkuMNTi2DXzTRF8ksjD",
    "BZ2721sHEhWpGGqZRi61uRMiRMpJ8CjKmWZtnypZTMhi",
    "BZPmeWFnfE5LQ1x3d1E5CiUAdfwJ1hyZ2dn8AFDJYJc4",
    "BZRHnhYBr9V1i8eRbnTBGgk8Vde9jRBvPgLN3RMrVuzs",
    "BZUScoeHcEinC65FmMpBaDbmwSN2xpPLY5eJZKKXwp62",
    "BZcf4RMVZoNF8iW9aEoKV2m1Nr4Qg5RKfagJXhSirV1n",
    "BZcrFo98Jf9U14fYK3iwvZVdJpW4H5G3mtuiJpCkxU9z",
    "BZgXRbBMeHVKpn7ZosVAuJAMWTRsDjYzke9aHi3DEHmB",
    "BZwimmev8gyrtyBFbTG1gzUTd3xiQTv1PtRGtXEtUMCa",
    "BZzPidruDUMbWSYUWT6NjTPdnHmBzDch3ydEtoEzxwXy",
    "BaFw1tDWVUxDoXxVJoNycrctqpvKQ7qB53tS9n6PjVQ2",
    "BaKTtu8xmQMWSoLWteCN6zQSeJiv9btPmJSkEn6rx7Aa",
    "BaRLTzTtzyguGvfDHRfgtpRJjTyukLyWKj9tpUdrvrcp",
    "BaYkpEKa9bCRjf1ox55x32rzJin2Rf6atBDGTiCmtEyk",
    "Bab6NP8WeSxwca42jwUa9ZC2BDX5nHycTiVZ91nzTtYU",
    "Bax2CYtE7WoTNE5vqgkGZZoGXw6jhEnRg4imxjrij1Na",
    "Bb4TksGK2XKvdRnYJEFKAFi3Wv2zQQHTpkqoFSzuBSUy",
    "BbBPykYmtkakAKmvgPXRWsdyeGVKreRLNkVbh7tpEV3",
    "BbGjQ4b9pKh22dxEb5HTNJ5dtuzy51XXuYxwUT75wyCJ",
    "BbK6kch1qnjE5kSAj4VW1RHA4SLtCK3fWL75T8SsZoVY",
    "BbLFJTuot8Ub6JecZEnn4yQi93GN2ZBjnHDJ4CCaaoS1",
    "BbPCZzyb99mx7otBMfhZr4CQYnk67oDdAcfieE6QFmFr",
    "BbcqDwgPW9FKD6fXGzEGCb1qhKDfBkiy3GAAm21wL6gg",
    "Bbq3GYffi2rf2oG3AkWHdhiLDGtqAcNgPSTGQax4B7pn",
    "BbtJ1KuyyBEGKmJKvoTSbUYMuHLGUv1gwSC1eaKgTUNs",
    "Bc9vPV3ZqcV48RjHP8xe1bB9Kphd6WqY2v2aFQhfNkqZ",
    "BcAAJcyuvkVAVy3hBJ6V1NjgH9WCFcFA2UCsa1E5N5RP",
    "BcFezKh2qR9EGssFkFTFa7GmacN7eF5sV15ThEEMmGWt",
    "BcTcVwUvpR465xmtqjgC45w2jXQRHhADVNW3sZ9j7FmS",
    "BcTx9Z7Zezik3DDPmMSPwVJ3JLWzR1RvnKfs2ynDFwkZ",
    "BchyKpVJWVPV3GdQ2LpcmWoq7JgTYKAfXoGbSUcz9qAq",
    "BcsUpVex79UxgfbQUWMTUhpfbZaL7q8gg9C8jLeCBW21",
    "BdC91BP1dQv1NugHHkggzRvs9fayWAdRsLShhy1CTkE3",
    "BdaZuH3rXcjAzRvuGQEWRQt2FXXMLdUqaafgPLZ8oXNN",
    "BdiUM6WWK92sYWGFf59AxX8qrjqLrowh8Wdsbhft2GPh",
    "Bdwk2aK5xCVNcuA8RTnFGXStCgSFt64eThZR1uWeSd6B",
    "Be5R5H1u1v4khD9WCwYSSuHx7AsNbd5kJUJt1oxHdZFX",
    "Be6Rarvj3o2YYu7rKXKnLuo8J8TR7uarqBc8FcAaB4Bd",
    "BeAoEPRTkEST6HHgfAq1QgVfsrnChareyJwqkFexjDMi",
    "BeBB9ZQcuEpb5avqSjfykqcpsTp8HmSSghcoA5ncjSHJ",
    "BeFgbVHbdFyMRiXSXCkXSUVEmos45zVqsbmH1tR4LwfM",
    "BeqPDR2d5UAUkfZB9qUDPmh1BwMZ8ApnSVvmijd2GqMt",
    "BequaAZ4E8JZPyoG9Gd1VzfqBQGfnFJBsLwv3Z6zXaM",
    "BeykFCq5fxCbdXq2TKNwDtvkSifNHdywMhVGj1thUtZb",
    "BezfkaSzYVfsc7JRoW8enRE6azNvViqyXNTZYMpwVLmA",
    "Bf6euvzyuE8dAxPS15V2sjtFBgFjmRD7AEf6uDbVfzVh",
    "Bf9PN2R839daMMmwKP49zqdNRSSfkUj3fhTPX4hqY1Ec",
    "BfT6tG8uQJcS8gDV4FNg31upufKmnRtyALVNZSvVdpwe",
    "BfcaihYtufCmWXX7xG4AYETkEYnZ9qCNkJ43c1BVnVp9",
    "Bg64ACc9GyZGYCuAbXWeFypaQLsiG5EUTK1C8bE4S1AM",
    "BgEAjwnAX5q5NqAWH26wYX1KeBvjH9JL4bvabZujcNVJ",
    "BgSxVonNVMAV4sUEzLtqj6nxBw3n9YG5JSR2XcnCmmrb",
    "BgmjP2ip3oq3P7q1LyyTaK8CcMYUc1eAgaimiqn9yVQf",
    "BguhuniafgLgvztitw96kuKK5R9Y2tih9e81rzgnynVt",
    "Bh5KFHTSgvByALddo3quQoDRQwTG57FfQEV2Wp3NDvxG",
    "BhALGqXnXV81ZpGRkKWsfeFiwfPVDqxiENzxLpoT49hJ",
    "BhMN4NPbhEz8wL948U9MjWiTEVBaW66ctU2rQnzeucgu",
    "BhNA8C1mgT1qXUHR8dWfqEAnBfiqPnzqBA2Q8Y6LfhTA",
    "BhXj9saW5djqQu8ofmGzwEh1LWBTdkEXuW4jPtX29XRW",
    "Bhba9dRh5T7picDNKTvwgxr39r9Q9QxvXKXxNUXJE5FU",
    "BhsjkYQu27k73JFpkF8UQfYyrntd8JPA9XjCxve2bko",
    "Bi8avdSPXqqLLbrZimesi5QxeuUHhoSHgNWqARfNCrLK",
    "BiG9FrZxRKorcPjVYcEzmbdBG5G5LcoeSorMULwNz6nx",
    "BiNo7wDwvNDUdGoksUCD9ctyaihBtsjnSudYh1rNbEPx",
    "BinSgKZFrUfe3X7KtNFVHJZQxJmJGufBySKidSZxH9Nz",
    "BjA9EXgdqTSaZNn7FV4W74UULVdVjFUDRzkf3cq4hfAh",
    "BjBFydP4g42xMm4pkEBmkqWSjQJEZnC7dwyGDLfjFoos",
    "BjMLK4Kjntn5xzjbhujzcCG4viWPYnS4QSa2MGMCax3u",
    "BjPDHrn3ChYSkLbW6KPos71HbrQcArteW2pTxyk1j6jy",
    "BjUDe8c2cKmmKUmboMmgUZcCXdexJevzwbyXAPTLwxr1",
    "BjjoVy5qm3i7fKmq5CjnY3HovLZyNqrf1ui3YHwBuRrB",
    "BjrwAfmp65W4EHAV2G7b2QyQ3N1faGw9v1duTzvg715s",
    "Bk3EMFbxFJPYMLYhoLmsTCnBpR95yDyhjgqyqYypUSf2",
    "Bk63jNKhzqa9SpNPtYoQKf5PgXqrNypiyrDoSFnLv73W",
    "BkKM38K5mKM2fAbM7ETZs623nwgnhFtHVGvLocyftpmb",
    "BkkXfAZJN1fK4PD52NDdCruDywVsBap6dzcZLq677hDy",
    "Bkrpk1qrMPmjHA5ovqvFAv76mk734QVbVWxVSAZYDwdD",
    "BmUpk4m5cV1dXsHji2qcCf1zMquELFfvozMATJKbLJQs",
    "BmqbVkBmszw5ybQnt4WU3ivSBSufCiqVgaAUgmEWnf45",
    "BmroaT7XHL8Y2poGmETr9NCbTbfS8fxZtkxoDpsPg3sf",
    "BmytGvZHfArqtDct3YJfCFFzUDPNZcwDeK8875uZ1ok9",
    "BmzovU8pMv8gsrnK6HXCP39dFpdTPBAw38YkjGFQBuu5",
    "BnCwcR9rk3mxtx7DpTRa67EezVgCdR8LSp6CzBhntbr2",
    "BnV691WxxJ3t53JVd74rbQubBbEVQv8Fbpu3ALE6iuCD",
    "BnYREFYKjebPDLixGma6jfFLMQp9mEikf3iTRjBK3jcN",
    "BnngJSGHKTq1oYZK8LzrrnP4th4TRKymY1wVjr7VBs6R",
    "Bnt9EPnrPUveSQ7FRzCm46D2ZUnCGYu2iTnBEVC15id7",
    "Bo1hWv9PCwHkUfucnVwChgxP7dobM49bX39R4Cx7ZbGp",
    "BoAwBdmYqrG9xLn29NrwKHpSfXXZpkbHPzyWAtzL8XWN",
    "BoNF1QK6N3rMwQNxqPq3ionD9bNdrJJeBSRJhzjWFDkv",
    "BoVfTTxsFWQTKdJmBsSXM2mupVvThtCZpCUKpVtork1Y",
    "BoY3RnA8HTK17BxXfQXTYubPm5EP87yYx3HsZir28SwK",
    "BpEfCg14cssDb2gpkE48LL7mSMb5Nv8oCPemr4YqyEwg",
    "BpHfCjwh1qCg5qVCrLLYEXQT2M8Tuy2xceQRZCWkvPFm",
    "BpPkcP9sAJ7RRiPSYM6DPNcypk8kC4uRwpq9CaCk6us2",
    "Bpg2Un7oe6iex55XHbsUndYXt4qYLKJkLrpoyFdyDVub",
    "Bpjigy4q86AZhDZP8vdHpyf8U26XXNhmyEoxLMvzni4Z",
    "BpkemAAJyMnPMxQUuKyfYSNRGfjfETFHtoKS5QCuvn6L",
    "Bq1gP3E36dYZggYnEQioH8cKzjn5RQDja5F9n9nZ6PwX",
    "BqBdFKhqSyaKp2LzLyXC9gVfo7v686bibqp68fiWq7b7",
    "BqUZ2CtgLdcowxWMqAwhbG7cCtpsr4dvCnLfaEBewYis",
    "BqeTqJg8pr1NXoAqFdHtqnF1ESqdTjrpeDGFAXqjzGvN",
    "BqfGZjE3tZR5noGNCxUFjiZ9NbvEpWkoaVCXYW2DuXjS",
    "BqmhURf2W7qVpXDLnxBqa3nN1NaxrAm7LbQVbTwheXWt",
    "Bqpotzsd93sAyHy6RMeeKvwStMJgnHJuGYr6PsjxW7RH",
    "BqrF4cCbJW5ZbsEEyHvwRmF46ow33vLw3mg2vSDYrUje",
    "BqwbizzuV4VtS2FcaRrJ73hPKfdeU7rgqDZ2PrgK4J4J",
    "Br1ySKqqmX483CTWQRvR1RVppu2jgW3yVxP6ce24C8WU",
    "Br5VnXfSido2K5Qr3YtstYQHWGVHbj5BqUjy9XnGGaDz",
    "BrL63tpbUxdabRhXTkYaQWQVuh9J59xokNLtfhZwx65M",
    "BrQtgtVhaabdMEyXtrRucbTNKFpBw7MsmcjR8HxigwLr",
    "Bra3fcKQRQtLZLPC52tZChxy6wkRgaLdY3ZmDpj2sxt9",
    "Brf3111ZKD5b3ibq4psmcAcuQMX9peYsLh61X6TpTmi5",
    "Bs6DGu8UZJAhvNyGXH35s99GK88iAM6JfpZ8BYN3NYZR",
    "BsEPuQJdMAWpr1jX4tTUv5XkV1fC9yhVQsbxUDf6uN7p",
    "BsF85vxLEFFg46uaDTY5XjpA4C9YYU8N6Pua22MsTvKy",
    "BsMM8SSzJvkYP4qbXFK782sZ7f4SvRZ5Z7UiXZRsdwKq",
    "BsRM2sHqWediiLL58QVAi38yecV7XJCiPdaJRQf2CkTk",
    "Bt6Nxynrmfr5KdAvfrCBNRAYpvpDZzZZaD8p47DCBpSJ",
    "Bt8GnTSioPvSrJ3Tcjc297ZDmuQpxWTzc4LdHr26EBsc",
    "BtCMxwmXBzfuwmVc7WXJ6urZWWoj2RV8LdPXh57VoK8c",
    "BtFA6GRZHwUo8Q8xUeLzgvGHsRV5BT3x82C5T4Amxbdh",
    "BtFVZDuuMHGc7p5oGC78ZZr3LZoUtQY1GQVfewVqWi5q",
    "BtfutNc8SjwSPfSgCbKs96bE7VooDo8Erb9ZzybXxZ2D",
    "BtnFZFUQPXq3g4Lihbbj1J7iQaZLQBHQdjtYtGhMdmAn",
    "BtsHSFvNVZnRUHYjSfcmT6KoGwdU6Wdoxi4cnKpVrery",
    "Bu4wo5wDEYPGkhcEdcxzEnqiSUzECkkdZbRiebr2amgX",
    "BuCjacuX1rGd9z17kusy4Dx33Fq4r2ccU2sryynqVjz",
    "BuQzK4qBnEQrfMDkyNbynctndUTPfoLDXxLdBz4rfgBk",
    "BuWEvpTC5GnZrJZ321hVYukxNsc61FnoY99qthhTKzw5",
    "BuYL7EyiwywzkudMym3VvAPhPPFT77aTFwAXg1BcKmko",
    "BuvUtViHNBTmaJ5AMrgwi3DNYgXZQsHqUdgUeJKJm7mE",
    "Bv1gVQsBf3yugD58qqWSQD5BUTgwgYECEimCDXiDuA79",
    "Bv72eQHVX9PTkMPxJyPDa4XdV4c4XSyK7Zg5mui7opLE",
    "BvPKzLoQprhxe3iAEMXyK8gPMvBmykKB9ojKfXofTsH2",
    "BvPuFh9usvV8eCZWfDw7ofj6vRmQ5AbzzN9TAxzYmgXD",
    "BvkkrwFzq8Z6ih9nSkn36x6rHQSJ7sfV2YYwo1Q2HQKj",
    "Bvy94cVZXWffrDwt8MxBXKv8yqEzoHMwK3ZHXgH2rWQx",
    "Bw6Q8ATLWAJZXrY9vVW4DSpGMZ2ayUbThyoAd7VDsjg6",
    "BwmQGNmiWnD5qeDqXgtZKXH9istxSKWAkGoWz9Vd7xX7",
    "BwpZd2MdJ8t2jJfUoeBHoa9fN32AT9kwYiRXkFTcFXFk",
    "BwwtJ2ADrkC18ZXgNB8knk7bXhDYFRRASZqvNX4La5Jq",
    "BwyH9hFSigbSAbp8f55TREYLxg6wGU3EQ3R7Cfxkc1WB",
    "BwzojEs37BNBbioUDXSMhR3gb1d4ziKe674WrAw38Yhv",
    "BxCJLK5GeNQmdtZiHwQZrYAFmbE2BSCSzC4WrQ6xqhHe",
    "BxEheCwGj8TPAtNKv8iwuaaXL5dUyL5EJzFDE6Kfw6HW",
    "BxTBein1fqbHapnLidiMrN2ovCSWcyMNikpgY1y2vmv1",
    "BxTkUBwTjCacNeZsK3Z5mrFB4XpoVpN34RodwT4ENVVx",
    "Bz722YRLyx92b3iztheNfS17oneKaV2hL3qU4uvMLuLJ",
    "Bz8RToyKYnrMcDLFz2HhBK1nRJPDkrmqBBewXpNs3oTz",
    "Bz9WigaTSHUQojCJhpFVwjKm33nX4wL67hYPLSqYVguQ",
    "BzG35BjHqzTKBUBg7iqWoMWzUaGhH4Nc7nyHcoa4LpEx",
    "BzHjNJTMDsn8jLBgZw8EaQ8FC264HvRPb2ve3XdgFGzn",
    "BzLDazjmu7geRNuhHViaBTKKTr1S2Sn9M2zFViovkb47",
    "BzVWHG3WLthddbhbXiTdvjf1pSJisPwsh6k3Jvbb7TZa",
    "BzihXBzu9b6kMTYwQriyFpURNgswgbaDU2UyxXnE93VX",
    "BzoQr9ZxEbxdfcaLdiBSCvBNDSjApTWmJt4cT7F8vDmv",
    "C11Yd656fCrxu4XaAyDzKeKWBua2x7XyHyD936hcLBqc",
    "C17LyX8UnGybFwmkUfJCjdphaU9ayWsMhkbod3K3AgCv",
    "C185L5eZQGoAWFuACfSbbgFD7BZrqiWsaeoXJxZDkGeg",
    "C1DHsqckLekuAgEeiWaucA1M8Syagbtgiskq6SAFqa3w",
    "C1DQMe5g5BBXQaedy66P9bLJZkSD9KM1zETLbidWvtNU",
    "C1SpjwckbAczHiJkkXh93cHpJz77qbkzU8oVRYBaSDv3",
    "C1aFH3heeU6tZAE2ihggqchMWhg1TAJYoT5XCaKzwQye",
    "C1kvWqzGMdT7ci9TiS6oNCdX7giGFwQg89EDriuKoSMR",
    "C1x1whW8Qct61f7rJ592sngs8s251PVp4Loj6AXqvcTs",
    "C23qSBE7qNatK3wrNf2K4kMq868NLpwUe7zEcxBuDxG6",
    "C2CnUxSo5TsUp6tWTz6TUH5S57eciW18Emniq5xqHc5V",
    "C2GhKNAgMkdyaVXJa1KKcqTHX7kChcwkqrZfJPFijNjn",
    "C2JXGHGqt7utHNog3GCEXknC478f3U13zK6NXDKAFyNo",
    "C2LQVzLWJKrMvhMzxNkHyX9eJbjmiphEiAQTTnhVCHcJ",
    "C2QMNE49mAaQguRigaSkvYxhHT5xi37YjTrF93Qy1BdM",
    "C2XRT23XtBuqpZUCxMvwm6w7EaSKCuN5QeJLxYXw2dn3",
    "C2Zni7HgbnkdRkV3ipUviPC39uVnzLyaEfG7biNzWSvW",
    "C2br7hHiQENyrbpR7SEqSF8ccKzaNsptyHuBTnnXwNHz",
    "C2hLCSZ8YcKjHxkCZM8vqc6a1PqCV1kgtUqHwjaifVH1",
    "C2iQbjps5gEPRNYwpm3X6LwTF9JPqaYGMbTw1v2dKQte",
    "C2kS5eRU1uNBbSZrK9j7XnNx7fQqU4mQXqpjLP67MeG9",
    "C2rigd6sjxnNAnocyBQiRApcuToceVqTD96J5phqEB1i",
    "C36oXMJVGdJSx4S3ojedkgw1WnAk1DLWKGxQzkRWFb9L",
    "C3UdmJsEidz8UFEeeBWeAzPZc9NW2CwFSZj8ZoZzUeS4",
    "C3XR5MC8itHkCad4eaarVR1h9h2uw8ZSpGSFaaLMeWWy",
    "C3Z9kk1xqngUd8hDeBANdysniUAGo6KEogkpcBnJWosr",
    "C3mN2w42Q2WYyVfJCQEYs1fCFmxeJB4HhPYqE8evegnD",
    "C3qsXETeQGfvPvSX3c4vZo1pzCrx8vyMAfAJ9htK7Rzf",
    "C3rVMqaDgv64uM1aiJiMapprfnP8sFNAhYwUCkYfUkBB",
    "C3ympfbNGtosqwT13N1x6wh8cGMyP2FTvNTV9iiLsHSb",
    "C44GRVvNzzksGFGbkrhbKwemGut7fji4pc1SDssCJiMU",
    "C4DF62boKBpMToiuPJK6xGqTva1Yy6wTVQ16HqERoHQQ",
    "C4XpFxmG6L26c9NiTk5ZhSFGX9VH2VKLPXUbPTPRyeRQ",
    "C4ndKU8JZ28ZUCsvucV78NpWN9DPKByjfT3smT87eCSS",
    "C4qZuLEXZv72JjQmmVF18zCkWF9mivpd7v8rbZaXLDx",
    "C5P78gZDsmFgbRWpXVmAs8YPpDPWZMDdBG1qZj1gkU5j",
    "C5S4ACZ7NjGLLr64z1ShY4X4GufoU33Y3dZFbXEY1ycG",
    "C5jA9oa6h6a6bchbzRpEJVvRmdUBBap4Z9mm8wwqQxir",
    "C5p9WsC9YieNWpAUoapip1BuiCMpggmVoGp7GkEkW7Xd",
    "C5ryPaSupHnykZWjBQqijnHSeNfxY2cr7DHSAyYpuz9G",
    "C6CMEqgBnBoQckZRj1h1UottHNRCV4Gvdx3bkSwDLHSK",
    "C6DGEZV2rZkD34fUeNj2bHCNLraAuJthfyftVZsn4UJB",
    "C6M4wEwyMqocoFRdjGA1Qfz4XaZbu1ZkarXsHebVdRQh",
    "C6P1YY62egn2Rg7ZFZQF1fcpucHESYifmQwK5XXa8UaH",
    "C6eHGxDqfqn8jCvLiCa2vQFEk7XdPg4Y1a4mXW1xUqVb",
    "C6qcosaeVrbwW8Dxu7XLo3ra5Ldv7kRKHrrrrxh9vXjg",
    "C6v7FxuUTdY66dELJkqevCrBRW44hdjQD9Yq37FXwz9a",
    "C79sNdJSbYAewdjocxJL1ZCFkPqPJauHW8Sxds3PsVTY",
    "C7EqEST6AFA21qzoCP6wPNJt4FC4yrELcfFVK3c1XVvh",
    "C7JdNnzC4mZmkzrxY6DPKQYd9ttYXqLyW2MRgzTUP8Un",
    "C8E4Nbq2EJxBVSfNC1f2vh91dfbX2FzrkkZ87pKUqFB7",
    "C8FETj5pxeR3ue877KSUEaGHH38gu1bgPV898Kmu3RYD",
    "C8SPwdLpyDnssJbicC2VB8YByPho6n3HH5qJs7HiZgVc",
    "C8g6DQpjK6oCLnct6oPUAWC8zosiiR4KfhG8H82FoeyZ",
    "C8jC9CK7dwVyGGarvgTjnSqxkhAhQfmWKRZ6PBr33qRG",
    "C9Eu7jcyTjAX58Nn8NHdXx5nptbp1tjmXqBPzkjMtqXC",
    "CAB3bv3TQhqTJ2Ev2w5gAShCdEZ3RTXz5qw8N9VqzF44",
    "CADEvdBG6yBpkgMoqFyuwpf4sgjNv72sBSbz3DW2Ee5E",
    "CAHCjB44go5f6mMXTRpDgoRaftyYMoQw1B2XivaTx7B6",
    "CAUakuCTtA54U9va48MqQGJxhHRkoF1mQRQM41XWenE5",
    "CAW9dRCwNNY4ZSbSpzxgWR1UJ5uux4CCsryRvP9nYGzV",
    "CAuDjZ2smsLb9BrN5LPbHjXMgkNQrkeXutWf8KZwkVh2",
    "CAyq82YBAmQj8YcLVbC1GDUQcf31y3x2tdn1RT4LdnWP",
    "CB4aC8wa8Mqcb4othmTAWeAD8owoUtvGw5TkPUaZpDRY",
    "CBDZkjSgtUdj1vnscLLziAQeociDoNZJN5NjBqF6xRWa",
    "CBJK8t2pZLZ6su1hXd7XUorsDDc5AUjTWd7ze876R3d1",
    "CBLYmhnL7JN9jaqAbxuPquz4hS3THbeYWMpxQRPz6a53",
    "CBU62nSF7kNfw34prBrZvykzr5FMUb8f8TFYTqLrpLiy",
    "CBXJMyJSSV57b6dt3T2jxswb6HuyxyhXYVNPLRKEEVEF",
    "CBZm7BX5A3XwHHm2F3pQ8rzLfck9mjsXuT2enJBQJXJk",
    "CBkrVLgHh7eHoGXRKbmu8buvZ6MfDD6YYuWiyjPFxeWT",
    "CC2sbyYiMgRT1AiTGJF4pyg9GTe2i2vhd7KJ2eaeAdFM",
    "CC9aE1AiJoS39EPrAXWPyynFtwRa5UfJ9XoNDUTECNA8",
    "CCBXuBAySLxF7G3NPB7sHjbLTVFC8vQ3vYzLaFRhw98c",
    "CCCxmZTRs9yyrYgm3cRLrZNhAjaJu26AxWhWPZzxqn6Z",
    "CCGdP8x1jGUQEPXnrzegPa3sPsCSL3GHYk1JKZ56VFMa",
    "CCNah8BFowhe9sJz1G6FGJCXFm7ehXRbKC45mrLmSXDf",
    "CCPq9qjAuzAgt9nx8XjhiBGHoEuDAQVyALRvzpq3UoHd",
    "CCjREb5kFpywSqMmT1wnPgQrtxmD46uSejTy5mMxFsaw",
    "CCv4yzCMDNugA475paiE4kgofHmCat3JYy7nHGVTAnoL",
    "CCwNFWgVjnnp1j5DLsirH9DQBdQ5Hh8NGnFG1QuYyuQ4",
    "CCwTs3HyUWR6oTqcTAKBH9ABiUgc4FUW8Dcg2gAAG9pV",
    "CD8wACLTnmV4mvFHCx7HwLsxVN9mpMuH6yDoCLmyG7Mf",
    "CDGNxik4TvH55cK7VvaDMaFXuMyt3BWQmJ5Xwa6UZ9Z",
    "CDNRHHR6rYiQpPUKrD1SxsKvg7Rke63F1Zuhw6Epk62u",
    "CDYmdoyiMYBNk5WzUR4yrfR3XWJRD3pyBDMEQwcFAzSH",
    "CDcMuDzCKSwQgyZs5sM14CyUgnBR7kZb6nX1AxK3uFtg",
    "CDdAc6UwiMhdwPVRZBNsozYNjmaFgQMPZ2kKb1jV6PJq",
    "CDePB67ashLoKvuQx5jEguuaeThFqxrGkLvymZdKcD3M",
    "CDoHUbGAEaycD2fJFxt4QU2Ebk7RnbEYyZkYc3pheSiK",
    "CDwewqFmn4hYtDeUoKa2yKDKU6C9bLHeavw3owSZDkUZ",
    "CDyjjQEhTk55q1kEnMEnNuDzAwvVqwJncd8s8XLRPdpp",
    "CE1pSFewLUy3UhAgJAVdRiDN7dsA2593rkt9aNqzP3sY",
    "CE6MGEqstNRew5oJ3kQkHBnPRTZfbsAgm2eGuK6QfGLe",
    "CEU2zro99rTYF5xw9P5N43a1qG3DsRnz2Hpmrwm4Zr7x",
    "CEde4gMKMzzwWL9ojJ6PzXjQLM2JGgwPX5mBrVopzqcJ",
    "CFGdRbvtUqFMgr6WVh9sQn8xgRXyuwH5H1AS9w8NqBGz",
    "CFWFPrrYE7ektHP5jH1vGKf9J9ud71p8wHbkkDCp1gtZ",
    "CG776vXjXaKopJ9nDUQgr6HVUqbkAYaX8iPfc9g1sGNg",
    "CG7WoTYL583qqLx8xLG5jRcXAWc2cXH1cc7MWHzyyRsx",
    "CGLW8WRjigMbZ96AhkmBqfkpJn12ba81QBRNG2vSbvty",
    "CGdPz3k6fXRZ6xrKXX47BQbqRNMwRzgneqsJibeeez66",
    "CGf1qfJYdTo7aE98kqYZAf3Mzh563CpfJDPm4njoyPwV",
    "CGiPj4wtnnk19CuyHZxiB6ctoJGUbsQG2SAPXgcHnGoy",
    "CGuReRNhYENSmbGr5N2n2V1AbQHVgAiKvDxnnYRiUCwS",
    "CHEDFmB63aAPToH885zDg5rYyXbTQrPry7UBdLZ4L6MM",
    "CHZeRiVJu2GCSySxDji7W4Hbry94cU48vTgkGJgZKo3A",
    "CHdMhb2wr7YaHmkEi3RKkfaUYmJ1eavt5ZzLeWxFKS5J",
    "CHfYTX4SACua7MrJnuz8DYACGnLJcVWUTbsMZVx2QY4s",
    "CHkhQf3S5fHD6THq7oeyQXb3Q4Rm3eFto9XZffWZfTZa",
    "CHqC7MjPWb29au1g9Hnh4wthqHrvcpwBg12q2r2pHt1J",
    "CHtwtQYTTw91839QTfDEKiQnxwyuLuwYohtikGdsyvBA",
    "CJ3oxJpAnBYTvZoaVGY826P2q3PhsF6wqC3MWmgggZRk",
    "CJ5srUzVrnLDY4rdof61NrDAfNSGdCo2bnj1GZDj131L",
    "CJBeB2sXphJDBJxyPjLsJbqFxMMbATiTCdUg1DoJvMzP",
    "CJErYy31dUKFgkVxStVdrwKK4JLEu5DoN86gqQTafoxh",
    "CJU3sEuPckBeXashMnVk19gffjpTVv1vZcjNyDKazqVM",
    "CJkkvJWMsj8NojtP9Lc6zu94fB4fkjf5ZZa7Wq2oQ9Ro",
    "CJm3ZPttfQ1rVw3quGVjXxKAdjCZH26fhH8FauqikT5D",
    "CJuuDjRkwVpJJpe9mfwrC1xw5jrCPSSq2JzixvTukQi3",
    "CJxAX7xPSzxgUD9sLbp61NtKJVHUELLUSPqsU4coAUAG",
    "CJxgLsGHvzayz2zQTMtDbHd67NMxWX9Gy6t5jUiRV6YD",
    "CK1tFZdxznXbNv3C7F9K6eL5rFsjJdYoDT9J1yxzDRvn",
    "CK2UhqbCV696N7ADCTVUTj3XrQQ5Qrma5A2gCExkmHWh",
    "CKEXckNm2zZqGQt8rGcFaGbKqCwWC5zgqpofKEE3p5hS",
    "CKUGwsjN664iwSHMYD6i384TUWrokod89npgvnCc4Ybs",
    "CKUxiP7Cs6CP1MvrSyvDEAu2nAxddrXutCH1P6cRFbu9",
    "CKfnu3cCQdjnas8Zu2Kxrwa1Y9p6nEgcYcgFYJMbhrP5",
    "CKnpjpbF6escZjvtjHrcKHxQbzXqhKLURQtvBtYLoj2u",
    "CKzH65BLftvcnYdQj8JhBJvUcT8aiHzja8dShrLRcbqy",
    "CKzksVCFYRvjTMLk19ZXXKsqHQ2smEHSr3cGw8Kde8tm",
    "CL4LBErB5s46nLuH4wEQyanAMaJegqKBmJDuomEvtpiQ",
    "CLAR8P6dcBX2ieEVHz7XyHee2hNvDbkDXF77WeNep8Kx",
    "CLAVjfriBYBjzaDSMnbXf8C1hka6tvDvbiUTu1vkZDMc",
    "CLAaLnUaQXzxSsAnXCKFp8KVMB2pB7iD1NyaETKP81g2",
    "CLFDWUx1eYkYYT35pSXP84nmDeUBsmg4E4xNUWkLy8nq",
    "CLJ7g9cgqxCYExVXNHJwxGMHppVDjqKjxR7fR4NBPiT9",
    "CLLveReg494jRZVLE8H31pugYgYh9k1HmM17p3ArMmT5",
    "CLdEZCHriNhbUL7khePmRsdZA4v88e8EgFbUgUHhm9h1",
    "CMAkPszuqBv3K9tVDbc78RSH25UhTBSexa48fanrC7uP",
    "CMcaCvMsE5Vp5viYoiGskNJQiLm9GwvQX76oo4wEhpSA",
    "CMhe4Xod6SjZP8BP5w5CkDi7FgWFyC6yHbR4RzDwWk6n",
    "CMmkkJqNRKdBuq9RNoa66aw6HadcAEfqDvWQMwWwutzY",
    "CMnDoisrU5HRwL29bm2KBdDYZdNnAk6PEaJg2ihZvL2U",
    "CMpLZZJTgEUiZ6i189QMAkRB3kaZyzZU3y2D1eKxzSTL",
    "CMvyMXfNzMDHPyGhwZkCXL44y8JGQ2rJqQmqFdVYsGC9",
    "CNUEZXEm4seAGzRTua2EXkVa48nP5uAZmmugJ5HjRxt7",
    "CNbFc8WXDrogPcVU6aCWbakt4wi9BuUj635DYueWbLTi",
    "CP8ybXAzEpvfJgrpc1NKpt4xpgg8vda34MozyGokLqMh",
    "CPU8zS19j7tBKGEs5YpT1akGB66mwTe6CwqCN6KGTBXA",
    "CPbYfJDCPM2JBaf7Af3WnmKcFc3iNcnJwWUVixixCRDa",
    "CPcZiexRVSw4xe8DFCMXWxncwYdNzCZ84NJDsfyfkwTd",
    "CPdWY5f8qKrRTrLjcf43LZzAzoX5w251DHUwRBfA7Y8p",
    "CPvYcLG7L9dH5hST5UyoikHb6t42qj3MwNRm5uC9gdkD",
    "CPzBjQ2egjDiWBuaSuGUokFpPeqXAtP6EeFcpQX9XnR",
    "CQ4qwbgdad6yjfRP5amfCiSSUTGgHaJWRaQbcnTRMUQn",
    "CQBf87KPSZ3PjgWeBX37rBTL2whxkyReQdkBxLu7UPnd",
    "CQLAbhSSXy81TBKyNRBDUr44WcHbKusX8i3RJBFcoopH",
    "CQLsnxX6mF8XXGo3xsy3kxwRJrYhaA3J5f3xTq4Xo8Ld",
    "CQSuRHfhgHk4v2v9EZ7nRpDdYay9JVnhCxBEpqeySLNq",
    "CQVUjHzBsPuHvMH2dTPWJ8VBr3Gfe2Ae29jD1wn59Hu2",
    "CQcGQ7uU4cEEztDrjgdybAejkpjhMmqncco9DMsVTC3y",
    "CQfkVDxwPNhZqqu1Gxnd93EPYeqcj1vvg88AJw3HYrMH",
    "CQkS1d4PFaQWZmViRBSMxQa5BVKBJGgEbZThvVmdxEsV",
    "CQstZq2J2P6zoyxnbpJJP3MU5LsRpqsXQPvSr8CrRgvN",
    "CQwfKH8rCY8vvcUhcw61zD7yjGaeNY3XB1J1h2mBLSk",
    "CR8gNVWJBRBZVc9DKfSyrSCzkgY3TwoMeqYss9JzhiNV",
    "CRDb9NFYzEs7X8z6ygHDDPdkyWzWc1Sg9h4D9pphTFRR",
    "CREokoUDa9vkFGeUVUR7GEyCyapaz6tkDkAGVsmR6P4F",
    "CRGdm2pkEy2SHpCdWNyMJsdwmYajHZpLf9o3ZT9NTDWT",
    "CRKufLJZpbuPosQKGHWULhX6hPf2doaENqvVFHsAaqDR",
    "CRbS1o3rtesKN2JTnqHC3HoDMJBaHqoxTRx8TmReFUNW",
    "CRgY3dELCXapeJom55fGxXxvWquWSYZv8JNZCkDyvde3",
    "CRsoh81PzYCvW15ENDpvmXB4MbmVMj7RMUH7nHcMDVGC",
    "CRwj8aRXXCDLJKErswvz2suxf4c4wBYZbFCMssr2xmTy",
    "CS1Lg3BQRJu71iynHX2KJYnfQWcay1Mscy5SwdxS9gZG",
    "CS2QueGwcnaLFsJ586mA5JUwqynfYHcYXf1maWZ3nyGe",
    "CSVCq2zWaYy2d13nSw2nXVqewSpfAaSdKScW2hTxisc4",
    "CSXk7rhyidJwug6ogYdrKL4gG2AmBLn9Qk5fhGTt8JBe",
    "CSaz6ANy59pTNjRVMBscJq1gevJRVhL5KRL31m3TbjuK",
    "CTTuo42LZ6tGHhsA39Tnp9WnhSLuRdSjfusF5ZLcSfNB",
    "CTb8pkjzhhMAtXiSvzPLaQw9gBBer1zUKSTreEYmPhX6",
    "CTd2ssf9U953zZvy9oUM5buiNynyjHu8ytzmf5PDBzgt",
    "CThy5Ds9DgG9eMenGYdFzj63XcQFCq6mC9Z37M395cEL",
    "CTnMhWJqY714yEiVvoVXWmyZ3wESERzU7RppEHKWVbBS",
    "CU3mYzJYnoYFU3tMc7Nx6CpBZ2mBhJhQi4vLfg6Xj485",
    "CUGwMJszXcMzu9Yz57Poo4Mz4oEb7iRhVLw6gdUhyGj8",
    "CUNPhGJJR9Cv1kKr7AdiTuPDEp23xmvj3cFhUv6eEbKN",
    "CUTdVQq9mKM6CMC8rTxmHdjV9dXJH7KFpDFT3hdxs7JP",
    "CUbrcgzW7QPbPzJZvPfN4oQeW1pPjvofsppbqkArPYYQ",
    "CUnHiTFxpYpsiGLazFhKZ7gvU9E4CvSMTjki7EtohUe1",
    "CUoijYD3VWSYfWHgob3LTDGVCUGjiGwYVP8ixyM3ox8U",
    "CUpy82ATrXaQ74MisLu9XJcWqGVQmEYCyvFJzF5A1hMJ",
    "CUtwbB1dGDJA7ZYLfYojz7exsGKWYSy2peCPCVAGtbdw",
    "CUxJLSvYmJy96Qxf8Rp6xii9tfWZmUCS2z2A21jc66i6",
    "CV95oZF5Jd2jA3VV7EtFAkLrBsfAgvJoRHjoeWJbFUA4",
    "CVbL8jrK9TYjdtj3rUpb4bFWP8ascyNq8R9sLttwyYxE",
    "CWD3AYf1uE2L1qSnPvGdkxNrenSkYuFvFXp4HoCZLrDU",
    "CWF47TLErUmdLXCJkYJrsvBnu1UsAjiiFhFP8khfa9dB",
    "CWRBovpWTgzJHH4qLXdszcDyviKHhFNt6H1Z39ioTwD1",
    "CWi9TrCQmj3iD1cN11ZjZJU7MJB5QoqFrxc2w57A9GBh",
    "CWpbZb5MjcWnrBCRLPbs113tGn5JTp2xA5UmKauywmuj",
    "CWs4uzwoLfP1yXV4NqJEaV3kLT1XsLTwcZsuDTm39Yig",
    "CWxdHvgzqtL9k5GgXq8WKrVf4kUzJK66bNxMEeQ7QKZn",
    "CXLfqAUBYS22Kvb3y2fBkwPyKt7tzYkXtEVrY1PWiWxM",
    "CXWjs4eJ5NqaZ6F38F4HQBd8L9e198dWSSWqfbyGbwwM",
    "CXaHDZ1Hdh2wFWqGhqEBWEPLr3JbGVZVTkR5fHDs47UF",
    "CXbkbj2qSj66gVK9ALWX9LmByumuCtouTybcHYCSLpzF",
    "CXfmA4WFWb4FA7BonccWEtyEa9GjGbLibwXvD25mV9Vt",
    "CXtKdkeU6ZiFvK9rCsL5TQUT8Vh7i67SyPj5sQLMLMj8",
    "CXuDajSdv7cL7HJvtXFNvjtCwrgE7yBTjUpPSy2ppdQT",
    "CXwVnziEKuPBkRJ5j63dR5X4KBUewKebdLYxC3vNHXPh",
    "CXz1pCo4rT9cCL1ZKDgNhW3qc4TbhpNyWonMf7Cw6Fx6",
    "CXzJu14MgAi48hvMy8yKd7ss51uEMuteNfN9Z6hsCuZY",
    "CY1rDsg8j92ANoUngfQBV7YhfcA8wTsQHWxNAmrxrcqH",
    "CY6sr64LRTDPakeXdsivyLZ11tq3SmyqHsWXBxAdoGMD",
    "CYQoZYC56X99P9qitEMTbpvGR3mpAZDzn5G94E82b5AT",
    "CYT2BkZKNr3c5FwTb7XrmksCrH3Wf7WDWbZ3KEK3oj59",
    "CYV9rjn9ohKjGz4W2ZeEEwfc6Qkgj7y7kqDhiJzbxCP5",
    "CYgP1vGtfSut923mdqToN5KLGLetVWaDvcKL5y9bqZaB",
    "CYvUMthjVKLHBHcLNfRiG1Cg2kK2s1S5sZ49DPSdYA3n",
    "CYyHtdZbefHyJk2kBcTGsPjYdnTD5QwBqL63uAeuusgH",
    "CZ49b4KfqCSdjcNmhrpfktmLPHKzHrg5Zp8qXjkzfVGP",
    "CZ4qCYBXYsQDsJW74SUUR5yFFDHkQvcT62LMDt58uLkB",
    "CZAWajjxPHp14ef6GmyHopoAwTmMmddUedHhrwdHW5Cw",
    "CZEcaz9wj9Jy4H4kTKhnK1Vup92Sieqp3fpRXucrpsdj",
    "CZLcnooWrbJPdZatd4q1ZgXrBNoyJkS2cTzoQzKXwbod",
    "CZWeGKitWW7BDpTtPJhvpVz1hz19eqniurLMFVMxuCFf",
    "CZdqYRVC7VTrdV3AvYtNq2jfe35GBa68CdxcExhHxvTh",
    "CZjaVsCeY5WYRbkAMgkSjfEcsQZA2GQnfh2WRUNJMyJN",
    "CZs8VUhXJLuM2FcWu6cFmPXrfv9g3MyLTEPjqtBZJpza",
    "CaBhSCbmGj1F6cSSbgCUtrNQEu1Nj8AffQ99LBEjN2SY",
    "CaRgeFDrfU1fwdpdjHtcENZsncu8DEGHmC3X7ThfhgsL",
    "CaXpe454FbsZXWF1XgEqqeGwAiAY1XrZeFyebBEBSpnr",
    "CaeMq4WTLUDKVgpE5GYzaVcgZfL1BpN7oYqChqe8WnES",
    "Caem6pxJy9gFq5RqViam8iVcNP7wvp9Nnoo4JzXaApFh",
    "Cagrr2zZoi2rMTFF5NJsMLV95mu9hkg4cbeKiXccwrHr",
    "CamMJxryexo1E4Dm4n3TVDczbAaJfdPL8XgEEC8vHbAD",
    "Cb2fmQ32FfThh856FS6Kmb6ybo5Dct42VdTfkEpD3x3g",
    "CbbLNczmwz7mu4eVzCatccfuJRY7eUozLT1YmtdymqRG",
    "Cbes2NY17FgUMbiaFPeye2KyBGVkstDxUEhfe9h83qJv",
    "CbiDiCEEY9drvEavHDKoSY4WAg8Z5PjGdDy4c7CRwtAi",
    "CcHMomgSbK87Kb7C6GSHRkkbUJFhDaxhzHPd3bPN96py",
    "CcZ351X1E6LC27LDgtbMUELGka3SVu1xC6pcYt6SACgk",
    "CcZ5hGzvrEtHerXwEE8gQgb6akATyUeezrMW12MBtLb7",
    "CcdDcFxT7WVvfaFN5eavRSCxgNrdUF364ui9iBNGcLX1",
    "CcrJuq4eCu9haZjSSYB9ATxaveEvVey7ZqtwS7Ecdac4",
    "CdC1SBPPgtW1frQbVwPc5xJC7eCza1jfsxt33Vad3AYg",
    "CdLdhFJpcQbQBRFvzZQYfxXhHnrkav98gqKxy1tbziQ8",
    "CdPeWBEHuFVQvcoAzC8yQCECv3PwKzqH36nBExk9mVVs",
    "CdZhcZxddRE159pvKKNyyvboFswk9FKV1FbJjm5BC7ao",
    "Cdm3kcWyuWRDdV6wWuyKy6GS4NobCzRXaNCKyhNV9BeT",
    "CdnUNS3nbrJ7ZoSqA5VhqDF445aG4gTbTV221ggg6DHw",
    "Cdqp8m1Eh2GzRtQHyqUNLb5GAUGjz4SZUnhgYYTHpiGZ",
    "Cdzu5TPsAqwe8dxy9h6hq3ndVn6ETZwHKvzpULqQcCPt",
    "Ce5A3qmE9fUnHEe3HdoC71phn3bW6pt5UFg4komRbJYY",
    "CebS7hR6VX9J82fTCbs83Y7s2hXhsABUM4zbUfFeevrW",
    "CeiETJtpQdEgZBMgHC9XHukoTrx7cokkjNvouk9fM3qG",
    "CejeKnKe9iufNA6ZM35RCL2iAuy9uKirnXiJiS3dK17r",
    "CerPTyYDvRAYPyg78NuUua4ELk9mgUNr815AiAsX3QFM",
    "CewdV6Gue9oPL2zoUaWnQXaLmYB1mKCWG1rLDFLnkVLz",
    "Cf5wobp6Qz2G3M8kNomavS6B1VHV2MAmRLjhN8TLCruJ",
    "Cf62dritYj84mJJwwoz8LZy4HqmmYRXFduJYhqrBVt3T",
    "CfFy1rghpbBxj9i2n4FLJQM6RUA4jYdNmbYmRUPX9BgJ",
    "CfKvHNSdB1sJeMwjw3aVeQbHpm6zJKwoJgjPRisfbazH",
    "CfQuFspmiZEyMYLYruYM7Hp7j3rQq5g17EYCNjjRbrne",
    "CfXKpkS7bTMeZZu5WLHGyyXbPR6vsopp1FNk5KeHAfQN",
    "CfYKBSaMqT3NDidFtNJ1cw2bddsozTYLGfjF1eJLw822",
    "Cfa6w2EFdEtH18CoL6G7q3HbrjLdPwgZNfSPtbzLeXtD",
    "Cfm36tu794wxTifWihet1jLJvmyUwrrzv8TUzqcYyciQ",
    "Cfs8eR8jBWRZtWLJU3Q6N9BzQz8QkWvvK7AxgZAm7NHp",
    "CfvcUS5838NNvfSJLPLcFwDoLDzf36fwn97DmHCTEoXW",
    "Cg19q9KZJZpNSWRmWh3UJavorR1We1LiCPRC7XASLJnm",
    "CgECBNQeJyP6yk1Qe7mPFRqE245TYpQkov1vZcjLzj7E",
    "CgGJBXrkXQUirDR85SEQWockhV6a4TsY6TXArLQdKrmt",
    "CgGZf9sMPmgpgQRuN6gRx6f5RrQJLtggVUgHgJwd1PdQ",
    "CgTTPRHpt4wEr3XhNttcwQ2MkSYarUpbsq7gEFzdfUnk",
    "CgUgU3KZRPhmZzd5FFWgX5PwMgN1sn7YR5n9RJQ4jvVe",
    "CgUqnqhQjVnnLRpzdGC8r3CiVMDoDJXZzeRBy1NcfPpp",
    "CgY3ZPNNG1ZpG4KuBJviHgWww32Bj8FencwFnpGELkrn",
    "CggGBkx1PtLCxBQcse7ECvz77NEGWQeSJHLu7EpLLvqG",
    "CghUQst8TT1i1FbBDUMFAiHd4cuF79qjRJbWkc5Ez5fj",
    "CgkeUgyegzBwNMb49CoY1tdVThxsfppCEvfLJVsH7cKk",
    "CgvQPStFKKKJDdBwuzhGWK4QQxRLxu6vJp5FUjNpXdFP",
    "ChVJf4FwGtHtJjbdfF2AepUn7srfgRqsEZicGFWhsH3e",
    "Chm3FLBACBtbTmHMMuWsygtW3dmUcJXTeegDpYaUKNqf",
    "Chv2RkDJZBFgmpkpVAuAZD8NKiHTrLmniD6pQmoDAFtj",
    "Ci1k7M8GoiNXtsf6no2LjEccqjKo63Pnxnk129Qv2FHw",
    "CiLZ5kousyFNqD5s89c7P4668ZHcM5GY69c1jw9RPZc8",
    "CiN7Qnq4Ej5wsAfegEzNY9TyfhMfj7YRrHR39BPWXTqd",
    "CiPmgCztJRNsj8unHgLQAAbrWkLzoeHMptwPVo5o1iik",
    "Cijp5z2jkkoeaSrxAs2nfhbEx1KhqhTAqQE7eJBvzwmN",
    "Ciq3i3dVS7Srp82GnD83rgAboCnyFc5YLfkCG4QJzU8w",
    "CiwWbYy4eGCLzkJrEU4FkhcHHHVyTG9SqyHUgNpJoSFj",
    "CiyQdrKzGaEM5nQBLB5wc6aDqeogJNCJ87PgyiGAuN4k",
    "Cj3T856BN3n6QzwXFAai8oNjPU8SSBjSYYcAe22Wi3NY",
    "CjCC8GMbGq5tmYkMTbRe6dDcVfeypmjq8AGLg4YcVCCF",
    "CjPfMobjqxfyYcjEtr12bVCxqNCKTkXXBwYFiBHu3nN1",
    "CjUXYCgb23aZ7yLahf7QgLBwoneMoeUMGxyWbsMKNANh",
    "CjYK1nLuPhHPV31ocev14WHxaYG5pZrjEx7WPt6Zb28e",
    "Ck75R3mtiizfWtC7jRFrKdznAwNF4KmH6czj3HPVn2zN",
    "Ck8cF6oh4mTqCsa4PJhKfb2u2QkHpBA77Njn7BHBvQN9",
    "CkBQaiXxKyT3RSTGZa271JLNCzKeXQKdvaTDNqskCuCM",
    "CkDFcwGxh2nFfWzwG3Ngh3ehfduG9hY7Mc1sQqLGFtrq",
    "CktWbQ4bjGsvarxqCKAxLmp6Pmr2Cwc7Cg5mtaV7XS3U",
    "CkucWtzSvj9FuQ2tShWJa8Cm8DmJuBXjd8AiBpRZgXLC",
    "Cm7RTBmtz31BjaZQbc4y7pkBuTGUTqPvhFS5Q33Vo2Pv",
    "Cm9MXDZywUf6AfFGpZ2mxpgcf6RyeJRLj3L51GiZkTGL",
    "CmMmjgWzF1AsS48r8dnGGjceGPZeXeU2atyL9dBZjmeF",
    "CmMoUdYa1oVfsrRfijWYj9sk1C6iRJwnARUBqcsb8Me8",
    "Cmgoe6bij3SG6FfZKtbgZ2eib1ii1wjk3z3KUfSRH9Sq",
    "CmmKEptXQ5uHzK4ZoiRarNdpxgYCVy7deUTtkZVWFtqU",
    "Cmq63CwbY6NWcGsxo7pps5NdKKBcMACDdYbT2omFYZwC",
    "Cn2RUnnQBfTUAN5cWmmYoFWnrt155FErR2AjBQSNuNKB",
    "Cn9cAF5u1qLxNyk2j42276DFTBMnwfaJqgMt6B6P2PbS",
    "CnAunhLBBopUZANeoHK128wmkZdCTSnz7w4c4DjNWFWh",
    "CnPUbpfwfzqB5RdVa8jaDyJzm6VuFLnFaSnqXMYhTnLE",
    "CnbEXjXuqpisQY5g9bHhtLE2tnnBiZepK2KdieFf1SPS",
    "Cnc3orgi2r2mKEXAhgBpmYzZwHYxef4kM1xiyFMApUXV",
    "CndAFuiFptp1eq7y7Wo5JQiAVPjmchksiWF5ZEm1bFn6",
    "CnvfTv4cDPaNvf8bZBiLBxg3zBgSf6GWqKnuRnub94Zr",
    "Co4Lb4Hta5k96swuKUp72PoP4vDC7JdiULXByjQ9FhS5",
    "CoW3StWnaMYtdSciv7pYQchmLVgNFBhounWqbciVcr2N",
    "CoancjjDXFUSUru16owVhqUe51fowpXKFeiUPfxPm7gH",
    "CovbQipGt2pUu9d2U5YWV4sY1obN1SiL6L1err7am4dj",
    "CowDGLwpUsuFkdgtNpUTBmPruX9H56dmJycGcPnRmDPt",
    "CpBD9n4eppFwVz6i7ugxMmmTJ7Qbhq2QS1DwGdZuKkth",
    "CpMhGFakbtm5de6An5mXidZ2bm41tuKB24BzzmMAFUet",
    "CpcEcWhP7nfgfnKXE8zxX96VnqAVoEqRPNVGBhi5fXQm",
    "CpfxdDFFFLNWTHRtAsBMbx71o7NBr8YhV4knn3B47hbi",
    "CppaBEPGX6dAviNV8eh28GMTfsYPRLBoJu8ppCYnc5Uk",
    "Cq8JWYPuEBtHy4EUoEU6oyDUeRXE9t8ZdQyLXYmNoMwY",
    "CqbmGQVp52DMM2Vudoh5fE6Q2k5q3MB3KwwLr5cbVEGU",
    "Cqp7RZpQLZP4j9AsFScFQjbp51H4p4zJxG7j7S1c3MLr",
    "CqznzH6d3QgACe8LbSktPHzBCCmVTk9Juxcrqma1MShj",
    "CrHeDs8NCB2ytGdnha32vx7BeGtnGieqJiAkqdCT4TqT",
    "CrZEuh5ngtVfcGoFbrLa1eTiBiY2frkwK37qGfDhPaDz",
    "CrekYb4ua9o6qYwuQwrZLu5zPBFGDoiiFpcUUGEotyt7",
    "Cs47aZHEfTE4njfZXytZipsyApMeCGoKMi6gyAzme2Lx",
    "Cs82tb9Fc7cxbo5bzS1eF8DDAYMy9H9akQ4MDZkfVHBE",
    "CsHvQ8MXnNgsd5BDtTCUhSEsP9t22YQzDjN7zTP9foaa",
    "Csc5UJ3kL1u5PJs4tbwgxGiw2nSrHvK5sDLnitQ8VcRK",
    "Csgc6sY6tJPAJtos4kLx2qSBk6RsRakdanCdW5A7rpBA",
    "Csiqo5YHVsHQDYskNsiVP4zaU2T6tvKxCdaFGQSRiCcN",
    "Css5qAFBV6faEFpBe57rgpER4yWsMXifmwiy4rZ5H68d",
    "CsyAzT68FhD5QLsZm6RUCdGtgxquAJ8mjrvVhBQn8os9",
    "CtHQTssde1pQpPGTm94JtKXDoHatYBTCQNsE3iijJ9BF",
    "CtJuXTJ1SgHo8TU2jhAvS5zLGpQayG3enBkBPisqBE9v",
    "CtKhyjyATKWCcXdUoL8kSDPAF6nmtwi8kATcEWeQ7FjU",
    "CtVvjx3oQAoRVjTBDKUaSaVphCfcfsHeMYXrgzTtE7EM",
    "CtesqPB6aQ9NgUd8VjmRucbwjWaDGidAxhE71nUXY3mC",
    "CtnQxoVGF5DYwiZ9zCjjW4oz7TakxVK8ymCM995JiYcC",
    "CtvLd5U54ABuCjt8e48fYH3zFg4EDJypp9QaCxqqkeF3",
    "CuPGuCoaD5c12WXD1fF82tZFYDYC2z2jeXnhw7FHojux",
    "CuW9jmLhqsK9X1EQ5hBABf6Ghc8cfMNd9FmtMATcfYVg",
    "CukqCyWkC1MhZuhAt38jopThpkeCrkN8cE1xHzKZxJJ8",
    "CuvFYj8BjtVUBxKJqweCPAkzSVjJv22ShKKWYUBWx8gV",
    "Cuwa9Xgxwf6yzXrFDCyjXyaoU6pB2ZdUy75Xuano3bEi",
    "Cv3SA7dWRxDRbAeMkjrNLhHaNUszVjXRWRmrQ796cL12",
    "CvSb1fpjuUnrw4iCKMThaVrXLZczuzrPXj2n3s1NH3XG",
    "CvYvHDGnXbi12QnS1Ecqhgqhjk2csFh2JxEHq82TRaJE",
    "CveKvqjyydeoqa3RLXCPV2sR2hwVrwD76bRhNX9QCN5K",
    "CvpWadYpHpzrD6yV7zYiawwFWKCa3msc6P3MSUtpJw5E",
    "CwA7EvomdgRMvDKSM2EkCAUoF5DZKGm21VaRei3TACM5",
    "CwE6PngvoiEAiNNr2bRmaFqjbga6oBtGB91vGKxaLSkN",
    "CwFwS5mCSGKrWZxfCHE4ta2U5vyJP6po1WNQVodGdsJC",
    "CwKCeZ89dWyMHHvWfKBRuFnE55SfZ3BHEazfDgoituSD",
    "CwPQjESLMhwPak3wHgb3z8PPDBoek6JFG28TBjMWa9Cd",
    "CwPcqpcPWzRfDNXziDZTXzd7g1m6B2bmsa1GGTYPwhGt",
    "CwTkzfjwickyMxC8UgLBCtvTafpzfnVxBLzAWQvXB63P",
    "CwjFn9BezK3joqRDK4GcLjeK3CkuuLMCuhYirySjuoDm",
    "CwrU2QkWcreug7g2gNSjaCnP34NYTmw4FbrwGVxJBkHp",
    "CwwTEquMZsDa9jv8WiG3MG5DBCoaK2N9pSvospGiSisB",
    "Cx5w3Mg8rgz6Pc8kbYMG6ZARnYdi1CKYUfjMu5ESoUeT",
    "CxFivVGvsoH4VfD3LpRRfwzZoWyeNzYs9R7gX2rRDaZN",
    "CxLZxCtzpY34MLMjMDPdMuP1jcFcgBeWbTzFAfEHjvFH",
    "Cxh7xRnCWvHfBKdHTs1AWUiTMpgHjmGB3oJXfXBTPfTh",
    "Cxp8JzvB9qvHAJubZ66MX3pvxYkpEBrQQbdJtnFUod1B",
    "CxrABLAgp48HHsLAnHMyzWCDMUypp6J2jv2538FHawEm",
    "CyM23akyKrRhT9bLXuSjKZFPhxtkJrow9wjoBmkHWGhT",
    "CyMFkg1aseKA7UTWs6g7982mbpqRqXCx8mLFYsYbYq1C",
    "CynFfR2v4ywotCK5u4oKrKMVcnoow1eFJQn8eeKvEnCp",
    "CysZComvuG3MdzmZh6az6dDTqcj7qBDU4RQ99bw5MPhJ",
    "CytFvMHcjoVouCWtNdKg2M9PVXt3LuVoHY2tE1a2CAx",
    "CyuXSiKoVGESyeV71b3qhw2fB1xTi6NSf4cbibUTaS57",
    "CyziT7miXLgpYZBUcdHHSzURP91m2fm4ZjswykNQ3YtK",
    "CzZFfsiraAi2nZwiiJFSW534UwaLzbNvymq1jT33mqNi",
    "CzhftqXMtbdT3BNFUwg1vJGJsKjK7Zgco1uQ4yBqs1UH",
    "Czq325U8npRUj3cYE35AioqK8PfRZBmCe7ETd9s5eLhL",
    "CzreLYZcAhAEDgVCUhbHsPQ9GnF5mU5B71PeHcSAgBkX",
    "D12q3EN2LVdZ2LRG1mwsRMK3bTborfvSoMZ4uytiin2h",
    "D1HRKuRWXeN5M1XjbBvDYqQnqtSPf23Rut2ZZVbrs4KB",
    "D1YBG5KxzTfNmMMhsiuH6voCwc993fvPv9nLC4AuKcNJ",
    "D1gGXrT4DMc7MQir9oao2KJcXksxEvQ7TTYpUJKADMAy",
    "D1rK8keGRBjtiQxdTdGjtKpWZYczUKT9PW3TfD5Vb1me",
    "D1sJGacaWemLZ8ZVwnMFCRPZLyKcHDnJUYFtvkpTmqzJ",
    "D1vWSiSSwBCQRECdQFaH8KU5oSEoaYDbtafATUnA63YG",
    "D2C6FdtAMmdWEHj61hXLoFNwLfR7jb3jAaCNgDRgFRWd",
    "D2CF8k5T61jowUijCHYtSzEVB7KjcvrNcaWvXoiJrwsG",
    "D33nhKES6qSjnBqPwH752q24Ae5gbZciGmU5KtrKQEbz",
    "D34ck4965wbzDKLyKMyxXmjLgMPiAmWGPNATzKB58kWa",
    "D3Q16km29C9Tr1PxvJihStkd5jEM16YurzMFE8obqCRv",
    "D3Rfs59L13MqviPNmoK3R554Ned8Baci46rHoKQCDPCV",
    "D3yYUgKVuGekpMcNjXvNvVy8xZExDc2SBbbDZXqqQB9A",
    "D43RsWVVx4QJCfUaSJ8Lc9x3FC6hffk938HT6BEfB4rA",
    "D4NPV44qvjvgKhyp8EL3EcCT5sd6V1P7mfGSMeYB1wgC",
    "D4YPr41PEJYWBmZtkySJBaKQWCLViyBR8c5qj5agD9PF",
    "D4mQ11NdUDpSjctCp7C17RjGSbZbTBksHSLDZGvz5aXd",
    "D5T3U2chDe3V29B2AdXieCFty4fxGpcNxtYXTvwFjFTC",
    "D5jhZiTxygXhGPMZT8TqFeWjLE3ZxwceEmdFywotiixj",
    "D5oayGX8D6SQy39gpAePNk9gjVHXjtqPmvX9YNKJjThU",
    "D5sCqXAyuhJtKU5ZFbpZSU6g3HiQg8athbasY9yHucJi",
    "D5uW4tW5U6Pu4fvwiUtXqrEoYEWY6EPhHvji3yCTb3s5",
    "D6V5EeJmxQ43Kh8Ai7wQtFdibV4CNcdoY2TEPpGWtBaL",
    "D6g67UGEQtSUELA4VzC9CrxY68QNKngJzkGAukpv5SXk",
    "D6oFPiJtV9kgkuPsi3pfgKNU9WhmBjsZetLutybzjtYC",
    "D77o6krEhZ4TvzbLZMkxyVLpDdMG3z5Q8X6Ea5qqN9Jv",
    "D7CVxHkHThUmsmdaeDDooovZam2qdTkk29edesvbNNqe",
    "D7EBPQ8xcBh21tm82XfpL4WzwEZahh4Vdc1a1trK5Kip",
    "D7P9Efj3BkBro2rpBSxH48PaUmFqja7nSqMosBA5BvB7",
    "D84WneiUa3jir3zAeU8MFyGBsKemLSkRGQJzSp5qfc2L",
    "D8B9yUuTe78mwxFmNsjHuf4EZpeY3g4DJ6Su7pvKbRfi",
    "D8QtZxzqJi7zNnqEVXVqgyoURJyQB7HWPsn1daKyDzmb",
    "D8X5YQ3ydzuVa28exfGVmoZfynARd77hNjtUSU23ULdF",
    "D8v8FUQPfgxyGu63onbNm3rQsBn5mwBCV7CyHasFw8eC",
    "D99YrSwkiHzXGLSb4mtsYsQP15ex1JS5oKXEQ9FyHhij",
    "D9BcqorBuYWyUkzn4mHrM4NCLBGUQaxnXohprxtffqZX",
    "D9KR4jYQfHZahe2f2La5PNAFrSQUv43Do3kRaQd31wqy",
    "D9aQZXdxhAfDfBV89rpMFLVHkcGVDJRKzry3HP8SvHFW",
    "D9bu3zqkTmFa5yKhxTZgx24GVApeCDdQMaaamNdEykTe",
    "D9iSeLa5d5wqjrGgZeYV5BHit1kAWhYCutLab7e1gr3t",
    "D9p8qsxyzb8GHrjjEqGYqLpmB7ZZSHfaqosgCvG4kfsc",
    "D9uGhfeZ3yz2e5yUpo8fQ7ehJzDtdaKaduKjXqFAmU5t",
    "DA4CtDuLdMJb3LKVmnN1nSevuse5XwZZqU1Ysqwf2yUG",
    "DA7WctWtMBEXrCLJrRH9ESaFfnLEnvJrFEWCxUvkDk2d",
    "DAE8W6vi7EPVyvv7QYgPTeRtZa5vhK67EW73qqrMUX9d",
    "DAxHTMLyXgpNFd14BEEQmdvP4k91eFaKTp8HRixkwM9e",
    "DBPax2u4yXwwLZHypG87nSVApnXoPJRKch9EdRfjn2V3",
    "DBS2aQwhPBpzDZLvF9jdgcTePma5VphemNPk8FgE6QEk",
    "DBjgTHujUpMd7DGB7wL32if8F4VoGEnNoyLYWYUgYCp6",
    "DBkJpTWFdqfQDgA1NEvX1ZkeHJkd2A9cjiWanuqECYWo",
    "DBrDcPp4qVdcfCW3HCVhmS74T3NY4cHWaDwkdmotTeCa",
    "DBrWgydHPXanLf1WZJpowkLoXVYpBujV7EjLjNYMNtZs",
    "DBvNoj7KwSAhJT4BPic35nfkDqse21nNwXaahor6tz1L",
    "DBwzMC7AC1LrhkKu99ohrHFSz5SCdionNTtBDwJj4gvB",
    "DC1vFohLd5LYFMALgsHbviU4DFZgDqo5KQnnecAJ2yJt",
    "DC8bDikAXXhiMPuX9C2jtS715rYpGobodmPDBMKscXr8",
    "DCVUQn1cRo6E9vFbg7BhRZRwQPWGWu2fHUKLYpcHCn9B",
    "DCfSw9ks5U7gpwXkzDUgZuawNM6oS2mtxZjaKRj8o75b",
    "DCiN5viLaydunNnevgyshftQUAVigtDHk3WHErrHd7TA",
    "DCiqomCDYq5oNDid68oyL4EHZ8uDjC55qd7pxTqri1Hf",
    "DCkuGPVrCDK31aryG42vWD6XqtFrFDppVrfUrwzPZMDN",
    "DCta9Lcu8aYTMSyu5ZaAHAuGoj7kgSVXBWzJRwsD6tYn",
    "DCw4xJ4ugfqkryDhpdBhfx2mBJB31qf3xELxYk1FuSsN",
    "DD4qSbYATn4GUo7h2fBZg2Q1USfeCb9DvAzynnckaqw8",
    "DDKre2AnS5V3eFmt9qXWjKCDj4Uf9C8CW6qEaLkY8ZfF",
    "DDPwBoSLT1otwWq3JFzq1Be8hfkWiS9ayEnE9cfs8Ai5",
    "DDWUX1yATMt8kQsx6N7y1U727kBd3xH6J8Q4WCbD67i7",
    "DDcyrMGunVtw9b9MUrp1BR6pSQoixj7z1GcJDtYdRd1H",
    "DDdhxNo4kiSpS4MW6i6xdp1mw2RKe156wZu78ZLHrpqE",
    "DDmPnt2g2wSvYBKwE2jcKRbJYcaAYbucY8YMbtjtyf3z",
    "DDrFNkY7PGsCmuGX5HdMRCbdRL8MTPzY6FRt929bHDUh",
    "DDtHPuTk59rd4sQhU3edVtxUWDNSPZLGC1C1pZ6ravTy",
    "DEET9U7T7pLEQC6QULYc9NTxcexgHSoNvHvA8xMJh82R",
    "DEPnpfQsJ5tY8Nc3vNuzaHesnTB2u1PynkNHt5knF5nD",
    "DEd2as1jQYnLFb9tbeVD5ViRgfJio2tgZhMi7UKwppmS",
    "DEgu9c8KxRh4mRofvr9CEkrnEMpMqjXeBmBRqEnz3ynd",
    "DEkEMteJXQehz2dw5EqV78vTnYZrZ539xgtLH52hyb47",
    "DFGUxQYNDqVcMCT7bycBQLAQhjHVazEPnSYrKPXGSJdT",
    "DFUnEMDDVWKXMms283N5QZanJSFPsCX4apZwz75YTH24",
    "DFeGd6oefHykVEAR6wmco9CsuR639gMX2HpjE9y3n1jn",
    "DFqZetsYgBj2jDHDKUk9vD4ZaoV2EKmkZqGurqcZ6Ppz",
    "DFs8cY4aRm65E4BVsaXG3ZJ1kqn2jwEinHNADNHptic3",
    "DFxGkNMFim63VPWJjxy8WFW8Jt2JT1fAqyMSYqvYPZDT",
    "DFzep8LLyJvsjZxrKyEDUdQc8g5QvtdAxja7bHSm398j",
    "DG4cj6Q11chPkttGyYQJ8UgeFtEMPensbWDWsWuXTbJx",
    "DG57WbjCdJJULUgHTWVGu9KjWVyFHPeWxUBreyaQjePf",
    "DGFn3DvZcR7NMj9ZtJLrJHw91f2EmxQvmo2wb4Pw2fsH",
    "DGTKj8ski4W7xFaC57bjsr1NQKRpYFtC3K1ZNa5cSQpQ",
    "DGWcwPAbsksaPVEWLQLXL2yCDJsdPbDmQTHuQAt3JXoY",
    "DGX23rChHsXYEZ7caXvsW4AMQkZnd1iYjAaLnimmaQbY",
    "DGbTU14TR6FDr1Sd2UFRAhtzUCf38TTe4oQkd9TuKyWK",
    "DGdg3XiJrmo5WHrYtwCPXN9dSQmMRZyudNcFgMCwbP4r",
    "DH5KQ8eTYK3wMXnBh3YLvMF3Bef91py9uuvJbrGKcuz6",
    "DHGnKbDakPeibKCrpPsRuasTKiLNdWSYJrbmC9NrFMjX",
    "DHQizp4MhkBpSPhpzW9fFshSKzpnuHCBKGffxJcDNGqk",
    "DHfo2mhsQFtf54gxuSoFLGysoaQzK1QWjEfhs3xahQeA",
    "DHhTGU3fB2uPLrh4Tjh3MKBepe2fs9jDo8LJyPWvaK7Q",
    "DHnxJpXvFt7P7WonpjwEYMDsATJUnSAAFABLU4peA7dx",
    "DJDGSfR9Rd1hLrVJurqH8PHSkKw47vNeau2fPn7Hhsi3",
    "DJP3tum8mHwdWqffwEDFjvCcKSQW61EdfCKkrgdQsWQk",
    "DJTygvSX9Q5G3nSgXAN6Ze9JrFfF7hDr2b7YVfwii2SS",
    "DJhMmoF2uDKU3ciDUXmLj889TKeg9Asyx5RmFjiALdyt",
    "DK4p3H4kDNpXD5WGo5PKSyJQFENxiFmik7PQ6RjZbTA4",
    "DKFVrUGa8RenGBDTz3UkNvqUZAHnYwB3FbdmXgPLsnAV",
    "DKU4fTbvLeitF63qc8d7FmLdi3g8cEzdrGDcszY52FEA",
    "DKv53Nj6J5yQC48qkgRFz8yT42eWHpp8nXddCnpiDBvq",
    "DKwF6mqA74jkZkve9HqQLJEsUy2SjKwEksc8yhnv7RjV",
    "DKxmBT1tuQwEL4jAdf52a64YZLVNvH7aWX7M9wLZwtZN",
    "DKzU9NUbqGRjGFCNnjSUvasntoyHeA4cu3ocqhDRtfTp",
    "DLcnTXhkBkLJEPaVNwbyMQifkazLiHLMyEpCJxNdzSsr",
    "DLnQyvFSdkfToxy5DX94jzFUxgKrGjbHsiXBR4zeoHHa",
    "DLqELWCRtqhJWEVSMQF2rYvXs2VdVYvs4Vhwu6NCvgpm",
    "DLtdoA7DXYMW1J1RRmb8mZgfdj1pYWXHdppfay6CuWH4",
    "DLx81Q71qVEv2sU35VMKy58MNBdKpHCSWSVrqXGmHBnd",
    "DLy4LEnR9g3jiNCCZgDoNwMBedSTQvNjUG4DrgteiCiS",
    "DM4vi1kHb4WDV5b19s6GycbKRcVG7FApbPegnBC3cgAJ",
    "DM6Q9ag3qjL7YRUm6e1B9CDXB9s8sS7jMHyG6y6QihQv",
    "DMFXd15Qv8JPj5K5dJn6FyM777nPXtj1J5cz7cuPXP6k",
    "DMZLj5ucRNhXtDswcUnifai9PLxKrazEY8vrjStrA2YE",
    "DMc3DX6SnFgaNXM1BS17mDgXeJ6Pub9vjPWDqmThLTZL",
    "DMh9vX41c8sBF9r4B7EvwJwG98aqph3BL6AfeG8fDzc7",
    "DMqhrm1MZgwYw6fnts6nDXP4nsY26qbLoFYhpRcduoer",
    "DMxWhgecWaAXhfbWk2oFUnN9mTxvSktuybDRALiJay8F",
    "DN64M2w59e9VnA58MzQKXPi224ah8Qt8KoKL9yPJf4ku",
    "DNEw4EpRi8jZUZxqWMF7YiFEFsdM6vZHGgTKKwRrmJ63",
    "DNLiu6JLutvCJtG4hMwbErcbhM1DznWze4QLQgJ2SSyi",
    "DNtw16VaCz8BAfmmgpshzmRxtsSVTzxjdU8iY68yateA",
    "DP1F6UcRFLbjfXTkzHMRcmCu4H9392JXWiPLTYMU8inS",
    "DP4qV7wJTiDzQVnPRQfM5AdVJyg886BYoEJEbL9esVi7",
    "DP7oc4HBRZNu3re8ADNyuxtHJtqv5h5SCiecLzY1sM8y",
    "DP8pzGjoDah7qm33hWc8wvSefQfvd5qEN5AdyjymnkpG",
    "DPbH9dnyYh5ctVyK9hSpKymEYkQ4TfUV6tZWEcSB9zUz",
    "DQQu3ejP4FMmjbXVABEppSPwfGxAxysv4yfyDZNxZ7eT",
    "DQWktV8XUTERGzBSML114rpy5H7x1NHKu9MQgGVfvuH",
    "DQhHen2xcsoaHZsSsxtMvaGeJkD1uXXPNKJnSAFYLgJA",
    "DQnXNvDPkpPCrjTJ8dTgHD8MuJqxVTB5nRSRHJhtf16b",
    "DR57Qjx2X6FLbsSP1XSCpcXCb2BLWNw8cngzAM7X1Bvx",
    "DR9FuWTcbmbFksHfoRPzQbC1Twd1jy1x17Q562MuzY5L",
    "DRCgdUXXkiVCS1dFP81JM3CmernRdZdeKVZNTAwqZ66T",
    "DRDmm9WBKGuqedimcNfYnZVgUR4XM4oZdfiNYAvnfSTL",
    "DRGVNg7LwZEiYE9VmYYsJtYtpY14reTaXhvQwX55e15J",
    "DRHk4LhKZ9ZrhcL1GU2585kJiN7K7HYjGdFQAMKUdb7d",
    "DRSjCGWAXwra2ZwAfNmnKFW2QrgDJuaYWZtzPnuiWeuv",
    "DRsLeECKUo5p6cDLQtkGPs1ouswqERVTERaW69rByM24",
    "DRzq7QkBmxFM9Zm3seWFrit1xwAV38pjLCJ2STszVQkH",
    "DSBkXhwTGYspKoTh85PLnfM4VwsFJ3iBU4A4afWJsswH",
    "DSDyGbthgc5ijquTBae84UJeNibWdQasGXPEQpCat929",
    "DSFY4VatDj6BPuSts6Eot747JZFJ2rbEQdio3YXKwk3h",
    "DSSSfRZ35ETGCcomp5o7NpihHYusFJQZVoLBt45WT4j6",
    "DSTGdY3XWNnZnYGcKkrfNHD2HevSpnZs89n9628HPbK8",
    "DSeZXLPbof9gz34FhGpLNudq8ye73KB1MNcVdXhvUhNT",
    "DSkjksQrC7UYs8LWSueFetRcrMe9iceWX7AcwENAnEXT",
    "DSkqcjW2Ni9VS3oKzzt8a5XTbhKKT97FrPoYQjxXMfdN",
    "DSsFsuENaZmHiNNzTd5Pq9Vr2Zwk1QH7H3CZxdBW2L2N",
    "DSt3xfWCUoFtaYQPEULSvRb95GZvvAdqpmnRTb9xYw4w",
    "DT3NJ1mjfvwDqXxF8yWAqwBp49gYw9kuEP3s1c7M689D",
    "DTLAuCoeDgPmk4cirjRWwTnjqvt9FepJwNWvHd66K7Qo",
    "DTY8cFMp6xw8453e7vWtZhgcPAcsrWfWV79jJjuCMmmp",
    "DTYtXem1PjoevbAkfK9sLJUqXEDypVbfJmxq5ko56GXS",
    "DTcNQvQyKC5gmCWndQfbmZPMroctZJa2YVe3YNsKZZ9Y",
    "DTsRc3YyedUKcRks3EydTfNxwUbaxvxWFqekC1b8dRzX",
    "DTwmibGupDi11fjCJAfgjE9Be5pEd9C8GsgTRteAT38k",
    "DUAT7aDRwpNnpwJYcJhZ4fgm8fmJCpewgUFuWu5qfQaG",
    "DUFAzg1x9MjJxfpUfSRbNTv483iY47Kw8iWbJEBxWFkn",
    "DULk2B9XGTnj7TtLuDFmNDYtAKXsk3UyibMGUGLWAM8F",
    "DUdMWKQgWBC49SvG8dedJZbuxrAM3pzpdtV9Qud5Fixc",
    "DV1mmikBsYp892d1gZP4Sxu9yjZQs6WGLFTiFies4xqE",
    "DVR8VxJYvC33WLZM21aviRgidCGn5yRR9BRvwpngouNV",
    "DVrHLSUH5jc23697avvkJ97EPiCTWpaLLr2kQnAyCR8d",
    "DW1DfwcGkG22ingL1Z7SaesehjixpEoMUYfNogbn5rCK",
    "DW2P4UU3BxDMtMs3ubq2otDyjYEXqmuWr8BLHh7LEZ5",
    "DW3RMZv1JV8uC9zQdjpxHuGJue13gZ257FXgtEh6M1aT",
    "DW8ju17c2TTsRnEijt4M9nNeSghqZy6a7eqaZXeVAo9k",
    "DWDGHV8pThJoK5LisMNJMzubE3UQdTVVSCXr1R2UmSh4",
    "DWHPGCPw27gcjTXLVKpWeU1ctS6ePvpFzxSSd5oW3D8E",
    "DWUfMebUjhbMvSxDJeEQhXwa8q66gbc7hkuak8SZwpzx",
    "DWzvEdYxmoPcQ2rCXg7CqNj5mAVy3Y5oh6HDu6tXbRTe",
    "DX8Kq53Dfnx9ZL4T6SyCPqMmz5eVixwFtoJDjgmAwcCe",
    "DXBoozv9uEJZh9NFiCefR4Y4qK8ZVyyjXgRu9moLvqZC",
    "DXDwmX5HiW2H3YXt8jkGZNpbE1rAwRR1c2GUu9biX1Qt",
    "DXHyANFfkiZtj79jWEgi3KCD7HCutC8pacP9ELmufTPn",
    "DXSynevuQLezLBamSWTdeMa8L9JfYx8bPrG5EHDLoVVW",
    "DXYmFWCwRJuQPfirvMkMps6uFNjN2VWehcVepcUtN8bC",
    "DXiL5WPbT5UvpaQtDrhnQ6vv3HbrN8vv17i72PyoXga7",
    "DXoetxmxivn4hYsRkXAHxiqQzBqjSdPr66Wg7ZNJoRiJ",
    "DXwNHWbn3KX5bZLJb9uj6Apcm2i583D3tH1WF3xY6sGy",
    "DXwnvkLhN2mcxGtFvNhynerDazC8qJdafbcGTajHo64Q",
    "DY2f1VbvghGHWtNGR31bfT5gNj5HdMvfu3bPeXgPsMz8",
    "DY8ysxtT3Vtig1t9ykEydm7dnrfycnJuWCzk5TzvDViC",
    "DY9K59xx8AJNKh6MsdJgeMRfU9cSjc1uVDapQJFs75vk",
    "DYBjW5SWhMQx1pKYLgnCNr6fQD3yE5Gu4MkuTR1z5xPQ",
    "DYEyAmZsYckWWRuetErKUjZ4P4R5REgzaiDZHg55gBVq",
    "DYLvWX1RFXY4i7v7XaZiPsa1HW8TKePeqohcHESEzjtS",
    "DYNDBkPMGWLPUqkNkPhdSCQUowaJrNeRrH3D9DW8ZqC",
    "DYSSvBq5gVK53H1nQz5aSnGMAXy8hG8rUa7jkxdXwhsZ",
    "DYePcjUaqvnEfDT17wwo18TeHpW4qWbeoPFqaxKPU4Fa",
    "DYpQwWsQBSBqidd5RcZbprY2iQ38bnSot9Nfo6McDKNL",
    "DYtQGBNKEjZcbGAoS6vSmd2mppMKC4Sqk86QMpziUrJx",
    "DYzfY6sWePiDhZpDowvzdpqQ7sy5iJ3QG7MSYApaP1zy",
    "DZK1upXniZ712uyynfG2eCjDjUGJt4NmRQLxz974sUpf",
    "DZY8tXaSK2X279cxXknYhcskU8gAcFznJJtCp53CHmxC",
    "DZr4Ys9tw3LthtMKGvv2Zj3ac34SgqaFFotJpgCaaH7B",
    "DZvsTFcbAzE7HU6tvKW8JMPAfWeKBLnHHgtZWFVWxyw6",
    "DZvzRNRaKS19c5m43p1cST3d9vPZJDzUVTw6ekYPPLaR",
    "Da2GZ4cRv9vhNfyb3ft2JpxEKv7BPLjhD4hDjgkwQXJd",
    "Da67sn5XmWMPchLYdpwPeLxKqj54uMoEVwuXiFpK3ndP",
    "DaD52YESZJiyTEuEwPE45GnKADKyQGrqkpXRWszM54ED",
    "DaEA2FhAqkuYXudH7YE1DyzgzjeRb5AtPLqBuSRPUt8d",
    "DaLCXKi2S6fYfNy83Khb8ZAADDv97wYVKwcK7JA9YZza",
    "DaVXSe6kkAdVM6CSF3UmpfcTgKj1dfdeWiyrkZURU1Mq",
    "DaimXJMH1ZCucktD3cpNATk321JHChzWJP4U79kBsNra",
    "Db2LzALN12nwvAgFqdxsoUNrNCVnaRQzJy97gJHdRhUb",
    "Db6dBnJyYBEJaVnhWuAdKyThx5ZQSv8TggFDfqUaePob",
    "Db8WQMJmUDcQ86TNXxc6e9fDFnhMEa2JsPrqDW6ePQNP",
    "DbFGUXYvg3kmivjvcZGV1qYPyzvJcjATDKqDPcm5Lmsa",
    "DbL2jk1fyZYX5gvZ6SpYB6VprQrGAAP19TxnReoXa5V5",
    "DbsPk6neKTM9CAbRofGj1KhtinLtUGzdWwQt3c3ApoQs",
    "Dbstyo5uqtEasCxVefKzKneT8XzTt6aJsqxQgMyehNqg",
    "Dc8ZVAnwyEEgXox77RXYZrGmnotk1UGf8WKSsmJzAP2r",
    "DcyyfUcWQ5EfWLmsFU9gxwEFTcXxRSYgc3M1zB9v6qdC",
    "Dd285TWeS1x2vSNUkg4Qrj1vfxNR9gtTP1sAEiubbq1X",
    "Dd5nSQq7WNXxavNJ3P7oYG3HhfJyxhm2qwPi84Mi4Uur",
    "DdGmbi4RrAWE4F5NQDiK9qZZxfQGDxXdyARhpaxC4z86",
    "DdHGG9uFCg47wLGsKSdLN6LCkrEsTH4FQ1XjtpzQ6ctA",
    "DdMkDqMYuDMU5bG6HgAtakjVWYJqZuZC3gXD2LGkUFJM",
    "Ddb9sJVqCSwNvwuNT19uDop6yuY1P6bCLXVoKWdvfGKz",
    "DdfsmxT345fW8DhtffMExXtGkJhawSgXZRKeZD2Ff3SM",
    "DdgHDbvX6VrDL6HjBrd5KpvpQMdrLuMP25zyV5C6ChC7",
    "DdttXUhLmxMATXgqEkcetepRucobB1RH9RxkpUh5nLhf",
    "De9ncBQUAVwb5E7BNKw3A9URYb87BHhv8a4sMtr6Eqtq",
    "DeVtYK5Y2QfK1PjR9T6b9hV1o8eWWvNaUrruj1sZKzaq",
    "DecPgymzyPrG9fRySnmUzTondT8B4rByrDAuaocs7otd",
    "DeeeDnu9SDGEyfwzpYjrbQVjx26MWdgsvhdtmo7Khbyo",
    "Dep29DBRdjcYsWpTpDBDLRMa4NHAgrzEUJxfyUpMVx1d",
    "DetEoYA2xENRH8R4TFeznHYApcZbdZh7xvRg5EMX2f3X",
    "DevQYchZLSuVoFSfWW5RqNiWv4uW34GwFbsB3i1UU61V",
    "DfXdMgyU6bkht2KmWQJrF6kpwD6mixmNHK4scTEefsuE",
    "DfYxZpW9AFNeJasKKoiTBrW7fRZZtt7VTEDdkEsidFU5",
    "Dfun5L4uKH1pw5awZN72CatkgYVyd9A8YV4mZ15qLJAQ",
    "Dg37gB75UT8ouheUXi7PwgNf6ZpLVHs25HLjwC1tSsrb",
    "Dg4A7fk4knp2LBdmVS1ZefycV3Wwedm5teypwnAkVuD8",
    "DgSGJqLCBm6jHmzRW3iUCNnAW7RxuBW6KypkjNePNdKp",
    "DgSnisfs3gSqa1WvypxTrixR3XjunMqyK4Vm4qrQtLxV",
    "DghYUu1miKxQKTWiTr6SYxtyNsyDav67GkFZz8DQxav",
    "Dh6fL352sKYjgcdD2YhSdJBDjwkf9Ty7uq8ax5sLMcjr",
    "Dh9QADu4oJDy7jmNUHWWvMgn8Wr2DnZExaUxDsLotAoD",
    "DhD1EKRGHnpzAZTrXVaZYxXqS1retaJ8NVx4dSbceU6U",
    "DhYrDCQGufNHgCpQpYSfCmzSJe9mQuxyE1pfXjfVBG7Y",
    "DhnTBDMp8jqhMNN5KUWHVMDXUzEPR1xi1dnHxogM9Pub",
    "DhohiDwrcck1HogmDUtWpQ3VgqqErmzUt1h9ATANcQ6y",
    "Di1hWfSatUPz5PFB1eDtz3NPMUKEJqXJgaaE3VdSQpA1",
    "DiHqLNpL5MzamA4zmUfs1F3gfFobrqNySttve7s3cwaG",
    "DiNv2HEPJavT9TGry76pKV98rNygd2fSLs2bFNSfC1aa",
    "DijvzvW8T9Z9yuYpngjUuVvwkB7ND744112kdenmsxyC",
    "DirStN999J5J46vmww91M8yq2EGfTt3DK2AdDD7Z5ku8",
    "DizYD1it1oUpFnPs6gGraGq6wrHnyG4UEyyJGm3Xdt76",
    "Dj2F1ohAa8jYkXrLHkF8T4MseiecjWPGpbCRzwBt78M2",
    "Dj9WvNxWEswCtkuCbTVa56fztr1LdppM8UB3Ld17DEgi",
    "DjRRt9YsZuZmcsSPPrys9cTMkjeJW38abM94VCjXagVR",
    "DjfCH1qUGPF9vjYJHbm17JtpQzRJB44fEJPQpndke9NM",
    "Djpmos25a8o5kTXwSL6WE8wAPKZQuaGJRpjy4rpPQG4N",
    "DjwoqbTQ7MBUArCHQ8Z6MyZ3PniJg6jPv4M28xDePjxm",
    "DkeqakiZvfWYW4WjvzmkzU5eoXRQCkq5ZVUa3BS9n8gn",
    "DkjFPw8EgwfQWKw7eVFJ3RQ7iUTEA8o4jJ6AxxV9spnH",
    "DkjeSsjGYUqjx7PA8AVSGr34AgCfdhm2tGHBfAD9mpn5",
    "Dm2BKuM8JSn7bc8Xy7AaNCN5bbxxHYKgn1C8iJkoUN5a",
    "Dm6V2BevBtnovgpR9eURvgsY5mBGeVhyiJwNAM6a2wR1",
    "DmL3gXjU3XrwR6DotuRvMfXGmfMqVTmkZFZCsDPhdu5K",
    "DmNnnZ5wdf7ArBPxVRyqkCrsG76sdamtXY6d2kMF3DjK",
    "DmRztm5VobX9M4FkmF4wMUq8haMhK2mXuPgQzZ3nDi9d",
    "Dmc56p5YARQmuJFC31Ld23YwKEC6qqbM1YdpXDjA7ydP",
    "Dmm2KXsCTHaDgsKpvHAGgNDYYMoCDYm2C3zRriH5xFS7",
    "Dnc4cMDRTwBqDAJ5UHd9P1YpuzXcV8NYGzv9ME4KNi4s",
    "Dnm7XPkaP1yCxufYi6Njhp87qVdKBgq2LXfood11pWpZ",
    "Dno6BBAE51g47CNtYN3dzEbkvoB8pGh2Xf1XYTMNCN33",
    "DnvPJTejYPvXVxi6cHt1QWAVCkou5LjWaG4ruo9pEpFG",
    "Do2p1utzkmZMJe1PwGteogRkKyFpMQTuyTQXT7DvsXqD",
    "Do3LsV7PBg37317J5TGPgQPvrh1QtEPXY6WCj1FwFymb",
    "DoCaA19gnVawb6pJJytvDkYxUpLeDu9RzbxKFZeVkFdo",
    "Doo3rMbYqybfGpqfCEa8tYs95AWKnWTmcu7Evnbh1xTX",
    "DoxyBfh3Uw3VVGMdMJbJTdpob6W9zGB19eVEoT8RrDdr",
    "Dp5izerTfJMgZ8QXg3RMKzMf9ggYWSJZKnDcwMWEnw3Y",
    "DpXqf7U1j9uwRRgP1nvfF6LV35rTcZbDefEovap2kga3",
    "DpYShu3gkBayfZunCGDE26HnjUTjHh1Neg7tcg8ARtb6",
    "DpjEusguMagvv17NhEP8VdwBoH5g4yuMggYpwW8ifsSZ",
    "DqM5sdkpiXBjCHZuXiLhRRyQVKcYfkPKjghYnkCWFFaB",
    "DqVjgorzRxiu6s16VmsXCSBWm52PYKHypb6Fx5JtTTYY",
    "DqgRs873FP6NMduHPDc6k3H5aXTeExHJ634Jp5PLEATX",
    "DqmpGXqnoJhABvqsV7yEe5GT5hRzWDuSSuaWCM15t8a1",
    "DrPN67ydrNgY2ryJtwS6jeLJakprg5pEajZZhiG42ea2",
    "DrwY6RcxtWU13dMgVWRsWcH4TLmu9dZMEhokN6aJjMRg",
    "Ds7TLDeihPT5TCKxTuWLpUnVQPtTRFSUhPYNYdAvLQCL",
    "DsV3cNwSNERuPyeGaS7xnW1WMpmVa82mdmx7vnbUECvC",
    "DsoYdDQq2wdZG9AkMFyME7aRLSUpP89KRfZdX5cgGndg",
    "DsquxGokwSr8XhYyK3eAfu7q26xTB4YaxrbyYBTR3E3M",
    "DswX6L1EFZXnNqeSvFqzKPznK32kYEFvsT4iPq1YFYMv",
    "Dt4ANWzqxsqNButV6Lx3XhsESsEW86fFFAMZwNiGvtrU",
    "DtSvgN2gLamsWpYfRg99mVrTD6QAAyKfRxCbAAie1sph",
    "DtdyQok2kPKt9McAwL74vsKkmtAmHxKZfnKSTxVhZdYR",
    "Dtoa8ygVVmtkWU3WHtkPpTufLQ83vwW1vqaEXcvMgG2C",
    "DtrUYFpkVkik63HYhuc23R6XskkuMLJ26fenxySZzjeC",
    "Du36sNwAw7Fk6diWiVjhHtKiE5neZeEpF2qdbipgGJU5",
    "Du3qDNfs7VTYgy2mqcKhkMeiovVTMpZb2vv3yTDM5FuW",
    "Du55RbnpmbPHyibYec29oMXjkcvUCinBNLb92MeB3eJ9",
    "Du7hHK9NHphybhGZWMyKxpc9RFDc8nAdgAGRJuQGf26B",
    "Du8iiZKanEUqNfbomhw1XizWsCqtuWNsPnXgGpiF64Gf",
    "DufcD7XjuYdT3xkG1JfiizUNHFhBWYSnPrWMCy8oXLHe",
    "DugST6PFXEsSom1SfisSiE3thtqqPFxdC7ZcdA8UTS1N",
    "DujGH2Qg9f8kJP3vzLtPcuuRvKgfb6fE2mEMVvpjf23a",
    "DuvtZ8aKjR7pijUnYkFvWo8nf8X1PqZx772uByCxup2s",
    "Dv6oqTRP4gLD7nfXWTJeqEes9SqgCRA7cqnX8VZUn3MB",
    "Dv73Lu6yvAHM1nwe2JheVGgNZPUAXd5QAC89PPRTxDtM",
    "DvFBLV7qzPwcVM5kiaJyC5d8MwsDoWERNka6qX2FgeYw",
    "DvZ9wJSMG1AENUuuLpfoJGvCokd3oHGVVhow6VPn6CAx",
    "DvcXVmHfqH86j4benp23m6QY8mDHs2ZSdwkzjitJGLvv",
    "DveifeP3rpDrYdrgGahJBNGmnjkYwBbihSzTHAYF4KXz",
    "Dvmt6ombWcaqzEuSAPzH2twJtssWjMNb8GSGBk9kyj8w",
    "Dw1uHdE2Eqh1cfqA81rYtE3LneikyycVznuKrv2V5VkS",
    "DwEzsKvJwjHtia3ssbyeUAAjFiadDa85e51qhsF2qg13",
    "DwHiJ8sfPBHkXSd7iucCNFZnQESyp1YXfb3XfQDVECcx",
    "DwVpEeH4eRH2UHtWpVvhf3M3yp2SHvaFGKEKJyWCMBtz",
    "DwZtvoUbSN9DR2A5zn346y225hg5hQBp7FFDuy9qCYob",
    "DwhjeAKahKo85SitbcnxwmWcHD6TdTVnf5Ay18r5kv5T",
    "DwjWM54aDVfHVoXV9P6S1jpSQt3soNY91W9VaVYW7esR",
    "DwoX8ti9ERWrAZ61jqC3VCorytwc7KneMXoLrXs2RA9B",
    "DxBJbyq7J47766pfqfQxtCmn66HbLdaKx47t1t58dsqg",
    "DxSpFk9WnR8LxchWVxp8Dt8N85vsZW1ipkgABvZNwsh3",
    "DxfS9mKvG5kHdRcpQWfnF5aDgk613e7iyprz84zvwBp5",
    "Dy56b9ZkcwvLGZhuGLSkGeiQ53yXcJHnxhv4HsiPjzZt",
    "DyAER6Hk7rL9qEc1ZRisr6iNjCjg6jfG27zJRtmwwug6",
    "DyYGP6UvXATp1m7yL3htjSVY7csmeUueEbteDj78JnSu",
    "DyarLcM7MJ1o9PoVQuFUnsEYCGoQjWWbacg2qUmtuGXR",
    "DyghvmLd9koxTY2mzSsondhmAJoMt9kysxZyFyCyrVEm",
    "DykCG7WEUSd8UrChMPZBeecSz7TKfDDz1FwkKEVrKWM3",
    "DytJoUWesh6AMimDZzVvHqTwKTp82RJySXps8HVHkvf1",
    "Dz7dg1cKXgJh4xj2aG3b5fu1tLQaT2b7UridxrCY17y8",
    "DzUeHCuYXvTz1F7hvZ1hCAKRKrGReewuuPf2NmhFZmMv",
    "DzfXUj4BdRTrErF7W2TsZmTQcc4ZhS4HnsWMwd5FLZZS",
    "DzhfAHSV3QggoA4B74DxYuFf2DGQSBdyyZ3scDxWnTUs",
    "DzqrsxeAWF5EDxLBgH56aRq8JKg1jA2icdXMZq2y9bav",
    "E14exTqAvchjuDzfxAJfLmkoSRURbQvavDUh488aqtCg",
    "E15Ky3YgSh5dGsBgHhhfSLiEnnZYn4jJ9PRF8UfPmsAH",
    "E16TZAoLygrP7Pcn6e3MTJn4HHP2GCddqui8a2b1YzHG",
    "E1PBA6WMzv5bKEhcBijMbydMqL5hpy4FFLcrr8MbRw6G",
    "E1SbVK5LpGM9HKjWmC663RwexJMDPQt4bH8JA5CqkUJx",
    "E1SdCYHmQcCtnfBy9BvzWuMujCGxfDyTJdCnCRDhz11h",
    "E1YNsjTsXN66LY8BJAu4VZt5eQWcSiwFNQqXFmj4mKN9",
    "E1kdc2QeVtfc2UtVKnxgHHQ3Mr5SHeomFZdMcerbxX6",
    "E1kgaP5nzWTaKJzSVcnccBZyxHVTdCAK9zmoGyD9V6nm",
    "E1nRx26CeNztfaYuNHFiFhsXF2tC1GepnfqMz4JRfyUj",
    "E1uWNQQCLm6R683Y8VBgBMuLT5dAMgr2bLBGksGzRBbF",
    "E2FFEUFGxGcDt9VWvf7L17ueU8mEnfUWBRKXekqGtfnv",
    "E2QmFdvUBRVhv8MBFEcEnQekkcw4kF1uX2mF3Z6b45MA",
    "E2V9mqJ2JHT3Cp71g78XQHuHCeuTzxNtJ1sPRTaX6Maq",
    "E2WuFpJbhyTocuPSCJn4xid46RrbBADZQBR5g4xbxHq2",
    "E2eK34w6g1ZpGxUeTwbS6qaEj9KXAmRLULiGqgnagReX",
    "E2vmyN4daVAZXukzdwFQnG4ZjxNg3hFYghNtfQDcs8rw",
    "E36E8EhCL5on3LzDUszjgstUFQGmLetPdsS9Z9b8ta5s",
    "E3Bji9QVnyHiYaK8NtK7Wpc6fKKaGMMaXER9NraB9b8p",
    "E3HKsBgf2t2eFtVTVV7oj2AUiht4yrUjpJrALCEYtC3n",
    "E3JL1rh2hsDEmEVaxPVrBW5U2b1ECR3ZnAz1h6RSsYHA",
    "E3QqT7RKa33HSgxUD4wgPW15J4JNhhAMgdEjgAc62arF",
    "E3iXUxCKcftWVRDfkT6RszDgjByGTZzJWpgT169bwjSC",
    "E44SGZjvoFWtLWPJg74qvpDCGp6HfNzcosFmYnt8tLHL",
    "E4FrpPPbaeVh75DckDdMbJBVtwaDGffAuxXVySKyqNB1",
    "E4QTbstR4yUbVEsbhRsBQReZHiZRywA4d5SbqUrEcwRd",
    "E4W7TeJtZW4cvS967hdnpuuzo5d3YQ8fPwGTnqwkRY7q",
    "E4cGHSnNnouWuMYyJ1Yypcp7E8B41SNvsooSR4SXqqA4",
    "E4pdqYc9ZDzzCyMkoZJByCNQYzDSSEX4M5qPaW7GN8Si",
    "E4zCBxi3cchvAJjinrQEt7FPBoAG8XbtC4etEhaYeZCS",
    "E54NXFSsuEgVkx3rsXvhCizGmDsRYAAt5DkiJqpoG5nd",
    "E5FG4WmfoM1uZnrUxy6VjAanzN7LzKgWvgWyqEGSWGBA",
    "E5M2AKE1jneHxqNsBDa66JxAuwbKhmsn7nCBzW2xQcQk",
    "E5SVDZCXYdJJyyjPorzcvRQoANXMkwyoSD5KaqhPg47t",
    "E5d1V32BLk4Vwk4hrzncRJtTms7a1S5g8ymXyzdfsEFo",
    "E5d6w1N27vrewhQomDS5yXuU4hsht4vZEGVdHMWmv5XU",
    "E5uF2noqGK5bbipUpFReKPXKpUFpXi2YPyQyW4XojCAj",
    "E66HaCRjhJdYongbFgHd5TRSP9YCgi7D99sPeXk6ZSfv",
    "E6NSTcVLTxBpbV6WeVcSKPB6B5FMWdHFTBZstyBAr7ZG",
    "E6VpLwmi5ta6BTZY4QCZkLFLRWNDyLG7DYQkoBD7JM1X",
    "E6fNU9LD1nJTG2CqkjQAfqaUAagSsPgbmfiqU7DzAUZa",
    "E6wf3H9v5eLc3QF94qoGnbwhB8ZtrK1VVNLJHHRQpfML",
    "E72j6kSmXrDhJw3XNTYg5eDTv9AA8tWJNfxGeNsV8NUU",
    "E78bEykAjg7HUXzqvBSsaSgGtRu8t7RF71oC48zKsRaF",
    "E7L7gKnEQAbz9vs8i7qofgwSx9D2WJHoY6hSFHUrbZtv",
    "E7TYTehFNjPedqeGN4e98zA2LmiEDSdyCAYMrhN8bSAk",
    "E7cjr3zqnFz8heiPDKbdfG776XzJHNUNXEKR6FKEQQLj",
    "E7e4RrHNAz1RSEHVvrvfsE9qfaQMexih9Vp6egBdcduE",
    "E7hnhYCfncA51A6Bvkobs4C9qCuArkgVauq3gHv23rZQ",
    "E7uKkh1w1H3bVKQUarrcGLZjvfr1evQ4yy6yPRcFv51E",
    "E7zszaqmmqXZ91Thx7PM7qeMcCCZfo6n7tgW6tPMHkiM",
    "E8JXFhB1viRz83TRJgxKwtL44v5ohii1Mpj5NAM1vcrT",
    "E8p6Hz26e97VFLQq2NmqBeYbaVSkaF4rXJoDCRDurt1z",
    "E8zNWHXHuVuPebH36HRPohJstmTKkw3KyuoKPnBgoVcY",
    "E97onvo1mqFRoJ7TQNnXnLRYUE4p4kcEkbwdMA2B8fGV",
    "E99QRUv46Wf8NpCiUFze2aTy96dTsHjMs85T2F1h3zad",
    "E9LUNtAoB3TmGNUX83haaNVSJuEehxEEpvE9qgPtbDoY",
    "E9PnpGVcWUj3XwZm5QxpDXjHkXEnD4Gn8aadGk3aEE11",
    "E9oQgvd4ySkLcFU6dLX6R12MFMP3UF7mhXX3GugCcKwW",
    "E9uhSTNc4zk7kDKh2p6rPUdr8mzh4cqz9qZSZrFsYH1F",
    "EAP7JyDEaaUByU3Yn9PBtmfry3RRAWUt5T6cEgw1y8GX",
    "EARm4ekEEfWYggrimWXtuCEuxc3ZveRpoAQwQ48V9Grf",
    "EAhcdLXCz9os85HKUGeuTPsVAwHmgTQ4Z6T4oyNXCQ3K",
    "EArxGgc7srhctBxEpEx43fZF3QuiqG7B14GUFPCkuQGY",
    "EB7QujiYhSL2kZtYfCEt7SEZCnr5aZWMZ2yNEHpB7Wam",
    "EBR3nE1izqPNiMAwgmZoXznVzbTbnwHCappC4RNaWUzP",
    "EBZpUbgtBpLJZvyBQJMRcQhWsynSk1AkAdLsFKmx8ZYQ",
    "EBa5xJtQFrA173hxqhyqqAubhdoBq3YAfE8TX82gV3CT",
    "EBgaCADJLx2b4BVk39dD4MtJiQdcSjMsDA9dBMujRzkd",
    "EBoYTsP8uEv5vRL5ViCr5oZY59KWjKdCFKd7mMQNivnT",
    "EBpU5dc5GsrBNZAmVr5ySx3HuvTQs6WUwV4VKFDtqiM",
    "EBqJUJ4B9xNN3La25u1Zrnh1yewJpJB4e96J6oAfjtnx",
    "EBqkj8VWVL7Daadmo1Qr8Vwdk7hPRM9gckFbMgneJzxJ",
    "EBvD9YVfWBbcxPdvxoU894Z8tpaFzDY3WpAyT5ajVU8p",
    "ECFtwxp7JiQAfCVqugzMzXXJRU81ewJg5Dg9rQoF1rMg",
    "ECMoEAkrhz8wQ9FHgDcuZNMU9d3uNtMqd57v6wLVyDMe",
    "ECNpXsZ1TLbrjGuZE9686ZFbZwg8niVxbZvpHTdfHHC5",
    "ECeSEsWNvwzwBFJyZJuDA6EhhW8pCvkuVaReRL5wpo9a",
    "ECfbwzeKQXgMv3jkutBR72FVRbPV8RRLJZ6e5vS6MMiz",
    "ECpXxJ24MMkrb4X6kiGw481qJeYTuVdvbqT61SnAeTtT",
    "EDBTTjLJECZYs7SyvisWLrgtrkyLtSgLdCuU5EHb8KFR",
    "EDV7visRc9jvmgtGe2rvWcgHXwgHMGMa1Ty9rr1jV6EP",
    "EDWvQj11AvKJuXZ1V9VNG9JkLfusX4hVkztVde3coGsw",
    "EDb1zQ6XFdx1bF4rerTkxxGvhGA2hXyNpNXKCdaZTEtz",
    "EDe3HPQQYcSNHE6F7Jre8PQez4G152zfcuKdXxDrFKxk",
    "EDg7uj7XUV5furzXiFjSYBgTErSW1fYRTbz7qjGhpjqR",
    "EDpkpLF2pNnDEMUwoRcj5u9gN6d4pVSFaHJKdFbfvuXA",
    "EE37ecCkC5Hu8kuqzcGtRgieXSgf2MnFmaNnNtLtzTEv",
    "EE6ChrHvLRGhzQfbmueZ1j3k4xfwioh6KW4yian3Di1u",
    "EEEUSYpcRT8E6FHiPDzz8TSYuj8Tou4xfWktDD2RymFi",
    "EEV5h9pJmrWNimXcWjQ3wZQxZPbGusHDniCV8ucoLSui",
    "EEWU4c8g77CtojT9kijikzJGABuZETmUk4jp8hBghQTe",
    "EEbZbpNzcK24THgKRdRQR8iR9rXMfLUqnrTvFAZEEzyH",
    "EEcpguh4JGwrSawaFMUBvrTchetFc7fZw3MdikqxoU7F",
    "EEnwRMkGVvGqxJGrBKBjY2FkxbbK9WgxQHa4rhmXQPZK",
    "EF5hNNVYqNcKRsR8HbFooTK2fnS4hGHjgURprQAzjkHt",
    "EFBzywFRBCv8RX248Rte7crQQdKELyDV7cWBYyXeUfXy",
    "EFGtW9f5AnfkYhaenb7AmQUaYXzfhm4bVcrEoe9aYFha",
    "EFH1w7AnvXxbvyPrZmf8v9LJx4WWfjqF1Kz7zKE3ZqtH",
    "EFQvYbBCCPTzGeC47qypA6Z4XHxGoYt7fyq14SMNAoLt",
    "EFg5zS7rhes3s6faYRhbA5RvCjyGEEsALmpGWDWxMJEz",
    "EG8UwLzRX1iqgDneFFKq5J2gqDsjuVaJNfwaXj3arJCV",
    "EG9tV7a41kJ5uCtrNWb4sgND9FGvaq1ugZGxYSmL3C7A",
    "EGGadJ4949Tv3uAy92Lxy3jrC6W71wL2k9i7KZSbLF7W",
    "EGXSza9D6dGQXTShBs5X9acFpDCS5jLWFBDzSc8ynhTL",
    "EGzod8UfjuyH9jFzJugxPWJKcvfUWqVgCLhxAxB1gahd",
    "EH9tSCyXK78y8aDi1Sdo55SUuxvTvHJ1uP8oUoiXzcZG",
    "EHUzz2s51kHjWeJDyoeBiBpHAxASH7Uciqk2Bm3uho65",
    "EHYZRuhQyyghbRmpKpJcF7gCRyvCAmBZTr2c56PASAYV",
    "EHYaNrz391btzTtPSLS61peR6FnzXcpCf14Hni4q22V7",
    "EHq3n1QczTjKH9iCXd9nAintmDq2t9fiv3bRpzQTokMR",
    "EJGWPVF9skNwoPkgeB3CfL4fsRMAZcXHWZwccHZHsvGb",
    "EJKFcN8M8Y45DGaXw77qqA3jAmVAKyFwtoy6gRhkfmBR",
    "EJLdhxzXTYtqGKwDo6UU1NYu3oaa3E3GeQnT4k6jZ4tK",
    "EJNoemNaPhRTU6PX8vsg3jYCmjadCEscgE5ixZPYJHok",
    "EJz3D7sDmpifBB8CKGezdWZCsbSbLwYdpr9a4Egue2CW",
    "EKJVSWJejfTPuFXrJNfgPHczJPJEXwwz94RB4ejcRSwy",
    "EKWQHZMmf24CsAECUVdyMZ5hSxVdQaBBY6a6segPzgRZ",
    "EKYAEP9N5RZhoWJGjdEfF6T89m3Nr9FTqAq9oZkL2iW1",
    "EKaMRZrRnVS3oKixMDvbdLz4BeRQy59CmRU1KkGkMaVM",
    "EKxs3zrKoKbY3C6zMKefxAETkstDneJsFr7ZfM8pNS5i",
    "EKyjJdLArnjKTyrdBKHuYNkr7Vx2xN5buKHM3CRUy3wW",
    "EL2Zv1hTk7E3bajkWyJUgUDuezAhbnYCpYMbLiEBqRBh",
    "EL9nYAebeXo9HkJx8xXCZLva8XGg2WAQp5czArPg7kHW",
    "ELKNtLKNWyGK4saRjNyHoamdgtQddyb8R4tueYEkArQP",
    "ELacyUiFbTsU8jkcEFxRaeXch5JXpxPwakwiXrT5iSj3",
    "EME4Nm7hpxxkV76yNG3SDvy1HKRtD7yeiTPRdu5tRVwU",
    "EMKUvgWPtGcxmMZ9Zd27JXvQ731S2fQxeWbnEsChBnrC",
    "EMKXiUySf8Q2V4tM3AViwWG7C9S9VdyjroLbtvZ1xZYx",
    "EMMJbw8YVJnw5CB32fC6ak3CxgKh4mYfvtzntS4tbcYQ",
    "EMYB91u2ciheW2s5wQYsBdsJeAYjxhS6XMitGuzhUAjW",
    "EMjRzS6qBS3KAeznxXgzjqGA945GobdAkizd32jtgGYz",
    "EMkdTwp4h33muJjjGM4tcvjtQiCtv1sz3MBxTujN8NUD",
    "ENRrXoGDTcknyQ99V6mW7awWH9Cz81qVSPQNeJK21aRQ",
    "ENeHUhrynz1j7Jqa7VkjtxTaRQEzH5TPUYQ4DkJtn7cH",
    "ENffYd3BQcBD9kSM1N6An1MA222MsQVSA1E3qhBbM6fc",
    "ENhhSNQa7KQ2YRJwfdKgd86qsQYFzSNCrwdDzQdszTHZ",
    "ENzFNq3AFAQ6witprUcdwgUFCTNsQGhQC4gvZHceFmM9",
    "EP3xMvhTFD8YTZZdwn2S1WbZuykTt2LrUrY5fkjnt8oP",
    "EP7wehYAnwKV5CA36Q65Mn2yB2yKj66Z9JJUAuN4ZFxs",
    "EPCoYLzrBLGhMo74TRLgQuxvrqYHfz2aNFfMZt9Hg4NK",
    "EPHM2nioUsZdDbq5iumYVJYA6NyRrDHhcyQzTq76ecR6",
    "EPKnvH3oi5RdibkZjpRrdei677ifPfeYgW7MnTcyndhi",
    "EPLpKhDo4BCHQDMLzaBhB9LnDXJPXHuHbdXQdmfBX6mM",
    "EPaW6UkVkCerCr4wn1raDVRQxjDHetZqxFzjBWtHFtP",
    "EPdp9PQHVWpknvwDjkH6Fb924wMNqzTuX8uCxuVZQQQc",
    "EPfpJjsDBxegfTJ3CEq3eKgEACWSbrzonqPFWwcWwPEJ",
    "EPiMQiZV9keFvnJJ2B3KDcWN68hUdMmBG99XyHCWPqbG",
    "EPvF9zipHLL4Qdw72oSrng8ane6wuyqpV7GFM59pAom4",
    "EPzU9GXCRSM3BhqudA2DWNwcBrk6YHMk868qR2zHwMDs",
    "EQ1E8NuCRDPuPfyUnScSbso52j4fxDKFJ3TPJW7ee9a9",
    "EQ8RLPbke6YgEy4Sv8JqABVppk5avsVwooRGkrrQ8AmT",
    "EQ8ZoAfgziKbuwFwhizLaAarbCZdFkQTDeUWB1VmbobX",
    "EQQdacFTmpZhca9dXoFFBe1q5DjbbDpYDfvwNdFyqetf",
    "EQizBKJbHMnH1dEPSbEE3DDuQjFzfvwwkQAeqkYnAvxj",
    "ER3RW5KDuKjBZ3w8kByKcrTTVDW7ieUnAE9rDN9ZwHzo",
    "ERAjtrucCbJrwzvu69emu4F1Yzdv8UBC4pyJQqsbaRD8",
    "ERCYgK7tKfmWjQZ43dZa62fd56QeUfaCUK476KhB5QxR",
    "ERQtSiMCwqSSSRirnQELFKJ8fVgnRH3Pet1UzKZkmcJE",
    "ERRSYRaLT7U7xhktKNfQRN3TqSoUkztoLsSWARLTXT8",
    "ERRseTpcfP5dAN2sMhxQWV239bxd6r33USD7woi9eGK",
    "ERg55PoaJMMbrbcM7xFp2P8T4Hiq3e65hBdDwNs4juGk",
    "ERyBJDqEJMvE99Gj27zDxhCpazDqHNT9NuzaznREvFZa",
    "ESPPs4BLZhFvPMeurFWDLAUcUVY5LYE87yGyTUxmDnDu",
    "ESZrxnbHGV8Bj2GoYBvrcgJogi8B8zgWAMdMWe1w5mrF",
    "ESjgm9R9XUiRxyYkNMwTpZ294D2XcdhXHZhXrg24ecE3",
    "ESjk9CKnsB1x3dqoSVrszsamXMDY92dqRQU16fEAKTxP",
    "ESzNowzfjrKx5HK5BqVh8Y8yDTqRGmFZqLa9wzscmPh1",
    "ET4QHRMfuQma25PH6ZJp77hYJmU2rZTaZadHcHRnowKG",
    "ETLWgeZwZvdaKVXnBDhVGjF7VRN93yhe3QgYDgjJHdbq",
    "ETWvoySuDLRVdXm7g9eHJKoLHPBMS1X5eUuZTGLVpBy4",
    "ETaCVseLMyn7BQBHpeprPQuWwzBRiPXwV8gox7VWjz2z",
    "ETds9nXXYwFUA8KDvTDuB3yVDFMHgusNrGLdcXNdiJdn",
    "ETpnk8sMQUm6xqSD5roQvk8s1ZZovXgtr2RQwKrufr2Z",
    "ETxtYnpdqY2cZBHHVGXWieDZqFBjbENNo6YBRBUknJPG",
    "ETyNamJT2dWyVS89GUcPvJh7B9eYctGu2WpXxQq1LKhS",
    "EU5A9CTRpjKcuhtxaWPQvdaVghHGQu9CMM4C9H46SqXX",
    "EU5YquFmXzZ56kCSHjEAxDzLsSi2SQvfWyy1FurF2AzK",
    "EU5ohMtWGdyeGEH5XUyXroiyET21e8gWvj6But2Xopgj",
    "EUMe8h1ouyPgEKxPsEgz8BHx3AB2F22hpZc1yDmonXcJ",
    "EUdnJHiaLG7DA1iqaVGGb8UmjLnvNVQ9L9jxsSFNAMMY",
    "EUiwAiFVr6W1EuvQWED5fGDi7oPscysGSgLNp2PrhtCS",
    "EUkE62uVxSKzK4PcmYVv5Kx8FCPYvKwPvxduBibk2ac1",
    "EUmfx6ptHDRKmvxWfCYkkGShnXtccBh3twiyCiCRX5Ue",
    "EUyafo5bKUxmwxmaSssfa8nssYFKkhB4SjWN47SnePYc",
    "EVE3JzEhAZGJzY1E8xndJvFidkNMce8Goyq8vYJBxJD",
    "EVKjtmQa1sdufcW8VzjeANmjogUsSy4oSA9VjPe45RBX",
    "EVVTeE1gWGPbKP6eszuuKmQGuKDuYogRDaf4tFe6PBk8",
    "EVY4516L3MJU5Qt6tbWUK4gQxDqmeGhcJYx93ktdpseg",
    "EVeeJNtt92p3XSD4jaRpfTDFteteGxGwJtPAqv1NsTLm",
    "EVgnacX3gphgaRzVoeCJzNDAP7g9MBBd6NjntAtiPvgi",
    "EVmLgJqBeKZgNUBvn8fMGuzirBEmE2efMR2fVY3BSJ6D",
    "EVouwdgRPcr42YnFhL2iJhgUiQQGCgnnbhTfmiETnNna",
    "EVr6RuZG7dgoV4pknuW4u4uxytFfn1DphC2AfiQmrv71",
    "EVvDMQHtgguzD72eRXi7ps2vWma6vdHCK1fHcgZMhh9D",
    "EW9oX8NL7ASGZXA9TafBQs9tDsJk5ySEnEsGZiaSzKAb",
    "EWGbTm6E4jj96KZEVEPqLQGiZ1ggwp4WN9z8GABiMX9A",
    "EWNugvXxLNBvexdV241uUrCWkMs1ZXmSj9Bf1re8Ypyz",
    "EWPEJU9Kjbn1aGMsgBJgQxzb66zwhh9SkUfDb6Nua1MC",
    "EX3HeC6JEajkiVQGqRkyamhkFaZ6bpNMFWmT5miwiCRw",
    "EX75d7wBwis6rdsyExi5MQrtoqfzQLmmAcXrEZJ7obzG",
    "EXBNTfHbZ2HuwhLRdSdSGZoxNWVigirwYCyxsjQRDRRf",
    "EXKx4BiAu4zW82tmASLCxX66CoYUuh9qzKSxt6tXVhKw",
    "EXQ8QUP9mUeXHyE1p7vq24iF5ZxgFZjV7CyfPoFDWHBb",
    "EXT41dDB6SV7TsQbH4EpwkjHJPcoETG7HtbZqBkAxA7r",
    "EXX5zZtAQAidgmRfLTS3q2fjomXbwwhZjvj4axWK7h5k",
    "EXjNPgHbouVBa37JXjLsCrBwR9eo8B5wFXAADsPzxzRK",
    "EY1Eh15f6JzgFhnhYuzNoxsZe5ZyeWgoZ6e4zv8auBF3",
    "EY5GRxWDK4NJK83edQVcMEhHQoDKJd6gZvoadTzmPbgN",
    "EY88xJJ7nifMFpRFPANCPxWX242U8dwuUiXyyUUNU7mz",
    "EYFJjnbHAD66hi7WzdiDFmbsY6hYksB28HYCwC2ySTWN",
    "EYqmFo74wLPTmdEYnZTHGeRKR1cuLSj5i6up4yiSEyRG",
    "EYxt73sq5DipmBKzK9ZiBKzQgoTfbFzmSLnAFHkebMsG",
    "EZ3Yo1ougMzC4ZUgw4ahSB4Fh9Y2suSsyQx3XGSFyhxK",
    "EZ5rFnGgGeAtaRvtvHMfrvwrF4Mt59ZhaxdnxRCn9Lmn",
    "EZ7yKC7ETT47cfqnoYpnfx9EFxpR2bn54MaJWFqb6pyR",
    "EZCArguV51XThBSG57tPxmGUXKVSVreecE33WcbK8HVf",
    "EZMRihvqc8mucuJCVHJuP4cvcS48MA1Zg3dDZ9jzq3q1",
    "EZmArWkHAnssHnMro8a53cyeeXjk8eeUUzCtUpC8kscQ",
    "EZopwwNHCTD3NafcbpvJzHja198eCMbw8H98SaBPBaaD",
    "EZyGguuLW4vEtt3ddq48bW2g1hMhF7YvngPdfMs9ZatT",
    "EZzvC32QgZvqRj8zWyj5PUj2C7tcqp9nAj35SUsrSphv",
    "EaWndCxC5wh9NECRXShRjdpFtGYerAenuEqH5q4xDCLr",
    "EaoUELJue8BCUvdVvbGR4Y2c4CzNJhJU7XWW4sw3LbpK",
    "Eb8wmxkXqz2iC62R9TDnoTbVUevUptBRxyDqn4QJFCJx",
    "EbCM5E73e7UAeriuEhYcTcHmBbFEZUwa5SkwcudpJSrj",
    "EbFyinGMCT4oQjHohNwK2NMSayFsrGAPbjTQ5Kkrabuj",
    "EbMB75CDUgyyk4gbcXiTWAQoVHfjAhZchPWxZMpnP5dB",
    "EbSocqCSUHoHzyGSVChmvQgQMv1CFhxRc7a4jpnaHcKT",
    "EbT8LT8RFmGQVSbW2xZJVEmAeAHm3prGHz6SWftG2E4Y",
    "EbXkRcdwXtxApDMMiy4wc6AfUYG1s71Y7g2Nz7ZAqUe3",
    "EbcFVJSPpqAe7W4UKP7iZKBvWJGmeeXDKwpUBxMkurdx",
    "EbdRzFLgXTgbP2eTptJGW41ynWmxNHxHsaqPS2b19J1q",
    "EboPqKbKp5bLS9neYhWkVpYj4m4A5KLGWdpBqQVKq6xd",
    "EbzVm76jfbFDHpg13SfzCb1dZuGZThAptHwmmKMfLV8b",
    "Ec36LEGxKi2aRXw2pcqP1iTJzfaTx1APK97eNbmigVb7",
    "EcGvGSVDqugNt5kuSQswdnMCQ2FP8dZKLaHrU3BQCJw8",
    "EcYxB5N7oU6SttYaDHyRx9MGvfwSjt4U4zCU5ZxgjGjN",
    "EcwNyvYkDqenLzRMdX81NELRNPH88Nvc9uCKtsCX68xp",
    "EcybbDRJHSn5Ke7FCBYUwYpDnizVc3dnKarHJQf4vZ1E",
    "EdMukhhD5qvJh4gM4GySJMPedqwy7Facug1e7o37rVBE",
    "EdWYvtiPQ42X2Sen1WpzgB9R1jwW1ksNBpgyoHeVvZWU",
    "EdkD5C1sy9NcVFqFKZeTZgpnAG4ALMvhkKznhxNr3FN2",
    "Edob2FPJhhgr6TBvUKXTdV49pda1FcJM5BeyyZRGLJ7w",
    "EdpNC7NFmDKkG8PqeHLKYu1hyWiWRFe7oQynzPKkwUDB",
    "EdyMUP2ooQa78QFRq9wogk7gVwAtgaaFi53sRaScuzwd",
    "EeYPYJYMapZRtroroJvGXvwzJLTC3N85N4Brt6ARmdTt",
    "EeZgcb4s86RhYLwpCLWy6E4nvmuvTr5aqQFQHJHqYz9K",
    "EepKUQszZYTv2GgMeiMPt6fp3MZvL7TKqGveMffwCZaJ",
    "EfY6oPcLemVaCYsdHDcmushfvhVyJv19pgSHy82AHcAM",
    "Eg9xfo99cDecwyZRXRSpPxatznbmqZsAX161PBwEnDA",
    "EgLm6YSSkDSDeyAPRKHChaAgLMWxapZ6QQvFtdhwYdwF",
    "EgNrAV8m8yXpM58AxuazEZr5gdfGzgUZSxwtjhMHE3C1",
    "EgPp6Mm4VSzer8Ug9F5uK87DF1APiLf7wFTvqVahE7F6",
    "EgUrBEZRkiV5GjnWUnefamboSXHKNGXC7kT1EdTgjdrE",
    "Egpny95iyjwN299nqQhKWvC3AVx3BvSZxRksaNkaFNmy",
    "Egv1i8WyHkarpSRw3JwmFWhnvebiLpNuZntFzeH694kU",
    "EhBhwZjjBncjKFuX8dpG2kvy1Rk3ucsmHAtd4mW5qMaQ",
    "EhHPkqLx3VDiyyGSWTffjNyXE9sFkXDqGiGMQiiVi2jU",
    "Ehke4H3RKsKbRtSsCJ5Fqma5GU63n8K3HrUiRoL4GU5C",
    "EhzQWrwRKpB3CJR9UKoF6if49P1BvcWsaamTN9nd4zQP",
    "Ei3w41daySespGRwefzCPLsrV5zso3tsuSAraxhtyy9q",
    "EjK9RUSGmtcXSAvJK8Dn44H726Q2J4FCqHHobxy5bX61",
    "EjRdYcQtBHw6TRVxbbVxwBUyyL1ADr5SqibEet1dVhqx",
    "EjWJBtxj8C9ovhrZLt7pk9WociUVmM7C76cnrtL6N8Ba",
    "EjnCKHp4PpV7uiMq2x6GXM1DQ3E7PcmXZBUNTPFPYLQx",
    "EjncpG6K3JfcrTKY19WgVwZLCqaQBMhqkSbmnwJoRLAC",
    "Ek8K8KrG8Pmw5XMNUezsLDTa6Jc8LUJcoum5RXkK5JzL",
    "Ek8V6z3KfTMXo3AzwZpyeZsaT4nfy3Vqr1VgQWsHPWfQ",
    "EkW45nP29LTCMzwx5CCY7rXFzb3NiMJHker2Fs1YyPHz",
    "EkWhtA9TqYKMM1qzRX38Nt42vfNGXkETtaVNni5zxhnA",
    "EkqnLPKsxzu46EGTVMUDUfq29QiMAqX5zCTSEXgjJhLm",
    "EkuhQJTQEiPdhXwHgjGGBDgP7eNJ7XoM4Y3ctJkwunWK",
    "EmA7zeMoVqkzHfu7nc91HW1hAwiEq9FjxufXv8Xz58N",
    "EmQwy1zBGswHm9KuNaNvQRt3TWA8wTxNwcQk2Z174Hmr",
    "Emb5XLJLhZ6MU7Uo9FutWg27kGEJw6e5MSZ8XLNFirMH",
    "EmgpHypFTFf2NkMG4BuvQjD1ngiSD3a7CCTDd7n5dqT6",
    "EmxRV4s6Hrt43c49whsToMPRfD5z8UznBqRjzwEkZMoh",
    "En4gLqop9h2VmqC15ptXdHVMvngmBme8Uj1ZeoZg2geD",
    "En6W3CD9zxeQ9QeZymMXTZLXHCgjmeeNq9NgZYY9KShv",
    "EnAbzeqRwZrPNE1vofx7CpW2doNjMurq8RdXZHwJziHE",
    "Eo6Pdzd5nAphXZkFFTvYqtjEhMYuBn6BaMEytMwPAq3t",
    "Eo9KmwyeiuVrRRr6hRfpSezqt8JTKJVYzXC2fRuPEYVW",
    "EoBQULvsN8PsUT79xtGxRXimsJNtSg2stxkVLuYUwyHv",
    "EoF5qJmeShgtDTV9HZ38pW6YCUk5yfJFcpTMtcWizhXS",
    "EoMjMtVnAGdZvFBXj9ab8RLmGVsXXz3eQZ2cyRLk9LE4",
    "EoQUphwNQfc5aaMtVVEoKsnbNMMv6fqVHRg25YqnuWTh",
    "EogMr8J5cnHCUTku9ZsZqprtviMKN2ugrUzYRC341QZe",
    "EonmeYmt2UjziwVSTpJ8oqFeHTSW3CN2SbT62FPrm4vB",
    "EowDDA18rFwYSwJB9h72o3ViGoEMGpgsbo9y6sKtaQ4",
    "EpbjkHWiTF687XPJk4QAoSnBMN5k2h9kyBdLDgzF1oUu",
    "EpiTopSoHLNFfFc3gQrRHoKXPMXHvHytk3nyGUB9M8ob",
    "EpvVJ9X1tEqjSprTXqbiSMKizk7PAH9P3viiKo92JjV4",
    "Eq4EteEwSHJmcjqG6WXqM1jpiH5Ld2gmDKYq7ZB4yTNs",
    "EqAEaKXDZVBxNh79HWzQ3uAhe2MZ6QPbHRT8vdQSrMo6",
    "EqCczq2eDCPLT1VczJVLaTpMociUVMMBi7csFGZ3rF7V",
    "EqQWLtYvh35Yd3xBgYTYEwqsEU8Yyp5UQCGPEaRBvoDj",
    "EqUtdCnPRzcFUXaNLdT7XmdmWH3J9e6sSn1uigMNouao",
    "EqZeWYuHBRci1i57mRnM7Qy3M8TaUqCZvHPY3WSyJCQk",
    "EqifEp2QfA9hkeSWn2mQeWFmJ9pKhyUdrNc2trxA5TYJ",
    "EqpnBWchc5nbTXTDaXU1wfAtmDj4YS3RjL13N4uz1Z1t",
    "ErzRxLdB1GhR1gFbBWJ2G1Ym44HbJzESjsXsGkxwokm8",
    "ErzX9m3QK4VpEJkVmiSQkSyCcziEjP1TJgLFp4gg3iHF",
    "Es28NBVcpRo6J1hneuHx2fK3edKjsnGpspRKtCyu6FCq",
    "EsEyGaCPjoZDbsc1GGskXpuheaVawQSezh7FLsNMdq7V",
    "EsiCwaV7t9DJuTsPh6bFdJuaQeMCW3RsmL6sBwQj26PL",
    "EtCmWaoBjcjcVFoc6kwsu9raKBuPS1qtP2FRrkvuH7oY",
    "EtKy6khY631H91Htgz4MZU6gVyMsUGiu5eFp9LfHq8vu",
    "EuFA1EpAoRj4ZvUUBhZWvw4X2n95NsAPjMLkLueyrZnm",
    "Euo3qbXBrokjrQgE7ESNfFxPgzMT4DyFnXiWCZQo8WZ6",
    "EuxqDPtZjMP5goApJfYjBh7eTb7PS5BMHtuN22rLzGD",
    "EvBzFPjuirdDvT33GoCLpsnzMCiSKiG8GLR6uLUaNMRU",
    "EvLdfpo4ymXUkP3ja4Tdk3x6LqGGHReXQya7LxVcq3VA",
    "EvRtaq7QwFnFRDytuCHaL9NvsVVVfXBR3mxytL8csJp9",
    "EviQqtqpo8XCciD2oEiSWmf11juW7HccvTr7HvUSHQWa",
    "EvzDErYcvv1epGEEQQ1QFPgpHg13SH3LWQZj27bexzdT",
    "Ew9rwQ9Wr7A8xYcKLamD9hXjK4oy6dgSC6myhUFeSaKf",
    "EwGjvZ2X5bAAxtyWMR6mRaGYfccKZCkk9qrenMunPvxV",
    "EwQ2jXPY2Zg4XUaN5ssRg4nknaWCCH1KXCqgdubyPyuB",
    "EwXbuxNiNCU8RhKtT8CwJSfFZbmGA5Kp2uJ2Hqobm1vM",
    "Ewd5C3YB9kLQA7GeSe6c2CrbyHGucDpJJtqKv3g8kizP",
    "Eweq5149V8eiFAksRJEBksCpEUuSFsEaqA9aJRF6CxiL",
    "EwySu3HLpwYc3tGY6fvK8WaMedbwF4WxuCQNeBroE3E8",
    "Ex4pHdwU8F3vCKgaFskmdV3WrA2d3Uc3Vvrji4xnhrVM",
    "ExD7DSHyMLbRFbyWXpmyF9YG3G8YvwmJ8iYhim9D1y93",
    "ExQ57RKAYn2vR6rNbrkdeMSrQzUhb76nga4d3CsJAqxw",
    "ExXtkGRKEtWwzbazi13YqMJKdwtzo89x6CQW4jjNtuWK",
    "ExbikZWdyaBcQhTmJe58wPgLedcbH7YULwmV5wBcvuYt",
    "Exjc6wCrhTCvoF5HmnxwqLHZTHkHJdXEgCdUUdBDcmm3",
    "Exqqh6kZjVcPWJ3SF2s2vZPHEx7VAiQTkfrZ4JrmniHB",
    "ExzUzDtSMuFcvEQmjQeHwbifWkNq3vnTvbupCsTRytKS",
    "Ey41KQMATFfdgotkh9gBMUnkdjvFxGDqG7gCVziJPruK",
    "Ey6KrKMPM7pDziuZjMS8ErvjJSzQ2kVuiYRfgeZ7i5dk",
    "Ey7NUrZP4y91FmM3Jg3Vk6pBfCqPbjutHNAPmYD1kV3p",
    "EyD7iNSKqxLscypnnGfT6HQXT4izAak3CAzF141H1aUA",
    "EyGRBq9NKRWP9oA9gqB5c4cCiGQnC3BE48HWkamhwB3F",
    "EyXZBx4J2mRMYat9h729xWJ9MfWQ3yv3xMhM7fFyCM9m",
    "Eyi5wWqa2LCJ8dczhzdqnU3zpgTYJhr1QfUj4jTXyXVs",
    "EyobnPS9ZnZ9tUps97sPqy4hxdYfkQcrP5ZAcMy9syKd",
    "EzEzw5Nn7bV7Sf4fvgjGYKThht6eEgVBPAz7k4weas1a",
    "EzFgxFCzfTBteCwJyFrowhvvHhyRZ84ARwLTRe7YVxH2",
    "EzQHwN73U48KXHeBYvn4UdSrGCUgRKfeVyPfQ1aP5vyF",
    "EzfHLksj4FQDfsy2QwapAraEyyYnDeYXx5c7n5Ykpeod",
    "EzsRdzvdAU383YkLLqA8GjReeBan36wr4uPQSw79GeJs",
    "EzscKPyBhrfCLGkjavdeGVs5we4N5DBjrpALQhPaQepN",
    "EztoEfQAiBSviF4gKtbrNcWfmBrAstJ8yJnur1WojDNQ",
    "EzwhwiRdz7x2eVyY2AP9e7n5uRhcWmdvTuj3d9AocZxp",
    "F182EKPe5hzkFpxSyQp7UnKL2rr6afxHxMYUvdp4BZZ2",
    "F18WKFzYmkB2BcfVoQQeCphv38pjmQY7Sa3Ua1BvAsSU",
    "F1AnwsWoUv9op4mocWtJghjT6WGQrVigZC7QJX9RFHhZ",
    "F1QscND5cbNjJCiKPga4afoZRvwVuCcWH1d7S59ZDwGu",
    "F1TfrQAMH4jJdhUPer3XtVtoCdWVAcG973wZCsm75KZe",
    "F1Y76JDdvHMaohAPgzCEkEA3KtW9HSjfg5XsXUNvTVRy",
    "F1aN4TmKpUtYxgVMxTXDpnY2BFB1V81E3NJ2vrXfF2AK",
    "F1ayXnWADXL7BGapkyibnt3Wi69jyv8ENZ4qWdaNWi2X",
    "F1fG1YBHnxvaxoAaNXhoWXLGiRJmMQBBJDV9z9gnXRxG",
    "F1gXqvUHJGwpgUJhE2C8hXHuyByjXZzRCZSeHofvqxde",
    "F1pjGVNn9CPeDVBkDce9EA2mKZQMK54txAgBrcyKBqKH",
    "F1zZ9MZ8fAMDmu9rcykNHCqXd6iEk3DhXNXnH7be89SC",
    "F21SVaNRXuoeXGSBgXfFgumLBQnzgio3s9YoAQPQzqEj",
    "F2GupwXyrfKLMhm4QmFMSL6hgnUgxHUVJtqTgjAFmuYA",
    "F2KvWRQjuWqnfQCNaKyiF4TNbgx3QfVRhn4erGcqmB4j",
    "F2jJv1sQbJjdTpc7pGxDXLBoZuMLD7nvn9LpLtoHbGKE",
    "F2sD2qrdLkw1vFr2u7jSbLADeQ4fdWxFuJiuZX1jrBch",
    "F2ubiBsyWPUCTXhpUUY2rzYLecnpzzVNdqUH9dpxu1ik",
    "F38GJrHmv59SFP7kwn3Mw9oobZRDqeNBPFj9HjefnLjF",
    "F3TFQeuKDJQuQuQ9umc2jTQM3sPTw2KLznXoFpfXrQNE",
    "F3TZWbcvwh4aaP3g6dFTyWBXGeZXrv1AjZMYYTrNY5Hj",
    "F3iZ2B8o1pBTgr1oxBJGd5aZUcju6Nw21X64dxTmabaF",
    "F41hMgxv2ATuA2NhqLvK8Njz9trX3utYByUPAQRM1zRW",
    "F4Y6BFPdjYiJqRXeFZf4fezUZgdGKiP2yQrUCAvJxgEP",
    "F4gaQeC3sF9C15jZnCbJnxhJcyVceX2owmCdh9UoKkUj",
    "F52DMMR66hViZkAFzHPqbvCXUxdrpZC3vyCygGkD4Nyn",
    "F56eWqzBhjqpGbjMmaqp8JdMi9DtuS7Kn9mqrJzN6UR4",
    "F596Z58nnivHyr6Nwoymuo5wKY6wxy7BuLZG4L6h7Eyb",
    "F5AAR18JV7aYYKw9BL7yAWxtGTZwDQLR446u71dSwX34",
    "F5R18ntmYKrHMtLJRBHbuHx2f8ipft5eAAXpqofas24f",
    "F5X6U6cvxRmTiUvNrBpnwc1aU1URzb54mnR7QmJW9XLn",
    "F5f5yovkrtgSF9D65mGEuZ8QVHA67Z9FJVE5Vs5hmVxu",
    "F5je3KnwYLL8h1M9nWX8eEJLQbpnCkh7hm8neEW3ebAn",
    "F5zVgVgjzHaU898dyboNwMrL1GZqWy521KbCufaaZZT6",
    "F6UbKPmdJaL42estxi9gTc3xMoNQZXbv4ykyRz7E8BnF",
    "F6YD5tANYjdNPGBYHdn7r7KXmPmxgATebJNJ7wMFZXYM",
    "F6dyBdk2suUDSTsvCShUBrZgNE4ptrm9YL6whsbextst",
    "F6n1fzLwPTihfpu97qRPGNqdn2x3atG4WScMwZAoY2S7",
    "F73YAYovMQP5T2H1Z3HchoG6YpMbrFK9RZYD1pjJKYUS",
    "F78nSvxTJw1kHbenA4yAokp6HyqHVbPDfCMeGzohBFMb",
    "F7WbpJAB7jgXBmkjkmJ6atHNiNM4xdaLe2pDhJVZp8bb",
    "F7g8FdcG6q3YNTLra5RYeY5WfmVyDdNZHiKYKiiPje3b",
    "F7jKn5BnZwJZeBxbMj6HAXmNDzKKAxtjVMuMxrrYtoAh",
    "F7m4a35xnkrKe8YXdwLPVav3CtWZxcvCjCgco5gikL7G",
    "F7ro5MuTiQvSYomaCZ5oJV8njRUX35goW9VE9ewNKJck",
    "F88aP92VmcMwdG9WenZ6PNgWymEj53RLde7dXfYa22ek",
    "F8QmHfqNrVDdBezXUMgqVJDG4k3GVYd6dXqZ7mFcMbhc",
    "F8Z4ARVygYyFTnWWrTco3QUMwBZY9zgn5WreGw1p5QeX",
    "F8mD5yyGvhjCMgU7BHkLMejHDGrMc5dhz2NajbGwyTYZ",
    "F8nJ7TeXQxrTc62EfTYLCPBcMMetZPUbnSEWPcTz8N1z",
    "F914Nw8jtRc6ux7eZmnwmMYYkXEAzGEqJs4Y2C5ocTtK",
    "F91cvqbLsjs6w8LqMWwKwCt7EH7t1CMdD48FPmYtZG9k",
    "F98xqje8vgd7d21wM21diB3gsApc73SffJTJcgk3mFAW",
    "F9AvgUy6DriEpbcjkWFfRmc9odgJBecvu5hzTbP6xRcS",
    "F9TmLCuUo8MCbZ4QsEWGku9YiqUqj7JQK4RQQEK7WAC3",
    "F9sAJPwdEw2rxpCufixZi239mfHXCCGfAQjCdAF3Ndya",
    "F9yY81buzwzAQpgsUCKowUAf8XYe6X4MRMhLCBtuK2GQ",
    "FA2roxDDs93HkNvLB3Peq3u9H3tqEqe1MMDB4DMNZjS7",
    "FA4BK5fEXWwKuRqQzPXGTpanjgDQr3HahUGKEvnnBpkU",
    "FAAkboKLAu8CZNHnBUuSQ8M5Rm73eWSr8Cag5iB8aJ2e",
    "FADh3nqfdK22JGAZ9HwxVfqEhAnsbBYo8i1dv1sJG4SG",
    "FAEEzBYmDP6a8j27ukYXLqs2Vb4GH9VmyrzpxjFQKENo",
    "FAH6hhSc5g6i2uDAPKGErhx3kQaKE986AH67rJ8c9KGq",
    "FAKfS11WPgDD2SDkocEHaBN7JbBE1DPavsWe17wcYXPq",
    "FAPfzfGgMGy5v7DoGUFP9Nx35DgHMJaj5ZoPXCKqZeq8",
    "FARm1ffKbevkKEQYYmg5T54qwkuHwj9UBgD1STELVMeF",
    "FAYVnFHqpztoGcjsx9sJneYhGq3RoanrfPZBTo1HXFTu",
    "FAjUbKipEiEyVvi3XveZe6aEBbzu88ZNx3UwgHHrUqMx",
    "FAnZZs1LJDY3Sgr8XqGoVpWchLzFGcwMSbXmoULjHqe5",
    "FAuEEhgD4r125fM1EVzREKdxeQwwGmG7CyLBcU2wEEGT",
    "FAwp9PmHg1yab1vi91V2upBjUUGhutnoqy8hYNCDMk8u",
    "FAyaBtnjRzHWZyPmi7XWcv9KtTePCyc4SyJBKckZeyDP",
    "FB4wx4BrGq7VCfurrEALSAD3FtB2rWP1bTCMhzsUdnK",
    "FB6rTAKBZupJ9YrYjGqmxqGx6WWirM6izvWVcVaQZAV4",
    "FBGpqyQfHEPYjmoE3ikKu2mJA65VmwPYxsTrHULneMJs",
    "FBJGjRKtmtwXRWtFQ2KkYJReGMMQHrpk2BeBeBM6Rj1d",
    "FBQgfKBrpdfeVmXyB2yerqAUFpvH8jA3DmhzW8tYDidF",
    "FBQy1ifc4JvFqs1Lm8mvunGR8uLAjWkgfciBR5oU3Y22",
    "FBTX6aR8QpXYqtks19jh9ict5LQfvJz1cBzSiniBJKai",
    "FC4PM4RhLgWDGfNsUQNm6jdm4J1ucDPDx3LHa2wWUUse",
    "FCKdrKgB8pdGzntpmoqxkLDvZkSEXJJjyzx3J9MyQDrx",
    "FCQVKKFsFZ18DUxdNRD3WBdxa3dPW71b4AJmcho7HCR2",
    "FCYJdR5CYmHe88u38F69waFmhQAEQPUmSn7yVZWzr6nm",
    "FChopSBdSFgvUN6K3TZWEeFZsnEx6LQmsUXbLaFLsjKd",
    "FD53WD1Gf2neZ36oWUh69376SPLycQmfgvstArBqVTmc",
    "FDAmGivMap5oopVtvkAGYBz4MvgGWyTjtJq7REettnQB",
    "FDB52PS8vvqsJp3PyAMbUU1uFs9FZAzrRkAmHyeMcczs",
    "FDUFbgXjoHBiSrtnxaTa2KiMw4u1d37HEnVQ5p3TGMfJ",
    "FDVSSVNHGuihSvbK7VZ6bzheNsm8hVxpANTbH4sUEmHY",
    "FDYs1z6gfJmEu8kn8pT3F27j5c19JRaeFi7Czc62JTF6",
    "FE2zFb2UjHUQrN5wJGRHKhFsrXfpb89gBefSqVG5x27p",
    "FE6kbNpffoaV8KNdLqKJPB6TGc3HMLQEu4w3CRCiymm8",
    "FE6ws9M15ywFkUsVqVUvt6dAhGQsEZvT3AWecJKtYe3K",
    "FECxqfEjLNcpFthb3CEJ5ASeKW5knMVg8v5iSpuzp87J",
    "FELfNCFbpnZEJkWgaBDGMEhWJju8EqXh2q15GMLSrSr4",
    "FERpFZxCRRcHGAVSbzsEATMkemnxtW6rPJRysgbs5N3g",
    "FESFP9tbavyYH4NyFqJLWUS8euKYm1rqJiftwcBkrjAV",
    "FEeNCYVcYU9Dfa1HNrxqCgy8JX4RszWPiwEaKB9Csfs9",
    "FFBLHuE6w1qtCR47sGCcxHPbJoeyxzRNigRnUF1XNEiG",
    "FFE5RvAeFbtVJkYWkvRPD8iLm35WY43TF7bDn6RBxrM2",
    "FFHuPVgGi4r3gr59cRHcSwBuKAciZGEEVFp3X4JYfmsc",
    "FFKhB2C4XG5f47ADKAufZyN91g6foshSGC8wUWHnjmLn",
    "FFVQm3gNZXphPguNBxt5Pz4kt5VTGN2vuGeAjDyPgLgm",
    "FFWBFx9ztGKKMsok6YuJo3yZUWKs4CjwZQ4W9i48pDGb",
    "FFaMi41xv3GnBtwJxZCmogNWaGZpe4zopqmz6sZh9PMk",
    "FFhtkctQRFs3VbUemvERUdq267DnQ3Zq2mkH1CuuTg8s",
    "FFko3GwSMCYGdAAskzk9Rpmb8ruAF4m7beytxDihhDCe",
    "FFoQwuFGSPRzf234UwFk2GkSQQScrmtAVZUvCWB2aoeM",
    "FFyhkGeKCbprAehXgXZ7cjbxkQYFhmVvYuNkXof9jvqo",
    "FG33HrfnkDTffa4X3jkSDGMtDCAxJ7U2LRMrCF5tJG1t",
    "FGBMCNDrTKykXgTHxDz8ukQC6EEywhAVgT7xvvKafD7V",
    "FGGVDRh35UxprRnGYrRX82EhJJexnwFPYMncM3SRSqur",
    "FGPeKxoCi8fBS3qM4BvnfphJBCZYV9fjefJV5AVVvzhT",
    "FGZTBCKUYNaopzGWLBYnTqBL8EnFUH1VdSGdzsXvjboG",
    "FGZbCpybiBoVt83LUWnobBQQASWihDhNM3fKPbFXHERU",
    "FGpZCzsSJhATET1eGgK9BKSSeDDVopTwPu325QbpFNjA",
    "FGphinZ4z2WwhCJ5KCt9uT5AJt5DxmRutSn1BBiUYzSy",
    "FH52e9CDFUKLs8UGtcyQ6pmnfjDZ6bn5nEaP83zhmYGp",
    "FH6UVymcCiEK3BYM2Ek6QD3e2rrM14xK4wHD1Up7DwFq",
    "FHAhma8envewczWeKjpzsstW8WG2QmmtagirhaKaw7sD",
    "FHHNsotgh3wMfrvUpkSpoGnR1LHQqYDKJ5RziV79EyTS",
    "FHa5KEzZwAvJxqAHxBWmB2bivPCjMnFuEyi7zyrkFayR",
    "FHxcQ64asVbyrEmcMiupcT7UF2dy7rpbzXKVB1b3dk2k",
    "FHz5JmPNuK88bMD3u5VkxmQxQUYHDXQPh3QMiTe8ccX1",
    "FJ8D9z2LMs8cQHiMC2bts81rCUEQumB6hKwf9Z2BuQi2",
    "FJPTv8eDpqFQPVkUG77GzGZQftBvihsZ5inbRYkyDFFj",
    "FJPcLrHhdjuWasgtXiXEKYKAECzvqgtrzXVKRH3Bn1L",
    "FJSc1AEbfG5z1zYEj5ZoGafxR5QP4BLD22tzYWZpkz8X",
    "FJV4tBA94FgXVLcJDATc3R8LMpQwMGYGNXBzCgAbSz5W",
    "FJm9pcYRRhzNRac5CYRcQhmaZSbJJV5tjyS31M6ASnPJ",
    "FJqk8AAW8xopwEDUzeyWti73VctGfSENgqeWk46DzuFo",
    "FJy8hF2gnWH91kxExx6akafV4afaHpBQQHpgvK7Mgs4v",
    "FJyH1cXUCTV6EhheEyeuqAALhyeFWvvvKocQeW3J2FS4",
    "FKFCVaQqffZ9CSvYprY4oGJ8FC51eLqrV3yjFPcvnx8U",
    "FKHzbuyE7HJUyQFbk4UeLBCiXjpAtqUit8AtcbyAsFAV",
    "FKcHd1MgYvBgtMhFs53xVVHfdgPRAVrDGxZHWdHv7U5v",
    "FKg8WLx5d84go6qj74ZUeWszxM4oEwUMpsn9Yss42xbW",
    "FKxnDPdKFrjVQLmQ75E1HxrPFoMN4gCGoXKFabEL3p97",
    "FL6FyjB64PLwCNSqC3DSKYGyWdHDsD6vVFZNE9gwTabL",
    "FLRCRD3W9hTnQYnvpzn2dXZaZ2fzNVEED3jFCVf4kMUe",
    "FLY5anmvK8U4nhbXXwS5mM25x7wPRFY4SNZrecPsb3eu",
    "FLZwCJUecVxrEMpsHvQMT5eYDqWuqwQMq2r33LJpbt8P",
    "FLj33VHxanydGJ2eY3scQKEvUq3q71x6g3VJpUL2SrWT",
    "FLuHhXWardij7rN9DbF6bAxuiKvVPmBGBZXptbtGM69r",
    "FMfPR16bNFsKTp1cGq8gRtGdBFt516ZVWW4xDrrLgcs1",
    "FMjotrkaf9h5XonZ4Eg7sdkDZDqLDr9bHaoTMCzj56yC",
    "FMjsuNQw1yZ3oySMojjy9mXB5RD5jiLePsVipFbnTDX",
    "FMrWqQg2J9c1AcCMqwUptsTrwFuq1ds8CDx2QVMLscQd",
    "FMwdAgsGZZVGJNoPu8LbNDuBn1nxAS1nFbUM5cDpxq1i",
    "FNBCeZHoqh4c9Dck3Hggv1KpsqdijxkQ5efyvK3JAtmX",
    "FNBRq21YpEuJn5BrMysDdjSxg3c6AQXAhN6bjTssFBN7",
    "FNCBJyv5SwA6Vtew3AQxbKKNzZVppuD1QBGH1oSt65Ce",
    "FNvfTzxfDwgis6MnLtmDYswumvuWwVW6DxtRPUuJpGfX",
    "FP9huwG9qQJPL7EqQa31g8UTT2yiGUGCnFpnQJ1HdsEa",
    "FPDPWBVGW17ZEtFupSPri8VBbGabZebZQ27PMGHSyjL3",
    "FPEZMkfbPJk8nXYWMEVVNtFzmDAU15ee7nEUL5QAxPp1",
    "FPLsGNfKtYhAs97GfRsy6oJhQ2FfJXhUK4fNA8fNLjHP",
    "FPXHotZbKMFuN1btbMq79jE775EuCcg6L4WLHiv5zjUc",
    "FPe1jg8Cur4ejKUEvkRTxMDWeTouTPSy8PM9oAhYbEXe",
    "FPmigGrjXgG59Kw2Z8HcjXYruLktrUwdje5wprjdbH4C",
    "FQ1rA7TC2Z8TkU9aT89y4yc5gKbrLTE9eHWNv2gT5g4",
    "FQHsd7fpixxSUjqhPjnmT1Wc2saYmB5HXYg1EQtwb1nv",
    "FQR5vy7DFRHDHd5eZ6StvnrkypEeRMDeDQD3YfrgAZCd",
    "FQeB4tJGML8Bv5x1bTenjYZ7NsQpFjWS4UAfXoX41iGn",
    "FQqWFLm4Z8BSDpyebW2An4YDwTc11SybYajkpZyak8fd",
    "FQyAZYYpMycfPtgcXWVvWzKt93xo6WoYMhqsSEWMCp3b",
    "FR4EJRfUWA2dSYmPWBuStKz813ZwnuaGAhNSVRTq4JJy",
    "FRNBmeefCV6VeDLehFWpsVaBRogWV7JSgKGL5aUvD2nK",
    "FRQHp2BCoAwNGQQ2on84BiCY5bqDH4Fu9P9kDQgQPyKY",
    "FRVXgBLQ3vHGZYUqhDPxCuESSQUWexuxE9ojTRnrhGjL",
    "FRZ7EmcR431KEqfpmRAu7XVi1Zxt1hesEN5SXW4dbr6C",
    "FRbyg3meZkDh6vvA3sDMfSbfy8LnTVDuUurmhTd4S1nu",
    "FRdSkxfxyA25HFHGyezoK5xgsQpUtXqYRmpV1aD7dDHL",
    "FRdwQhxAGnvosJAzk489sKwpPAthFV5gmLzv3qg1fyce",
    "FRhoGzarbp6WnKxcXRJ25LMdadJx8z1BGYPmAAFCegpe",
    "FRk1ugGpYQgbv8DMwC3Wrty21QkitHXLg25iWVUFdU5i",
    "FRkB3Ac35MKry2CGDXCZC5gzAipgJgPEqr4McGCc4Wa8",
    "FSDPf6PCcHReZ8XEGXfmRUE4MaHdVAQd7W993Bokhjss",
    "FSM4Ftyf6j6wJRqZZmGGDz8d7t8nvobm2r42CNspP3TS",
    "FSr9v9EygQRAipKqyaQ6RHEeAiTzeDf7JV3FLujEsNTV",
    "FTSXRc2wjJXK2Y7zZ26Zgzdz7FGwHoyen6KoZv2KmGpN",
    "FTigdtdxxWRy9o9hViTyeLeL7WGRbXKjRkd8gVMRNmGc",
    "FTmR6G8DcwdT4KVBGSv5KbPiDwRGAs8J3QwuxDDMvqQ1",
    "FTpvNQSMixhos4nQXWNqBnG65x392eE6Ny441tJqE8Yv",
    "FTzNxoPe6KarS6FpovkXqU54hPLghPV4qnjAGBqMkTYW",
    "FTznLw66iw8f3fRuwpL9eZRAGNzqdvbY7PtP8S93d2q5",
    "FU21vfxJeujEFHoFGHn55HY6o4W1aLMmoycY26sP3zzL",
    "FUMKNF6GVTKC3gcwN8Tr4KgkPSH4Sm4ew8ckLJiZXKeP",
    "FUS4Gf7thYt9reF8yCV1wbfe39mceYAeYm38WU1FVan1",
    "FUbXMe1V85gyQtMomKFyUwaibyCuYRcjfVFD1Uyw7s45",
    "FUmE9YRpj1Vn1x8gqUX21K3ncpuFuv7rfh7Z5LwoDVye",
    "FUp6jdp9HgArEsTF5yuAL2dAbsvBCrSDygJjsSAoYDC8",
    "FUq1amJ3ZrXJVpVuGgZswMMWwuWpf9tkSJKHDC13UvdX",
    "FUqh9xaFUxbtn775nrnoT6FeeW5vQwAGT35p6xCrtfMK",
    "FUtYCf1VDCYCjPWAX3iNvF5FgdK1VHwExGLkRTWfPqAn",
    "FUu3ACdBxgo7A5uPaj65WmrUuavckYTvcruKDudMBroZ",
    "FVWAUR4PKHM9EVkvZ6Nnm6yErYQDtnbCrspHMG1TtzSR",
    "FVXymsNAidBs52yp35Y4WDfpSnbaZuPSGadBizXMQCkp",
    "FVaox8Z59G8WitTSGHcqBTA2shyh2sm9LLvxsfmK5k6S",
    "FVsdQAfrJ5B1PRGxu9oRwmJkYjwjGFuLKBJXh4YLxuN8",
    "FVvERZrUWACDd7YiLjn6xb435ZT76SYRe8hSsHuez7fy",
    "FWAGiCUwdECh6YEFgnTQepY7TfaqBbeTqk5G7mLhNqvX",
    "FWLUPS9pAjJAfAcJ7qfvRmK6bmCsUGpM1AtXZysN3mgg",
    "FWUfDkKuqNfo9pSkCZgEecj65ChxKSPh5EkunpV7H2vG",
    "FWc9d9t7cRTTWo8tVW9wJpL9VeyjWz1Cr7MbiENue5s4",
    "FWcLySNkt28RJueouLqBmaS95ReSPf1nC5AP5SAUN436",
    "FWhemQ65kcuDyJ1KWFTyZwDGudgS1p7LXRcgyGDfR9Vj",
    "FWrw6KUJnFBUpm5Hv2m227f3C9ZkFxfMpwWppF8FiECZ",
    "FWskmgrxKbrEEXEkeeQDZMEr6EqkM79GM4w9unoud9hH",
    "FWtNDs2Y5fXTFKzePcvCAx2SUK5Vmbc6HeY2mHKBJwh9",
    "FWxb8jCrjKzeMVHR1F6ztMtUyUQGooQkUTaugkWqhweb",
    "FWzrngH1R75h7PoUXjVQwLbcWw8QhefDULWAmm8kNfYS",
    "FX32Ld65gtAaeo8p27JbTP5cqM38Tn2G7f8qKcoeyt78",
    "FX3a2icZWd7QZHBNu3JwSMNyRpM56Jpf89CVfdkQb4Yw",
    "FXGWqYi7iBL1MCnoTA9N46ZeyKep9Gyx4oHXhYijXC9T",
    "FXQQWGxxpzx1eQB36Fsov1A8AuNBQHVxrpUBw681fcHq",
    "FXmVT75k7GWS7RnznNQjazMqUBmUWutkHM9mvWpkwWm5",
    "FXz1y8SkHJ87bnrEUkXPSRiDSRqy5hAwfH2hp4h1KTpN",
    "FYT9h52BxURSYs8uGZS88QAdSh797BT187GsGX9ktEgi",
    "FZ4vHdqR3e4HZPo276zGnp2mEdczXBZpBY7hEJjresTJ",
    "Fa1UEVpGTa6k2vbMa4ecrioBe3AQ54Sgztod1CBZZMz5",
    "Fa1pyYe6QzvLfbCcKqkzj2CnPqzDbYnCeaYydArjt2bA",
    "Fa4CHcySRHsbtkJjWRe6taPAaFK1zQZi6RGkfe98gUvT",
    "Fa5QiXw73TLobK2ypdSmP2M4hE2zuB7x4JfoY7KaeRQd",
    "FaKJopHLFEefbQhvzUJBaeyodbAg246g5b5xChN4kFdo",
    "FaX7MNPwwLuvN4Tk6dp7dPHYV1ebEAo6AdJf4HPHVhgY",
    "FaXNCfxyAjZq9Cf7sRQDNxUaprj49h1rtuHPCjSq9gNN",
    "FaYzXieoYwxPp55pnLmWstjrtTtzDqvMizkuiUsKZNQD",
    "FamSKKszfp5Qb2igLEv6QSVYyHFDLoARPn6NzY6qzDvx",
    "FarDwJ5D4onSnGMZh7rjLxnW9qVGCedFgzbZbqz67r6x",
    "FatAgCtec1zL3B2eVVgJw28WBkmf1bChEr16W2Xto3fK",
    "FatbycKBhdKyPKEy3gjx2mSojaboFsyYa6ZTz62NuFKX",
    "Fb2EFsdYo1bCRMGBAvj7CquuHkwpZk5KCfpQf8BYM4so",
    "FbM9EekzTxbibR3vBFKbaHA3j1g5Gbe6jCJvaswpbjQK",
    "FbXA1UDQfK6XeNdTo6MMq31E1WScwtNzTLyQT6XWvq1U",
    "FbZ6wfDotejEYPR3rwAc9CVWe6NY8AdAs8kfhkSo9Cc7",
    "FbjrcKcEVPXJsNFJuNvmT9o1TxVaiK4rHe7aJnyi1nF6",
    "FbrJ4CUB5JE2YaeKdTPwAWfYwhymEsPvgAcW7ajpgkMM",
    "Fbvryoq2jFAGJx3kVoRQqBnFCaDKx8TwPEpugY1nHHUn",
    "FbyTqJLiqnSF1J3jwMvrEXNjHCzdzyQDpUdtqXMvxsBA",
    "FcEYCJPnhs4LQDcn62tRnFPkZuMx23aFMRSH8UxwXR1T",
    "Fcb3FWxLtSUYvyZ2sVGvoqzJJJCsNGTxe3Ytj6pz6N4W",
    "FcbXGeXGy9maCDd25raySeKEBzYJ8EyBbYWwnMvrWJme",
    "Fcq8xPeUgogz7CsVdkmbXiVeVFF5Y1oyEyEdvi58tXZ6",
    "FcspbZkKyJTZ5zp8ALcYxkeBrqxGCMyy2Z7NQtzd1buH",
    "Fd7rgPpUY9GMZY1L2R9CNgj7pgTsqMtRwCjVN8TPVyA8",
    "FdE4Sei9L7W4hjuZAzFSCTKXRswawU93X5AMT6vQi1qx",
    "FdVfvhNM3XBTaEfsvQ59PyCcRmJD6LueTGWLdhy9L8UH",
    "FdaH4hgFn48v1fpyco93raAy4qMCBTp3WNmRNB4gBacN",
    "Fdam7Vg96NVhf38BBkcAZvW3ivA1M3Ab84F2nobcfwzZ",
    "FdvXYy1RbF8KZD5B6qBXHBeWTzVVTgcw2yFUMY5dPiPp",
    "FdxviBEDLue3nRvfkSTKTadBoRAif5UsjCNsuP6eDe8S",
    "FdyympdKj74E5waTDAqkuRAbt5Jg82Lnh6qcKFV2Qjea",
    "Fe41BkpWzBZ6J5rgy7fDmRrTNMZscFq1CQZcU9tdTcQg",
    "Fe56inmVCLptjTcguthM1NgqWddxodz7s7qNthGkRjEi",
    "FeK5juk525xT73ukB5VRpsU73HkXYcaJERxoxueEGXHs",
    "FfD5fdAwzLuz4NP1LwjwYEHBVqTmkRAE291v5utzaWLT",
    "FfLA87G1yUaZNgANJHhoHKikz3DyUE8v3yRsntPJ4G2R",
    "FfTCSJDn595vjkiD3mixeRsP7VY6Vhq2rqR7GmTx5gYX",
    "FffSwjK7chDMQMMbs5jWchpKdwEmNqx6P9e6uvqZNo51",
    "FfnErj5xoV9rqbb5dib82XBFRebUT4cj5ifwcSFg4JF7",
    "FgBcqdgprqvdzizPiAYvathUnNbd1nDsu8Q4ieWRT15C",
    "FgDH8TqSj2KQ8HkiWVELdekUgtEYqW3PtnMggYd83xu2",
    "FgSWdmoTDgYPcRxmXGirvhdfEimHxnYitBAuzeQcH9yz",
    "Fgj8zjJRY5Ehn3HNk6C1y8H4WG6Yac9wN9UBHArSBiJz",
    "Fgm3njQWNRVrdT9tJuUPAGLso3TupEY2Mf78cxn1UB5n",
    "Fh3TqH5ogE1b8x3cQ6iPnmmEpoPopdp84F4obqPdRdN3",
    "Fh8KLsCKfbrM1W6YNAsx1uRs2ckUrbGboZzSYPzLZj8f",
    "FhJFyv1i92ikMbR3KHkYAfDG9wMtKcxmdEEUKb4VQTEZ",
    "FhU1JwsSXVgcQjTWqAQ3VfDpEuHN17aDhyrcuLu3EHRf",
    "FhZhNB68CkG3JWHAPNTCJFGWxrZYYQcS5GvLKVKy5P9N",
    "FhdCg5SiD1p9GAQKbbWSiZFhoAYgnUJwPrhrQMEjJpc4",
    "Fhv6xuBnC4HjQ54hC2ihUDoBBrW1cZ83K6t4wNX1dV2B",
    "Fi4PxsrNU6xfw3iHrRxWnXt6zK2a9TRkxXZ84HF4ct6R",
    "Fi7JkV5sexvM9Vscgouah5QhF9PaVRTQUhTppWoyLCJf",
    "FiDrHBQLmWpBL3osuKzDugoBi2t3bsPLwPRa4Mn9fnR8",
    "FiK2wCUe3TTw6JTjpgjmU8dMMpEPrRRL6NHuxc7zCGmq",
    "Fit1LgAyqP8e6MmvbuaAEcCa6weHD5g6nzYnAEYYi1Ts",
    "Fj8T6Y9zro1Cbk11P7eNc5Fr76ANk4FvJbJYryft4P8o",
    "FjDSm3mD1iRy5V5furaq3vPzx7WY6DtX5mV767UU96XT",
    "Fk5KjcUSnZD5z4doexswrAh8GBkWM4f5qQoYkNxD7Jwx",
    "FkAXjdAd8MxQUicRJJYoE8UrmhTvQ7y7DPgoHnGudQp",
    "FkD6L9MhPxtdjqDS3MmiS8WUujYssGhup1NoHfGrpkBs",
    "FkGUCQLphpw5yYx5sdENpJfADuvT3jBjrAHAU5S921vH",
    "FkJC56cYYo47ZTWDBfSHLqHSiUkXavS1e2ix1LfFK8Dp",
    "FkJPSH29ALMVG182HvivoZ75n68P2iaQePRMJPLYTGZQ",
    "FkLcwxnX3Lh2ct7c1hFYQxU6azGoZgVDyVqgfVdnLYrM",
    "FkYQZEukY8gZ8DCNL1yfiHxLerUFAB3YD8DbfRbegWnf",
    "FkaSQJeL3Feq8GJBZUMhSXpwr1S8W4kzXqaeNEQ2JMXi",
    "FkdhrMSjbAAjvmfABRCdXC5Z3i9xwymvyfoxiRpj5d5k",
    "FkgJS52nzYyH1BqSbowBBKXmHUAZAtRX8GfcZJBVr6cU",
    "FkggPT26Ey9NBUJZ7bv5aQbwMs1GMDhL6WzxHmZj9WdH",
    "FkmSrMZ9iyT9itw8q277p5HME6U5TBtHYrX9xJ2v7ooR",
    "Fkp9E9BRRSiG3k5iDmNiw4cVsGLepy1C4efgA4hw259L",
    "FktM83iNkvcSWaPgF4hvXATqGD7KdprL6JyUnMRTJkEx",
    "FkyKSAWZPyrwkpU5W25er43GfC93C1dMHnywrb1uW7kc",
    "FmDAjkvpzypJ4BfqQXmPEADMvvtQysStyNuBZjo3jAmW",
    "FmRQ1mUVyseNijYXL9phkq1EgvHBWKamJZjSbb6cWA5f",
    "Fmt2eoXXgth7L9uFDwGGNkyohkNg3zowBFrY2kL2JYMA",
    "Fn93fJC3P6NUcw2EPSpvZYXo9AfmEhZ22UX7qvkw5Jrp",
    "FnMrt8aNjmQqBSaUWvpMcxPnWhRYATdUuiWaeCi2ME8f",
    "FnT5qu3BQPfpX5CUymgV3tVCUWiuSmsv4gkJi5gHHqpL",
    "FninAdrZPLZeAd8UjZh3XDbE6RPBojJ19dy4BewiBxLX",
    "FnzEm1GF3qw9bJtD4uT7LGMBAYmWhq25mWCry3yVX8wZ",
    "Fo8Vw3BgRGQk8VYiz9UpTzAsoEUF8H8AUHWW8CrH6mMX",
    "FoZZK3RsyovbW927jfU9Th9TPKCyfPEo4YeSWGgSyjPt",
    "FofPAecD5FPMq7cDsUdx9vnTmUvqiUKPsVcvQBszqVmp",
    "FogspXGxQBUc8rfJsqCmsvXHMuVw4tZmk3eF4wh1BCEm",
    "FpKmDpcigdqRVETGaHFNQeVNYdBsiB86TLkKTFHPVRM9",
    "Fpa9pM5p6CNoAxPgxHnM14DBgQHmvNxJzUTNTZnGLNhw",
    "FpdNFZm4tyybdMDF4Y7NT3VDF7FpLScFLyNnEPomMt8f",
    "FpdvWfhCTqGySyxeUymXPv4pCup8Mgk9uVz2HwLc4AJP",
    "FpdvhvG7M3kKfHYnqLQztQUgQQtCE8tXjXAAJZW4TW31",
    "FpjMFUtrb7VCrZvn1iDQrWA2ct4Azne5jcnmUPpoww4Y",
    "FptkJNBP6ffhSbHfD8CqFzh8JU8xkUmR6AM7R87T8fL4",
    "FpuqvFaa5UnC6oDyDx3UZoD8E7sphLX6URT6GCy4sBts",
    "Fqe6i9WzWPQq4GAE4Hei91emMPAbZG6LvGExFx1YbjVe",
    "FqwqWKMdV1Pfhve8YPk6owX7QCTtwMJqKMmDckTmeFZz",
    "FrEoSqRW4zV4cTrfAaDijZPoXJKDXYBZzNrJtgHozntx",
    "FrN853JXAwKtR2nFbbp73VtLTz4NPoL9UGhkJ415FKm2",
    "FrThDD3A6iNhz4MfixTzEEdvBUDaGDbr8o2txng2uss",
    "FrYKqM7TfRQL7QFYnKLLtvFrChEeEeuSRCiSSWjAkFkx",
    "FriawHoDbmCun9FSXNa86rnkNweBrHDLtq4K4fky6Gzt",
    "Fs9uP2RY5ToBh4hYp4iRu47CGVmQASGbHdogc7GJqTK6",
    "FsADk712M1Dm2BsstALrbYC8LWfxDe1Dkzcwu5Tmi4p",
    "FsKCzFEn2Zb6bCdv4KivTJaud3yBXYgCroqTXjSCwT5w",
    "FsiwyZBp3WUmmYCBKXYbbjJ9N7MEyXmvYVswYBYznqmq",
    "FsszbGtQKtiy4wqoJrLHkkmouPRNikmEscvkVHBCRmHC",
    "FstiBp72b2dZed2NYQsDcV4Xz6b3LsD2pwEcLkPJNLa9",
    "Ftsmg9Xv7BBu8GnjKi3zahgrGyChPsoc1xTHMAxPyqYJ",
    "FtwCAuQKjoWMiZz1gcWoTgmcvVRKAE74ni2afvd1nWGf",
    "Fu28yUC5buS1RW1QNvBKRzN7sp4UJZkdDcu3cqqfNDvg",
    "FuGwPCQRicmc7K9GsWn84A74UpSpKAWnK4zgZ2S4SgMX",
    "FuWtPXYJDtAHvDD84kwFdhQukokze87PfFv2oQJHYQhQ",
    "FuXcvXygYWDyeEujrhBsxFGc1cXsUy5NqJCtNLkBvMR9",
    "FubXXkmc4bUSCtJhso66a9H654ZCkXjYgTGWrJUTRJHQ",
    "Fv2rTun8moaRn2CVQt8aBKt7M6bb3uTM5qgKmQzY2Cfo",
    "FvBuUz3QxPEJwMzmFih14MGwZtBDvViH1PwqB5GeEFxh",
    "FvMxS11ZzBkrB3iZJoVKSBTChjmpDpQyZ7xTbMgfg5pf",
    "FvUHAZ6e97nKDbjtNez4x9h3bJujB5mC2itvw9B7vNoa",
    "FvWv9tumawLeWxv76WMpY9tZnw538Qi3AyhDgNbYjZM9",
    "FvXGn6QVJYyBxgZZRRuw9rhcueDjp12NnUGuyPqXT5Qu",
    "FvrKCXeMpoKS8rJTfGuTZHLtpnsfjCHMdmkKUgbUkBH7",
    "Fw84uStEd1Eqc5vGqVPSd7eHFW2YEKJ7mhTgJ9YZD3Wp",
    "FwCxpq6UsBhh7qPU86BeC1yYRe6GKaHvBu9ZwPnN4RGc",
    "FwJNSMmXY2PCsMkgcMMTMKfQPyHPhVjWM5GKJDSD511R",
    "FwZDpL3tJysUvkx1wLJTSLmLUJKngJZMJg7KT3sMoA9c",
    "FwezB7mnhRyBAP3JDKSKUwfpCwQAtq16tPYGxpGZSn85",
    "Fwjw9GGGWw9P7oHYyx6jsowwi7JUGKSSDV99wCGja267",
    "FwnmytyJnusSjopk2m7FNDpm45npqR42pphRNiFLtKyg",
    "Fwp8AaGaQfBudCwNQZdQuNELgxz1xxXV3Siyi6qNU1v1",
    "FwvqauCg1c5PGGD3QVLkGBKGMtsyVExizTkJad1RNMfg",
    "Fwyu59kNu77qJ8Sxe434ScMGcuAtyKNVdxaVMd75yZsN",
    "FxMiqPLqPNrDAZD9AK7ycLgFY8emwGy3ky1iqa6L4Aav",
    "FxZSoA1qHApxk9GqdCCHytx5HDuemGJdDeFwxwHXxHSx",
    "FxcxdBP1UU5Kw43L76sM6v85egfKDqkKW5oHrA4DECko",
    "FxefMiyP8JooYiLgbkztTVEHSBvePsD17bqYdKNLhEkY",
    "Fxk21tQE7grxMjiHAcC9LzNZvXTeWAE86DERd5fS5gUg",
    "FxkDQaqmCU4AjdfAUNmN5Y9xbE4PcXvpqDz1rb4f2zJV",
    "FxoLKM69kx3jgPHk1U5XzV1GgoTidxe39mLn6KJRpTus",
    "FxsDyDBkRLpujMweGB9v9EzQGQTrLcnXZN1V2fwwJHSF",
    "FxzkuwcN4HeMU2CARnfEEiyWtDqpvE7eGSwRPeSZ83C3",
    "FyW2Biu4uwPJ6yxPwXEydSdxWsvtr4emQLPyNZaFDAVR",
    "Fyo3yUxwqBSfgsw7WbTNy8A7xeak2uziaWLWM5kT1nt6",
    "FzTKLmYGU47vZsVnTL2MRnpx5QA6jz54aJ9VyWeZoRNv",
    "G13VNN81Pc6H84NFpfpfreSCTMupcMUj4NSa7by6NxxZ",
    "G1Gc78R1MAW5eiM6KXQ4ZQH64SGh6vw3v3hGJiVYDa41",
    "G1McruKkd4uQk6sKUVAKSHbYMZg3TGZE6zAbscrVUuRL",
    "G1XCvNdh9S53rt54CFCqiJiuJTyepu8mZ96a2ABQFy3n",
    "G1gyK53uw7DGXd8UAjMAYPXpohe6rqJ9n9sj7WB2DyMr",
    "G1o11bi5x87RTYenj3sDGZxhZWSun1Xf27MsytKbzJ32",
    "G1pzgfH3WbN1CCJJiKRigc13CyvtJAuDrXD5PzJKVVu8",
    "G21LfUcSjn87Xm9WM5N29imLam5EbrspadAUEyS1zhUm",
    "G2TRSmC6EJZ7QWNwpkSr211LXCYWrEzSPnKakWzv3tsp",
    "G2ZAnQDC874zDwA4hbfpMJ6HsDCwXWR5Y12vFcDg41bo",
    "G2bZyVDFuBLdsnFdcQsHh3pYEvqQG7ZtQeaRZHAh6VzL",
    "G2dkf5tbPmWCDHbJyrfsXLzzEH5aK3Rt29ySfheKQ2j2",
    "G2nZuHyhaxQivBsVNcMTXWagSdcpJbvvoHZcZ1gycWYT",
    "G31EfXX6iezzLEDhhf2CHsbFc14fX2FgeBGB71kUmoGx",
    "G3DTMHhxahQXWpZ4qTqPmBdmbxRxGXxDaXL8AuyF4KiX",
    "G3SyRXkSFtvnXakWjMSvXWYoYQ7s3exQSznRuSdi8gt5",
    "G3nbHj53rmCAZU1Q2iLFm73M9BFeG18d2sCbU2ZahsWH",
    "G3rC4pX9i3y1WiVbBD18QJ9kpHGW8qgLfKzs1VN6MEKK",
    "G3sRyjUwaroxxR96WR8m3ndb3HB8eHh7qnJGp5SpZT98",
    "G42i1o68Puh2YqQ18Dy97q7XAtzpri1peD6krZLXYReg",
    "G486HkKw2dpXYPFBCDwu3AA5AQ3j2GhbkUmwjZso8XKt",
    "G4HY8FGKS4irNaVZkW9fUHBqGBU7g1BEfRXo49UR2D7s",
    "G4TkdYKcw8kAnrmBhgoK55HKrbR7Us96yA2HzLLz9Qmf",
    "G4ZVoXivRJMVMQaDKkVhCrumTRDUbMiiCQHY3yoUnAfN",
    "G4cLzSDKXumuAZWE2mAYHYNmu9Pa2Tyu1dVfPm9USRMC",
    "G4vQmThSuoAqz7UnB1CKiLTVTZAKNncQHAwBYikwKJex",
    "G4xHaQwCJzgs4pyVDWsk4ZVkFpPRVKbTCHwQx2Nf1yVB",
    "G5A9tR7o4HvnvybGmaKxaf2L6LKSCRS3z6rKkLGAVTUN",
    "G5GdAWmc5Sk5rEQqNLGxN84qXfNbzwy3Z8BqadALMqfP",
    "G5povknvZXveRXiXgfbz6FHVkikxkpK3jdptpSy8zaPX",
    "G5tp4ZPTGJv6HrgZb5uhSAJvSUTHRYMUK1iRA9PBskHQ",
    "G6NCtBQhhTgUkBadiMmfE1u1ucYQYDL2G9eUUMAh4shb",
    "G6QddWpdHjz87oy8cNYkCc17QTTNYsF2r3gDJVyne83x",
    "G6jBubdEhq2kXzXkBeYYQFzgrqNQibdgLx5uab6o3wSM",
    "G75MddHi3gjJopTV3esjvFLaHmw3snyGAjt7E7JMyQxo",
    "G7HVJo8AyKjGDkvEe9YE399KPTx6sDC8FCYgHPJwgpnH",
    "G7Mxi8nZJSJc8drZ4HXdLKTs3JgRyikQFyc5NZoHAo2N",
    "G7N2VWeUFqx19tHwF8qzLiGg5ZP6qysqpPtYErQNeAnm",
    "G7k5fjYQ5wf1BYYbjNpWxSM5jkiKRw8GUMkaSQVompz",
    "G7uZfcG2gAzKiEKVsvmNBYLBThnKciuMqxAp48i3yAKJ",
    "G82D8QhjECqTR37iTjQM4WmrvLiYcUhQXmPcbB55SjVt",
    "G86qbgpbkixCVGs5WiwaEVzNyYMKafnfW6HuDvHCXwXS",
    "G88zHSPv5ZBi2u5g76bYpXaGDAd73FvP5yyS3VuRmQiw",
    "G8M2gRcsvrCh57wggCnfYTALrUTa7hTERytWRf4vzmPH",
    "G8NLAC67NYKnwoCQpAENV58gSyETcj4aArrUPoAKKshT",
    "G8P3rZhyryBo984UNDvfV3otp7nivAsoLY3ayHYeaWyN",
    "G8R24Ej4KK8DrWQjMbH71LGReRv6XEV71dwzNHuwMLzo",
    "G8zf3jEgSmnKWNuxHbWSczoKFKsTVa2mSSRBfyZvLNba",
    "G95EANiv9pQ9HNFxbRr5Kg8g4p3d2Uffe8cTCJzDP1uc",
    "G977Jtc6kjt378BBaePAyFmgZ82TS7pzTzYAR8imFELt",
    "G9HUYKjqdbtTF7n67EzGp2CAsWSMJ35rSit8HY34eAhk",
    "G9HqGXvPzZQs6VcXen3N4P1cMQmT5JxbYpj7hiF8tcYA",
    "G9L9Kx4rwtp9B89NTFJNS2oTvJAj8HPtmqw4eQ3ARnEx",
    "G9P3qRE8V67th3ve7rotGMiTXvezuq5sdWUv3JNwZ7qG",
    "G9UMZoJuEDexp3MPk3GrYd7jg9qDYVUDhZGWqVdaL7xv",
    "G9Wjqi4ehQL8RcLPJPSDCW2EwbCjbxVCyRgr1bywMJgC",
    "G9d7zypYxgWuGVprGd3G4Jh1sJ6g5dgq12LziTEmrEP7",
    "G9z9vXSgUSJHtpZdiGHzfKgWAk8hGDdT8aUFXBmxFhWZ",
    "G9zp3U8zLaZ2S4F7eJ58VkUvmo1WpinWfK9vHetu9ivC",
    "GABanPX4RYH1ANXYM1c7qaJmPcmWK5TvAwCBgFRV6Dso",
    "GAH2cc6SmhLAjV9rXkkpYcufkrguceN4bRYtF5qLxrZo",
    "GAS8H3PscXL6GBSSeVzdm21M3enpqBu9TXgwVY2SyJHT",
    "GAcwTFR3GQPxxMuPXFfq3gjG4b8BZJ6N1F1X4zthc6Kb",
    "GAfVEL4cVQiLbU6HuzHkAqYFp7zQ2Xif925X4QPMPAvq",
    "GAfdbMh2Wf3FCfEhtHLhfyPAbKZGTxUtyRXruzsZnefs",
    "GBLQ71BbQj3KYVzqHu7dPfREEc9S3wgqpcqNt9GJnaBN",
    "GBcryzwi3ZMAQHBRN3zrYDN6yNZYFT7vxUk6hubkKMnm",
    "GBhB6E3nbHQ3BsLXvtTRBQZsY7x9T8jrjvThSXbZaYbB",
    "GBnBHap4uq1HKyd2PXHtQhkRCJoo5NHbLW4Czr1FpmHx",
    "GC4VHYQa2pfoGNyfkY8jAY6ABbVZfZtpavGw6A516iH4",
    "GCERTWkymTr5vyzYjw2reZQVXW38cRizZDEZZhqm3Yz",
    "GCGfWtAhfUkwWqwKSmN7xRKw9GbzUhvniQtaNKbbzVXp",
    "GCHuLX311a2jwj52y1TP1YPGmqV6YLMonGJJyszpY4cb",
    "GCWNNLXkdPpzPPUUurGwHUFK8XGXyNj4nr92eoWnGC7F",
    "GCZLL64T39Wp5PYYVdtjR6p2pvASZoSTJs2fLPStigzJ",
    "GChmz7sUUUHuxZy1WMVpiBHe57u4vnLphdF6C4oYsDBe",
    "GDLHXZHhZtDqAHrJdGJ9td4dp4sCMkZDBLkSwaRMgy96",
    "GDPepr7BCap7uyWk67jYMgACuzYuPvmD1ATHgJ7wJn7M",
    "GDRHPEAiYsvMahnrz7rvj4n2DPN4zygoYeje1qbMcLFf",
    "GEJg6Bw1SsVbwt5tnsrTu7iW8YwdkZmzhVuXJfH69iX8",
    "GEk75hz5jy4tADSdkbFYq2YcoNMbVYVMMtKMLLZ9BJbV",
    "GExZUPzsCjbDXEA2TaLrseVLkCyTKqTA2M9NM5CGN2Wy",
    "GF6b5vYv3feQUKgBsbgDCMzBoJbeAUUbVUjaCf5B5Px3",
    "GFSAm2FSED167oop2PZdBgmJdZRuenYK8SG7a6PXmkyM",
    "GFbmAq3osAmKCZ2JG1sV9bJ3bGmujWyZDbihz1pb8h7c",
    "GFg8C5HsdHXqS9coe3XKWvq4TdkM2HL3Jg4XYfPBieJU",
    "GFu36gBJ134aCSeGZir1sFidDxAD1tyYTi9a5fA8ucCN",
    "GGh5mqqwn1JLrtq4bFQpJEwJbydUrkk4Zhz9qc33HU6t",
    "GGsqU6uB7QaDih4phQMurdNTGR2s7LNrVqJqSM9EGujU",
    "GGuCeh4dWxyEvGBC8nhggk7TiyhWrr1m1RL93DC4fn7j",
    "GGyz3Tq9RKiRSDnQAT3EP6BfBvehxv81bAex7zRARVCf",
    "GGzspqWqZaad7syow1xieQGW2pR4XL3gEVnF23iS89GF",
    "GHD1Rf5AwD2rQzKkL4sfUHZ2bcz3baAou7igAUErfwsf",
    "GHFhAAFymrQeixzDxLpecPREbv1AwneX5kiNpwtHzMR",
    "GHNXjCDivWyFExVa8P4P4a519e28or7kSbBYTphGw5Bs",
    "GHRPZtoUS48SdDCrMqtmbGZAqdCwFoit2fNJxmcVGgAM",
    "GHWcm6w4GjzFVrKvcekZnGfmy5WLCUZ4h4VWbwvrhS9C",
    "GHcwH26BTMpNpJLbmSDdg529ecx4Dh8UuyuX3EQSv6Bq",
    "GHfPHbuZa9ffCJj8PEANSexZudNqZkvZPnah97N6LFjD",
    "GHiRgZSrHgFP9aXjHq6UNBAgXXQ1xm3gwWNXuTYZ3jgc",
    "GHrZQ6cJD1Vab88Byo2LG3rYdtQWG3UqyCZQYDDLoCMa",
    "GJJKBRRRTR7XsN98cLrdjP151EtHkQScAMSwNbU7dazk",
    "GJNWQywMLQD5u7du9U82Gk5Unb2yJRWti1E8tqmCmqAx",
    "GJUdtSy6WnA9tZCn3pwgfzJX8F3UsBbwgHYieVn8y9Ya",
    "GJbY5kqdgAJQG1QhdjKjwp1S8b1m2ot4VoCBddAw4dsb",
    "GJjfWoHhUqmodqXa4KCXSA5fpUHo3YqDEQSDvuf8gr1b",
    "GJwAxZDziHCndAKTsavrvGKzonqjvz1RWYkg1gvKzr8m",
    "GK5wrBUDbpjrydSrzqyKSNEK8szBt5PNBmcYUiS4wUZ6",
    "GK7z86GG4XbGoAoWjFX7TjXx923iqLm3sPbBshmKNpDF",
    "GKG8cm7E9x61GQ4PAApoZVEgNa3y5Suosp6q8Ztr8AYZ",
    "GKVvm3G4Tk4UCv356qvJVLNBZZKTcXih6tRpc4PhqeBv",
    "GKdfBNsq9bfA5WmkgMDS6N5KWbVMWJDSpgHQQfnBDAQm",
    "GL1L9eioazgTLngXWEahcXGefVpjyWv6LZbZJ3JnJ4yc",
    "GL5ofXkQjrNuJKGfUEP6C37bA6XEirsUNrG7b9ZbY4UQ",
    "GL9hxNnvNgWKJr2fhocmMUigVBb7U14oYZadFZariLsf",
    "GLeyUvLXEjvw8wc4g4ahq6idEEdmVMLxVNu2t11L4yQi",
    "GLfAhRaUt9GveBc66g478qxDeQpgy9GLWLFsvppkGnYY",
    "GLoyxruxRSTou1jx7tCNZEsvjvb9i7hQKDVPhqAKL5iU",
    "GLt92NNfDYMWFNwsqZa9s1tKQdBgN2UBcakiwshFN3x7",
    "GLwH37xrJDGqmbuFJHKP5xicCuvfRrZLXCmXJop92fgF",
    "GMRSJwpFg9ci6MtK9qoKFitTKfxb7qQU3uXheS7wNSb8",
    "GMamwTVE9kpoSAYcss8oT6g5rBUuARsShy2VDnEQZPPB",
    "GMb5gQHtzBD6S1zBGEBSo9EomKqitxZEYnCwvhY2dGt9",
    "GMbbux7hSfKia5HaiYCRv1FLkCCeFTbUo52NBxLxoJsC",
    "GMraxtUZ2QjE6qdrz82LzZgqCLcDCewNWQ5b3yVyuX69",
    "GN7wiMEdN2ngVpWiJvNDsrovewAvPd6GEkS15zTw7e4Y",
    "GNE5nuUGHX9gPMwWmxbrzApJJ6eYpv2uXntBfZjqTGZu",
    "GNJUt41g5hrCEgM11TvVGfWhRfhj9QWDs31FNCeKg27n",
    "GNppfP5pKK8ZxZHXdoyypJryfTuAMLJsGPnx8mgEkBm1",
    "GPCw5xUj547P4j8cngvB1gKWVudtAVoy9K5TqoCstVCA",
    "GPMg8HCak7qQh5FtEJCR3Qsrg8PxkvXGAEWXmk7ZQQQu",
    "GPPpTvoaSXCQo5dzbWeQXGAGuvv6S6eipAC8abtYUgSK",
    "GPS8acR5qzPVeUohDM8Kr6ss9SJy8oCMHNxhbNQoL6qw",
    "GPZBgo8DQJ4Esvu6LLTjNGoJRcskiZLgZsWUXpnaPE2W",
    "GPjij7Jy4RnSzptP4naTJZcqCDGhkd5wkd4wHYCpy1gM",
    "GPoyhknvYYnDx735nFtC8TNBXRzZoCVGAn1RwXKaMHcE",
    "GQB4PhHypC28R8uzwavT9zGaKC5PuaEPQ8ZykWg84Zn8",
    "GQHvfU6TroLM84bZWxkk3FGhaXnfiCx2p774TyrL9a12",
    "GQJbYnMFC2LXiN657Xqx4DDVMLEdNqFTZ5N51cgF4c5Y",
    "GQK3P7qcTz9mxhNyuSeaFCUhMgxqkzPQujs2T9LNQTdg",
    "GQUeBZo61YtGcvGL1sdoViqfQAFuB9FZrKnin3B567aN",
    "GQaTp7eimuDyky6i99AhiVoDgS5CX61eh1jPJEbSe3Uc",
    "GQi5fE4krbxqFRjk4DTvx7x38QptPP1tTHy7GgeVtjNY",
    "GQn6arf2pUKP46cy8mjhCdpL86sQP3BQRxoMENN51Lfi",
    "GQvzSVRkB7GBzKLMzPp5xPGcTWbB2hnx5Bq9m3apsQi7",
    "GR7daNmk7jYaArPBVyzCxiAbe5nVwbFvtiLsZd6znvxM",
    "GRKHYx414WojjF7DKw3KiWHqoFJhBNnGfSsrkbyitgh4",
    "GRUF9fP9dHcUVRBozKhdtByTy9izdCy4aDqp2gzGVY2n",
    "GRZBTs6bA8ovGTJqWKixJ91Ho8kwrRqE6YFgKkKKaapM",
    "GRstN7pBn65YiM9YXMbo32SPDCXvf5wqTWAjhoe6EYyi",
    "GS3dbHreyDAe5YDK3mqHSCmyeDy9kvEjZQCvuFCtJtZA",
    "GSBJXPMQdhjtR9bXcdJiNQb6D7QAMywe8x1L8sCRXA1Y",
    "GSSYhwFNNCzo6phtuBoUenL5H9b3Bi39yUb8CxEoRUeC",
    "GSZ8L3rvCDpsNxYSVENT2c23tHCrHMXrpv3jYy4Zs5Gx",
    "GShHCV2xuXujqFwSd3E7uBt3sLAP12qmbuQmuTQnbzqg",
    "GSjZjYak1DtusLjZ2R4FK8wMbX6XuqW5Xzsf6SWrsXXp",
    "GStvxm16dhP4rorkrULgSyTi9ypAUyD7Gt8QBRxSxuQt",
    "GSwffEW3zKeZgu4WsEdDGgfvGPNKLM9hhX6526Md3f5H",
    "GTBtygGpydVQcJuPXXzpWFqYiMioRf8oCWnUwEtMbzZG",
    "GTVG5fiUUH9XWcpNJdZSr28GSkQpCvygbkTGSM5QV6aq",
    "GTcM7CrHaTrAHx2fSd5AyqseYHEvbpNXjNRfkrp8krb8",
    "GTeHcmdr8BbQhSHhbvZZsSu1Si39NwHQZtoN7G4L8gVB",
    "GTgZP1DgekUsMH3K3F6b4GYnyoaVgxf5cDHdHgwxYmKZ",
    "GTmdDVQpNgj2og3BbdRqLSB8uZWnVUYqFxp72VQbFENV",
    "GToh5EnGRwvAdizcbppZLLBnTxcjqm8LzBVZSueMLLrC",
    "GTrLcXurSUWbXAbeyaQUnoTa38WbJWvvX7xQxYWG28PX",
    "GTtfaRdK1m1gksD2E9Qmiq52LoPgaLpAQNHwzHu6btWo",
    "GU1Xae9iz44DrS6Ts6KPwdgTBddn3KTX6x3gbLpuQzvn",
    "GUAGgKVThVbpEWCoL6bJPVkG24Mz16F6dCjdMh6Kqdw6",
    "GUJpRApjY2ULNbWBeVmtrkYTTbjkYJkRVNwgjqKpYyt",
    "GUSqqtsmsLwBBB7cHNErfCJ3m5PBrH7RefFBhhpMRbn9",
    "GUVT4eNM6xFtcdHjNos6PoP33KfhCv3yiQVssyuHUEok",
    "GUW21KpR57HTxbkXiVhUCxRzzWriQ5JsH8qEZ3LjDWZd",
    "GUZ7AE2GNCSivaQYv1vydHDvoGQTsZaqEmpTmB95XLaZ",
    "GUoxmFHrqmt79nZYSsWgx95FXyjqY87eVJP5JRD1u3E3",
    "GUtn5UZPLAfToXPUyy47ihZbDGem6WUkvVX3tha9uFKX",
    "GUvC1sczq2m31SX4ew9sf46fmW5hrope48UPw7fkAxA6",
    "GUvkdX6MzhtUFHbaQaveoZu3uhCyPTYfQhZRNAaoz9FZ",
    "GV3Kan3doF7M52YEyQ5cy91kpd4HNKDQTQGZVY1wMoQZ",
    "GVMQY28UCUUNzWEr2i7f2vjrS4HxNrHd44kmfnMYHjSH",
    "GVQQUfPGoo1Quc8ddSdu1P6fkeHiaxtTRvVkADuw4HyX",
    "GVVQU25d9N5rWUpD7uEPgA5TN8Sj37uqnaqKA58Pzjjj",
    "GVbMi6ZxSbUjhj24wyX8tucSvDoJBHfjN2ETy518tV4g",
    "GVcZ4r9WtqoqXbtmD1HnrAmiu9uhfUVaGKqBqJzbENEx",
    "GVda7q2kdqeNiYQq2N7qjcmWPK91CpCDDNsMHJkCA5oA",
    "GVryCPSahd2uMKrQ8PcA2K5dofpWrqFZMhwicRsDg1t",
    "GVs2mSErCRHFVCMk87ZGBFatGfLs6VMhtXQLK2XtMReY",
    "GW87cZcL2QUrT1iSKdCdWA6xPgN7E91QoLgDAPMExpf1",
    "GW88GPqQ3VP1jUodFasij61RjDCYLvGEieaQng5ijYwM",
    "GW8SVYYGbXKUxpvPy85EwZVQxo7ot9TVybFricNdRJVT",
    "GWNHs79NEknuQ5gfjH35M8BhVejX2fYiWhq9ptmwu8yJ",
    "GWNxGVLAHbydCGtkxewufiBkuQKWHKbTXS8NW7Joty18",
    "GWmtq5DZ6nmESG3iBNcnhtqqin4DtiXNpK56jJ2y4EUU",
    "GY6imoEmUPEo6LBZH7SxH5EJQneeqfrvHKUxfTAhTEj5",
    "GYGHnm8Mw2HipBYtxtMXu2o8KjAX6rcMxhLAcvvVQSiA",
    "GYNxTudQ5QFkc9njnqEJjNLoxbg6ZHWE6cvkyZBwioUj",
    "GYu7mXYXtQZWJiQAtDY8tHJ1EvmubSRzRxgLN55oj9v2",
    "GZPKnDS1tcYbjbJ3uS1cQeeSoVoG8sEEkE9GnipRazEB",
    "GaZEth5ZTErpM2Joa7Xi6xbL52F3qkGR4wVZLtYYkPgX",
    "Gab4kECFHzXRC55sxYm1FrVcS4dVm3AoDXcKiiRwY7EQ",
    "GaxsXJUYDwwWvFnmjJnTxiZJwZz43ChHG7PPTmQCcbJx",
    "Gb3duGFDL5qZHaHPa1Qbnn31toMqAAvNCTi6wHkybmEB",
    "Gb6kWFRao4kAWk2TrbUt3FGihPzZuHVz28s6AqcEs1Hb",
    "Gb9kYx3s3y5zq4PAvbPzcjN3m291siWcWe6uRhUMVKsP",
    "GbJKhm2KCjyR7fxfNUXSed3mf5nXzxxVydZGEaVseZt",
    "GbVRqp4pjNbfj3wpQbzuVZgSULvPYzR19QRNW51WbTBT",
    "Gc25Rq8WUnFZBZkPoBRwDZiTsJFzPFDYtNMMLz2JNMea",
    "GcB6C74cPBA1CaCkFBTmSsTkz5UXkxhYzQRtaX5Vft7o",
    "GcRboa4YM4b3MPJwFwu8EP2GFrezYLDAo8iCQgtxCStu",
    "Gcd2dd1QAB2H9nBPLUC1yAW7uBwKF7ViWF4G4CtZXS9w",
    "GcdQKmqDeqzKRGCtd2kYc2SSctLC4fmN3ptn5nHjRnRY",
    "Gcsvs1AaoscHYTqHSsfpK2XuUp9G7F4w2FagLN6b94vP",
    "Gd42NMuzwPzN67LyReEUt2zwM4MtHaAqehv7eW32S8wS",
    "Gd5SEhDaxyvhufFDyaqTxDKPrs1uCr2D1c1DzQqZNtE6",
    "Gd7CM8ZF8q6L5d75iSHB4ZAui2j5ne9aJSaiouMJFddp",
    "Gd8aJKFyx6j4ktsJwktgA6BxHQmGxJ7D3SdWkxkWMpTM",
    "GdD3gV7GeGWDEV5cFsbKVhPYSFn4UyY9uWncHC3g3u95",
    "GdEJCwUPkgJtMmHooxLoj4g2vf27XJurTrMxvDX9cLaX",
    "GdNR6Xz1DfT7aUFGUkGH921R7aWHoKZ3S8Jrg38E1M8j",
    "GdjdbT3hG3ubCnX2RCpxrYiLj1Zje1TS7tXh6FcqucYV",
    "GdnVYR3w48eH7TtmAhcH9gsASAZGF1BzcfMPD7Jqv8xj",
    "GdpUkDoNbHigjBtEAh2o283qE1dGuoPm36yNFiqxbDR4",
    "GeXhDwXQnY3FH95pwaaKpzB4sNAJ3LdCJDRnfqq9XEYV",
    "Gez66B4HpG2SuRiQNMr5N7RowiydxoQq13GVNyvnyKr6",
    "Gf1Lvg5JWMpAZ1frtiuYkB7N87vJGXHkb4Ac4Gne5G1X",
    "GfGnPGkMAvyuYJMSZ6b4r6Gcx2x6xP5QjPN3zqYxZMga",
    "GfGrN7VsDvpdKxUpeU3EBfCzdqwgyzVSjXdrJBx9EHcM",
    "GfLdS3dhnjotEYyxbhe5pJ5zHyUwRUVQzfQojSvJKehL",
    "GfSWq7DRFBYzdzunvQpyjkuUCpK3ywK3w3amvAbp7Cas",
    "GfYpMuT4BhyXA361Kz3bzvd6EUrCQ8MQpEwFmXhP2wzG",
    "GfefEByjAWm3x6CnAkh8jt4nPxSVqURFPWPZfnHVGUdc",
    "GfzFFvDVdU2yjFKYBxC4Z9JkP5Ni3WAvtzcqdkRbSWRX",
    "Gg21A8mx2UQQJNpoF4dU6SVLm62RCH3Kvowvsu62g9L5",
    "GgbUVNqpxQQEzdkusickvzQStfRTR9pwyxPbGcbZeVTx",
    "GgeaX79RZFhnp6e2nV7qR8TdtYqcuXujcn49RmqUrbF3",
    "Ggmu5zgGHRcDg2bxRaEHKWFZAfCAQ6AshTq4r4Rkk2rW",
    "GgojsgprYjeGXRnNQ3H1ARvAm5a7cbzdjRDkMWz2aipa",
    "GgqowecM97EwjUXGCxEVLaEuXtYfCJqShDxfg7B729J7",
    "GgvFxiA1p3aU4GtafXUmFWHpCXHp1krK1sVREHeRtURF",
    "Ggve6bAo3h8eDVafsydQtyWysP2erYfa7KWUZBUkKYdb",
    "Gh6oCcBPjqmK4jJ5AQEiGNzNyiimaKNwBdLnHpxymD6o",
    "GhAoJdJTtvP2Vy2NVJqQJiUe1PW7DSdVCUb5LahHM2bY",
    "GhgX8VYy7Dy1UqAPWvW1fxq4x7ZTvWFWm1kMvkUvEmZ8",
    "GhkGPTuMh2YECjURWptQoEMWtvKbAcgdfMDEQAqeXPrV",
    "Ghm1HoN41MMGoYsMAfH4CvJ8epnAvMTio8xqDwpQk9qt",
    "GhrQSvSM7wHi79M7fCUnrdxZrUGTCzi3i7SxEtQUyiPD",
    "GhuFV3jQidDPdZqAaTmtSw8iDUuPv7uJH24bLpZZFSD5",
    "GhxCKnqH9bRP1oNrBf2Sr4Cu1bsnApb8D5jdHvDGFERP",
    "GiMfUiW2gghSnK2rCp3ZQ2BAVito3XuEqsUxcFVsFuvt",
    "GiNgUM8J3yP1SxhVraX3Jmw6a6gZySmzSgvrp83pfznL",
    "Giaj8FMXB5i5SAbQNqDBG3CrwjnzQfM6JbmABWzPYQcv",
    "GicW6RndXgfkxgVGsSsdP1MCsboutFPE7htBWZGDJnrS",
    "GitA2DMr8VkwGCsNWbRpj8PbA9uc42kKMA7Dg8P8fibU",
    "GjAFCY9u4hqLiTuN2tZzGrQSG5FTmAp4bg3yxpFBNE3u",
    "GjEYoedGAL8LSAUX1K6bB48gjWCeWdL3Vs84feqpFXFm",
    "GjJ7vYbv1BANMqawt2WKVehEErD3RJ1E4UfahX7USPZC",
    "Gjb6HzS1au5xmtJ1i88PgNjabGeL1UnA59zbJrXJCxhg",
    "GjbFf4VSBvoeUMJbjgHqw6ZcESpfBbaySqxcLFjJYbyG",
    "Gk5b1NsXLACinmno4T4DekRF89AZK9Qqeyf2Zme7VySy",
    "GkHsALCc6axrmCUhfVggcmJoE1PuLd3atig97xDZyb7T",
    "GkbQmepHHXGLfWck8dH6SwES9WvtUPksMVPmjj6yKJdq",
    "GkkCPrwTmWt4ApjZz4qTM8BxdUTRae9RBV6cJnVL72TJ",
    "GkqiEXXQxFvrqsMQqAALjUnD4owbukbdwz8AYbAyLfDN",
    "GkujEJEKgtXeC4zpxwAMjQfrXQLhPGESj15KrwRiJkLS",
    "Gm249BBGg9saro2ScTkE4AS4vTTxmdmriaYKAXqybft6",
    "GmAXDjEKN9V7Me8r62dmSVTRQz4ZRv6WHcuvPNdVJxTx",
    "GmXJnWqEvV5bXidskK8LaezY69uMXtTKgi1p5goUFdag",
    "GmjT5ihEhApBLqq2wfXPhNwABAzKzQsMLWtNGsXnLJTW",
    "GmxVMsCNkZS5GtXeMV9M19tqyVu96d7x6y1kMS32449Q",
    "GmzqBaQeMqAkYLFarkcuJJyE3tu2AKd9JikibWThPnkK",
    "Gn4aJnZYQ6RGYosACTsRUahAAPtwMjm2zhaqQEB26f7T",
    "GnJCo1uEeTw4vpxFacNpb1CJx444rwhPeb2qzCivaZfL",
    "GnMxqQ3Z19tTreAHS4uXpRp1vmSHeh8YgBuHtxRDdYkQ",
    "GnPXPGphFo5sCGvszV2xu8dSbMUkdUdejmgKQrBt1q53",
    "GnpfB7hJWRb29MzN1HjKV4DRg4A554AUPhx8Lsg8SqZ1",
    "Gnru8GSGiYjVjV8AssePn1CZNAJkBdVT1QMvnEadfHB3",
    "GnwQXBpDbkavSicZn36g2ZdgVWsnaA4jPtgpErX9pCHq",
    "Go7xWMCULG4Kh4hsPhu18EpHwwgyBjbvF769ZcJDr7s9",
    "GoFiVLAd6SMLu8CZHTu4JzG3tfkFqGLv155jDwCVU9Z7",
    "GoGBtrFpW5X5SSrUUrcEUrCtayAqNakPZfhUxoCvdjYu",
    "GoabN6gYtjmR7VBrEQUouRT53EHVZ8YNraokQWXccfQY",
    "Gobs1amzjAbFC4nLZkJnro1CeWgJjjGM8vZ8XmJj8FSx",
    "GosVjgtgKoAm3bRwZBm5tgHUR3vERFr1wxMJBBLmT7jA",
    "GoxKcZ4d5xBx4wNN9qxQWkzbUiQLS4dy3VMMWfvPKf9b",
    "Gp8WvC8GAwcFBffPUAEGWNXB3Zm1nSEDPujPXvNcCf2P",
    "GpUPb8Tg4AaknLkLSciqKHWEhsqhkfVpycbtzSFNEHC6",
    "GpbL3wKbE4MoZ76VtYD4yPFSuPJBbx4rZe89LAPWQv3c",
    "Gpu6P7YZVExhBJe9XnbKfitnZTuAudriBeq2igECZNLb",
    "Gq7yYnFLu3zAJxj9nSfPUVCFR7NwDDn3v1bpienpgMke",
    "GqBA66Y6TJWn1GjWJwXnnsKNr4V8fuMpq3UwrUeCgB2h",
    "GqNJjbp9dxyVNMM7Tn65iTt85DQEdcQedMNCkGbNWh9b",
    "GqWjg9ks5Uv6YwRn3oHLANbfhKqJMiXErCEJ77DDS5RX",
    "Gqst7dJoL7fmhZWGKSp8zBz2J1NaeHUUnaX7fGFDztvJ",
    "GqzCatxjUCFoNHXqfvuUtYDSsKo5584AQEW7E6HSCQk6",
    "GrU2CqsFfYQM43Ew6ihBGvheQKZBzYZRp9fGfgo1HkmA",
    "GrdcvRXvHvi749u5hdmnw6Ue6ztnC5vsMdUkLUrhRjpc",
    "GrmC8TMqsEjn7WosseKE3HEFAJVsjGMx1nwD7eX347bv",
    "Gs29iitv8rTWPwNNiHzX6XEiuAKQSdyHaa2To3WjHi93",
    "GsEzWUcKHo5uGhoQKJbC3gQM1kLHX9a8bzscdAxjj29E",
    "GsPRbeGkUZAm5UfZABvuvKdvdBSP3JppdKTbrcpEc5FU",
    "GsczjyNa3t836787nvapgXSupvZZwgRjzZkRbJZnzaCJ",
    "Gsigb7N9wboWQ6biKh7g1virMXbyYCisoeNDLC4uLJjH",
    "GsoquAwVjRyaJXXewvkH2xmYX4oZ4WQorWHE4E9kqFUf",
    "GstKuf6sW86YnZyDWGm42G5okmsnzsbHaTRW1RVxcAyD",
    "GtCU4QnUccozsUedyuGwQMr7YuG47iaSxPRZiU3u14ei",
    "GtDU97jVUHL7UqWTzxEBCiENHsQARKj5fVYXgKdv7BsL",
    "GtpJJT8y6inMqyR6i4TzVUEhuKPzUPKmVd5VyRoiKRmM",
    "Gtxso4RmYkL8BAXDPu1ggYbFpimjbnxHK5p4gKLBFv34",
    "Gu3wRz8WjVG641a8GVPM787dKk5Se3fGm6iuiwVKAKzo",
    "Gu5tuuEL1nfBuXy5PQrgNzPXi4188fjcn1CvcgHJvdHg",
    "GuBfczHiBL7DNaWrRG8ABGeytaMgxFTuUMUhU57z612G",
    "GuXvvmj9U6ZtUQnn8Sumwd44wn4VRKQsCdwAoZ7yYPhQ",
    "GueD3V2Mgu9hMDtmKdhddfe7jkvj7n9cicPUfFu2eaXn",
    "GuiiZFAni9kuAQTJt2qnNT9AA3gGThSB7tppxK3ph1KF",
    "Gv2chXTKPSaMpBFevWdB4fP371oRVtaV3dLMyPbjxHr",
    "GvLRKp13GYwqDtaSt8YDAzBY8iabm253pDqxMDpyUmDS",
    "Gvor9PyBFoLgznef3tTmW5aBEKXhdkm7PRPh72HFfFCk",
    "Gvr7GjjqvfMDNe4du95T4GeqKZhDyWsJkEPsef45sQD6",
    "Gw1pLD6NNm1tBCBa1trs112HzN15j8zvvJbC7vXmVnjp",
    "Gw9Gb2FbqqHoXz6f34GU1SEAzDuiqBqsG9hZBzfJ5u22",
    "GwDaT6gk2wtvEzjX8LfmXFC4vKKsdx88m2mgMjFs3cQR",
    "GwNwoArwmW3b1KjKNpp2snfEap3uTGqACm1X8jvuWK9a",
    "GwYDjZmbhugrEBcSvLMvrBQjxzz1nVNNrnLCaGGWuVtY",
    "GwtFeT5Ys2baQVJPLamgFTJfmZfDqseWFbFdMP2BtbqG",
    "Gx3MjhsomPs4WoufsJVBnarCPqWVB6RC4LgXtrUmRsgA",
    "GxJVKMmJ5qnV9p4PmPxBipqWiFJxB4J7ppTLwNgPndYo",
    "GxXabAaAnfMXwJKr29ZWcJGygJaVxc158RmG5MTfSTLV",
    "Gxie51rVwpmudibhxpEMDzkWBUDTADURSjTuvPabekiR",
    "GxiiWCpLz5uweeEU6bhBAFR3YQmCLRD9Hv6XafNWF5ms",
    "GxyGVhDaRfNQ1jQChahyD9jzd9CgFVQUthGnTNQqS1WM",
    "Gy2hYhXFKqjzSZN1zADcqBHJ3ystQ4mDAnBm16hhjzUE",
    "Gy4ZEaU5R1x3LDX4zkcZ7FYG48nqXhheZDvAQMF2Jiks",
    "GyGrkySmWQX2zgqbBGQ7YUWY3TiA4ksChadcuC9qerKF",
    "Gyth8EhiUDAai73fpgDYGnetF3y6qGqUM5bCYLgnMbKq",
    "GyzioXYon7zQmwnVPMeScLk26G7s3U7EGiSgvs6bHHfX",
    "Gz3YR2Bd23dToZRW2tXxc2b3UMstMDwbpnfXv4oq2Y3W",
    "Gz6r9GNRZgZbWkgJ1TDg5LuzsYFMxFbRvrBsZ1jmXBKj",
    "GzKHKR3WTfSy4yFCVw3ZkzdMCWpagdj12dFPBnzgmdPi",
    "GzVNDMdD8ZMNM84KwpC4RUoegen5PJBkHLiVshu6pfCh",
    "GzeCa72zhZB6oAi6Z1gV6Wy1GzRdnvTt5bo2f9HaiLUr",
    "GzwwPSzQWwByyHB8vkHHkeLNGjZVw3aM7hSm7afXH6HT",
    "H26TdGFLExFK39Vu9j2Fb89MXqr7uPukJ4qVF2tpXpKx",
    "H26druxceJDPGcRcZgWDgDBqchdrbiV5HNyeypPxN1Vi",
    "H29pA4itTyqyG7icXZHLYjfANgsyMeLjNJ2hBJrYgQeC",
    "H2EcmExhu5vxtcv6da8DTdaKz44YTizsdgSscYSCQLan",
    "H2Uvk6QDK2gVeK566dMYk13PcbmUGQYE7kvKdmJRSnr3",
    "H2u4FB8FbbB5uXijiBz9NQvh7afJ4HiyMuFuUDnnWk2p",
    "H3oUDRBvm5fFxZrxKPeB14SuSRTpxEdvTNYcVQqtxCja",
    "H3upsUqryBqM8mgpUxCvh6B6MAdRmLvw3hmzbtQLZ8jw",
    "H4DjCzCxFnG4DEK8Kf8Ewe1V7q4Wc9Ynsv4tEioTJuQQ",
    "H4WZi7kWLQquWoskyzVdgoe8f9H4keLKKNxifuzr2E9b",
    "H4YzMtff7kKqFtCKyPc5Z9666TjWfWQn4EyRVu5Hvk5d",
    "H4hqmZ3x57AB2wEiSU3UYAFWstb4CD3Snb29zYLV3fzr",
    "H53EWb5A7yzCVbLa2shTrDWK5XbR9tNQ4735hQHCwpfD",
    "H5XKsDfhewomELwZWFSf9EK5QNKhuJ5L3EdxjDmpuZ33",
    "H5i9bgN4LKkqpN9DnQTrFGh99EmTEmv2PWL1RFm6n59D",
    "H5qXDXVnQbj283BEnCuQkLfLV78LPamf9XHfV1Dgfyxz",
    "H61j8Ji42q4kRhehXjfEMWREsSRbh8m2v8ieqp2ow6LP",
    "H649RnayMDMmP9etLTNG4YZkw9bqA9kQKgm9knyqWBAK",
    "H65AEEBSevsVTZdMdtg3FSEjvJaJvhGtaDMurnPmCwdj",
    "H67JGsMcbUgbYeHfmbnEgSm9LNs4r969tiefV2FZBNEU",
    "H6d7bJCvR8mZcPSHgaETeDFkeYzjs1iyU3qudzGETxfa",
    "H6fZAM5YmZitnZPn57NvcsdztfikURoUN9D8seNkeEiF",
    "H6ikKmaj9RkBh4hpjQgUoaPQVJ45THagtc3GSxzVebaH",
    "H6s4bMmoF2r6KkEXk8Bfj7juCLLqcrpnR29NWejgwmor",
    "H6setbVF6pqhes8TkM1RRHKXiyLCMC2p3Rh7CT8mWhVd",
    "H6uTHoDQqFQLzFgogYtwWwvC8gR4QvBv9ZR3XWsZ3PKu",
    "H7AgtzVVuVsLWCbwGrK28jLzDPDFCMUuWidef3ca4Nh6",
    "H7Jsn7riY9ma7iZBDqM2npJVUWzTHUstJ9Gi7n743FZ5",
    "H7MiSCsnC9A9rTGhiVGVVDtjZG5gBrhYTZGNU4HG34eu",
    "H7SL4RHdqPskWNU19HEm6VQyjzVyVFdP1BsrdXo4fkd4",
    "H7Y8oHyA7SgAicbfsNGEhtU1cYvEVWnepzUpVcKdrzmi",
    "H7faquq2HL5GbNUX3vJwp7ps26RGevuYTvaqxyycaWw9",
    "H7kXiLi3knFoRoQCge6LmivaT92S4FHKDPeXLSQNrdNi",
    "H8AH4Zag9E5zBbeirs69xn9d7dyL8M7FiUPwynr2Dndi",
    "H8RM18LVxoNqJR89D3jvu44oqbTE2Qxbn26ePKUDSEq5",
    "H8a8ejGikTCUgSRHiuuVfJ6pztQ6mvf28pV46nmoTiqa",
    "H8fppuBTqPgc1eNA5EczVFHgundGRHjo6gEtS6uVRJhE",
    "H8xsCCKSs9zjaYEQVptf5MTbTDT1VTZsmQ3sCpu9bxxh",
    "H958Fy1XJCi3iYNQfP4AoPyNyeUrFcmxvzroCWoNVKJz",
    "H97zm31EcL3vPKGVia4o1zhWDYoNUXXq4YgDV7EjwpaD",
    "H9JiMVNksgVUYywUkEyq1e3iHXZvYiKU92qi9mwsQL8j",
    "H9MTP5xufn537qWkngJiEcaNwop19jALXS5BbFWsTBSi",
    "H9ViXVApuYz5ycF81FyV7gWBFSbMDmx4KgDRZkSonXBf",
    "H9eQozXXoRgNQdjZSBA2o5Rtkd53ChayQt4ArnPL63RF",
    "H9sQQj6qtzgg5WgJzcm2ZrTcuuG7M8kDYMPMy2ALC5x6",
    "H9tkF8WCn2JEnxpRo1Qm5WAmHKBmL3vjTgwCsn5A2rHv",
    "HAHuEqeuLrdi7XSZQE7ttTKshJje7SeeZqhzRUvjj6ZD",
    "HAP1Vuewhk1EZEah4jaQgUhDu8Aawu2igCYssJrLTrYA",
    "HASFYdjfZVaP3hniVJFzgu4t2ebhyDSHevnqU7AWbgQt",
    "HAkSQhfrSH2uqBDutPvvK4yepxunYefJcJsHmnxdBupN",
    "HAoB4xXgJxV1FXnD9MUvipaWe5fyUTuchZat3kmCcoWz",
    "HBBHkkTvQTCTZGChu3TEJoM2UUzEV8q2AXhYXginNnXq",
    "HBFZc6R7ZDyim8LvtcaQdN9gs8FUpmkMyDVuc8tPrunh",
    "HBRjWpubUV5eWoA5ddFfQVqfa1rK6zL2nEqxekgvkHCK",
    "HBTAzdJimxhZhgugUqFtjJcH1kyu3FM5dvUWchasqZ2s",
    "HBTyYfe55emohG9LuUEphnH5zqXdiewy4nhemthcoAMi",
    "HBdwdDksvtuJTNDd28h5xbpKYLGKtrqxdVseTfY5fTvN",
    "HCGvYVcayckeSVgc9BNQmogrXmsq1XjTVZ2gsJmPuf8q",
    "HCMSyv98zB6UqHMpEFZvW1Hso5svqXSvXp5jCyZnWy4g",
    "HCPBK6e51kGiAGJkq1qEsZRpB1Bf4JQCDZjFsy8yTLdV",
    "HCXpvaPXKZBZNoCzmRyvwq5oGWq918nJM4kVB38pVCJg",
    "HCaqswcW72ZdSNQG9iY6e6sxpqhbQyWpyLJ3n3mzAoUx",
    "HCcCNvwvJubokU9AX2Aey1kKBkeS7Jy8ju46K4FSfBQk",
    "HCrkjtHhsuXUMvYAKjQNgs912w6b9rDA9zyv1Jm3JNJX",
    "HCvWzpDwgM4zmouKu4xfNrKGNHUCGRNekMgiXhrkjGZG",
    "HDVpcVjnzwPrwReGt8dEU9Nrd2S6qdocWD7YRRfBkqo3",
    "HDXmuxkNfDcavCfxmZUKehhv3gByRH9fWZfP4TXyQUZk",
    "HDmszN4VW2d8AFaMYFMgnoZ4oe6FzEgt6kJSTi3eFwqS",
    "HDsWNdEL2SQU8xb9M9u2zR3GBP5QjDqZMqnUWp2xMcgQ",
    "HETZDrnYut3yHx9rWeWrqGSMXtc5PzjzLXfSh9HTeQQT",
    "HEuoUCWnwkVv5BmerTmmcVLw66Q13BxFLi7NvbupEgcd",
    "HExMDryutP7YJttps2rQPoaCnN8QwAoQLQs2dJFB32z3",
    "HF9apccUvnwCV6tJFF1mjYYThiUxN1ZXHsfbc4aK7bkR",
    "HFEumbZjFxAeMFZuumWXMYzjRRDScPq6nGMPTTZcS1s3",
    "HFPXKbnDuM6k3rseokp6DeWE2uJde8HCRJEcrWnqHXSy",
    "HFuT3FKeP96gRsjvnaf93bK7WYJ5brXpxcxrQ6cun5q5",
    "HG6MMiizC7YR9yBdqXTBfUkVnyJtbNhdMnt4nNTPGkeK",
    "HGD6gjUERd34zc14eAprAfUpRnyBmD3D6Aq9qnRAY6DZ",
    "HGKKvbQELTug8H97oT6USMxXDKdadQYxLXcXyJKVAmj6",
    "HHRQjufLmTibygHzVgB5fXgQBte7EFAsR68UxcQehPZF",
    "HHRfbWhv4rc8oWSJZb2eURg6wMAz6XcvSthKoucf3fA2",
    "HHVvBFDitEX5MN4VDmvZYrKvWmwRPmLSCCCUUucAmjqK",
    "HHfoNvtzje2Uho9Ew3JLJicDyoMFNqbYmdjzkC1k23Hs",
    "HJ3X1jqi8ZL5dmKoWphnfyJphyT8jmM98Nbb4V72Ptw9",
    "HJFTDiz4C9jV7vSWyebZACNKff7Hq3RjNVBDFtFqnn4z",
    "HJK8vyCEe9VvNDVUAog7QP4qU5VHhLrRBQqhwnFjgo8S",
    "HJU7eSf47gbLKk16RWqz3z94c1fiVZaxfXEu9Ai1GBHV",
    "HJfzCRRLqaynfKKUxy2kTtG1bDVqivo5NaSfoWj22jD",
    "HKi7X1Bg1h7Kw2YcRy5AWNbpTJ7n9o1onTzucBe16JRc",
    "HKnXCYiLSoe2od2B6zK8V8543HtopirFwMXh1of2nbx4",
    "HKz6umgQuSnMVhWMkapMYJzRUNqKjpPoLKqoNeUaR9NU",
    "HL2hsxE16jXKBPwQQywTbq5fxvSM7oczvbyEHFu37KJs",
    "HLXRJrJKEd8yAwXNS1KYfmttD61gdp1roMYwp5qVJ3zm",
    "HLYte73z7XUtA2GzUh3RWJ8hwrjGwV6ACYXtRu9nZy3u",
    "HMbjNfDssdARJJoU94ZTgqArHiW7e6FHCnej3u7XEmuZ",
    "HMruBrAz6enYN7q19TyUJYL8J7uJHBe8FxVwqwKB1XoZ",
    "HNL9pgKUrhXPuWRzKih5v3k9dXdkS55NbLKQVQEeGuAa",
    "HNdYt1uetkwPEqozcT6K1wTfgrKbakWedhWfrWwk6s36",
    "HNvtBNb5eHXgxmQJFfrdZ1veZUv8SU2psGNAHBwTEvrH",
    "HPJAjaA4pdfXoHBmdXBpAJnaDv8hgpfBYGAWfhfvWa6F",
    "HPSpXfweBFvATu9B2FPUv4FAvw9Ra2jWHsWs8RCfrQ8c",
    "HQ13R1yyEDop1wwSxdsKZkcm8W1PkEaRnGuZ66LuL2HK",
    "HQ34vfnBBJ9819Zk42Uth7uvT5AsJoMQVEpWRYxzy3nM",
    "HQ9LjheYv7q77DnKa1dYSfb1ZTh6mZdWmowzCbJtm8xw",
    "HQNrTr37VAuj6av1e6uDx94ww4mspQHeeKZtGodrqpRt",
    "HQQuTWiHZxi4H2CANga7FnMimEQEpVCSK5qRkPuYVxAe",
    "HQVHEfragKW9HDAbzHcJ2ZBpFp2jLzZyDTJ6TF9FyefD",
    "HQZSNX2qq9rpGjYmoSrYECuSJ8icT2JQsfopJp77hn9r",
    "HQZx8A6jYJtZjhTzp3YMR1qV1BRDbxmW7DsfAaT4DoAu",
    "HQkssrLwmymP1DG4vx8DaXgCv9SQyvJkxgBRUT9igRxe",
    "HQyz8VF8SaAvppzsazXKPawcaLHn2a5SBmN7T2kEn2KK",
    "HRHgbCurDfoHjLdU3qZWs63sdgvfqHp8zEtdBR5kczau",
    "HRXnehdNtDB63WoQk6YVLskki9zSbjpKqbvoV6pYRvQP",
    "HRcJnmheKef4bpAZVe6QbVUxHv8YjdRjgrT7VTxcX7aE",
    "HSFWX7JLqvHREmELwM76pVnxheGa8p1pdfntx5YjpTLB",
    "HSasy6GywLmhzF7dvnDPZ6L6R2RGSxi7R1sDCiaLkGzw",
    "HSjF6c2dhGvW4Ui4FZELrgDZLxEkHD2mUsKNyMYTVJqh",
    "HSjpeZ8bxRckbREPTaYW8uGnNznrkCgVG7t1AVVpX4Z7",
    "HSnguWnBtZ445T4xSr74VyfkWsTTw2DKXa7BQyxyvBRg",
    "HTMAANxonf8CrDg6co3GxnWyWzvN5muVa9E9zhnHbBBe",
    "HTYbEWKmuPtULRjrvatmGXYHgBpNjSc2VwNAFWzUR3RU",
    "HTaDBf8g5sddeQbJ7A6rJJbv5U5UAfihbXYpJ8dpv6zZ",
    "HTf6XpMosnK7jA2usxHCg9NJE9cGDyfKyCM8wFLvT9o7",
    "HTqA3Qnod8GczotLFNdun4mR1gGVZLkiH5pVfUtLipm1",
    "HU1XYGB6ZCSzxAJm31sUHxnqCYxBEPdK61FWAHsVxPsd",
    "HUEAhMhdKw7BaJU13E32TBDCe8HFvkCPEjpDyTe4uQdV",
    "HUFXguYMXYXQd3kN5wBXD7C5io5ubv6PxFDaaAGm5FLb",
    "HUR9jKVDVit7q5egfHwkfwQCnGSb1qghD1fMqFFGdGCJ",
    "HUTxnhKupnaqdhAHzk2F3SinmfDe8ypPiMtQ9YWuxkLZ",
    "HUUqrHiwgrbRKurbQt9RWzxLdavqNEcAJd3CRtH7cnqp",
    "HUc7heNSC1YNYQ1WA7t4VJoZLu1ZVEWeKk4UugrACP6c",
    "HUebophNeLUh9G8Esxo1H3NHu8xAB9N18WAFZjmaegpo",
    "HUoedkZmPeGCi377dJebwHWSJ8TaRs1VL3Bg9FRnx4bT",
    "HVCTFYyNyx7HfsjJefb4rPKCVzsxxVwdfpmQygFdBMvT",
    "HVEBEVKAQB1bQoY35XJQqAQMZYSzMqbKNoQvCP7zJZyf",
    "HVMRwP1LYedZpK5y66mA3Fz2nzuWQ1LbEtmzmaHZzzL1",
    "HVR6rCbdrJ7U45cdyarfEMumWRZiBvqezDuGVXCghiot",
    "HVauFnpeJmuE2y2vA3uhh8iw6fWkbwgjtX2u74FZVeMz",
    "HVmoJnpNNRB1LU4JBtx5dhVSMguAUBesLNJu3CqXdJuc",
    "HVpsqxMy8rKdFtS78gHUoM5u1UfYhof3BCHyoyCcn9fh",
    "HW1WiwJmauTdBoyPTKGmLUBSvmxM3HhXw8ntMofYxFXL",
    "HW35pph64q1Lt9QZcU3JicLy5YmNZ799VnjkkUpMHPU9",
    "HW3GwUUDefrDxCBS26qC4nsWwtsWecmHikP3dXDS44L5",
    "HWWtf1B4PdB6Q6Qehr6AvHc5caHERJNThnu7BUwYQfKL",
    "HWtVbvgoqU6AtWb9RgdBH1bJP81TjxL8Pcday4szE4F3",
    "HWu1zrwk9VCJWVTfT3mnTwiyj4ZbDBQK4gmvUptVoPDX",
    "HX5Z4LmRBrpnYLWmy7eTqjLqAu9KvLYpSd9oFwnfCTWV",
    "HXK1vVMkGGMfXwfBQNMcJb3ehCwybSQ358iKxDyTz7eT",
    "HXiajoAowZJhXKGfYzhgHs9Uqr1qCP7pBf4Ew9VoRypS",
    "HXmweR16ypZ6qAeLtP4TgaKiJ1HN6wWD29AC8MDdu7hj",
    "HXwrfj3nrTMg5PyVChxayVH5MNVtNXdgbHC9BR78bGqb",
    "HXxgoLcpKwDDRNPRZ8PD3HmgYuJQviVxkc3mJDew1Hbq",
    "HY23Q4uSbwhvuTpqHoZNQhfLCKZTDhNRvZt3isk3inEr",
    "HY2poaR1bqFzX58gzfMz5bPwHEy5et5oBQML866w59hH",
    "HYZNt2XJUMPMEbsyigVGB3pc1hJXNUXnRrmN2za3sv3U",
    "HYc53HMhvnC29NUt7nS9P2TwPfVfvHrxS1wRiGSrmuHW",
    "HYg9LZZy7K9cSMbchhoaqVScEYhGV7TSDjZj2ZRkS86m",
    "HYpTma6DZVqRtVFAowXPuiYdV4YyhC9uQPXdWM7V2rHn",
    "HZ1RupJTPpQxLDrbdXhvqfsgdSN4xcoU5y1Sw2p3ZBXn",
    "HZCQJc2efmLF7PYqTQShxHtEC2pz65Ujk48Yzj8eZUg7",
    "HZE3NvjLxkZXp9NtH7jiQvRQmZHcYb2JJQdRDSQmfkwB",
    "HZHyGvfBF86bx868L8dN1AZ5o1WeHeohAk26pcDQ8L2Y",
    "HZLmc2js4PhVedc9GP6KRtHg1tHva2rnmeez4Yrygpfj",
    "HZSoArV9xKuyrwEgt99orWkN7LDAQtRz1o2nVgyboVqw",
    "HZWcJXrJ6mZdQYLoUbNDU8Bz34eDESDbKoGRSh8x7Bcx",
    "HZpyi3EnfP4AtikACDJxGJQNZaxvPm2E8Lt3PZgtWx7U",
    "HZt1hDNqdMjcHYDFzD1nmQaeLnKLtLxSAYmEzj9wpHNC",
    "Ha14Va9eNXRJpdqafYkqDN9nnoszP68qpLXa2ws16r45",
    "Ha84yoJeMRxoQ1J6LZM7UAwLQaesULLZb718HNnm1b8E",
    "Ha8C2Yy9hmeGKmgovjqrCYFyN6cUJZMpf732CRrMkqnA",
    "HaH9NmbzAUNEPXjr3rWXCG2Z9NbYtuxqetJVb6FqAkPs",
    "HaS8RLFoF4dj4snC8aLht9LPtMvbCVPLex8dgCrmGyFe",
    "HaVFu86j5h9qBwCzoZzT3HxjPEu4ULZ3MPqVcFwMsaGL",
    "Hah5sAN5nRanPnaiDGyJx25surN8SfPVk3buHdB8EjVJ",
    "Haqfo2os2r7Q18ZAoqMNpeUg5ZEJ3KsnrWJzkHAgg4HR",
    "HbEM2yULc8m1KcyKWcRyRDVVP2L2LZhkzhgQB8e55cTh",
    "HbPnSU4vqch5TddKmYesskxjYXr4e3MGuQZyjesxzVxD",
    "HbXAA6if4fXch9xKspW7MxfHCLCRix53jZf166rDH5uG",
    "HbaEbFk7UNKgCLYkrGbPgwbFGjkLKAzJ7uUTaXFS4ngg",
    "Hbd9yhsWsHKDyG6LFraDRFmnfYftdxKNtrD9nHHUeP43",
    "Hc1GoyGJ5Aq33Y3NfqwtwqC6RAvZ7ZJYydXoc1Y6s9Ju",
    "Hc7nQ4kUPq1wingLeWYzidnFB4WZg8wGiEVfttScSK9Z",
    "HcSR2fnpA4jKWjG5jDv9RdX4Z1DoFgzsfBRQARuSRf8L",
    "HcUW4GqX5TfMdh1dkaCNY2SnBrSFLNsRE54Q9R3mi1Nh",
    "Hcg5yvMT6Y4Fsij6xRecSfC6oHCtfjdKCDKTkt4n8QHs",
    "Hcpno9pLjGsF2pCBhkXVmVztsW29RskdjC26TqjJ3WDA",
    "HcxfgjJuN5XvXaGqXDzWjeQfMjWoAjCMBt5Vzd5pRMDW",
    "HcyoQafkht4V8LiSyW8bpb84yA7GmFs42GFSN5pKE14t",
    "Hczn8BFcYd7ZDeMbz2XAgrvWSdhDrLcNUcQfbCk55dAt",
    "Hd89BBpXZdAZcFM6MkGMA9b4KFoZoRJWhbgC2YuYXv8H",
    "HdHpAMAwnp8m5JhBLvqMi1Ndg9UEN15BJ1Gc4vYHbmCc",
    "HdNSvQKC4nELiCRb6VxhqudDXUY3PKYqSVVpmLsAaKvP",
    "HdQDuyKdJzYavZnfHHN2aBpvH2roihe13FUZht32EZPB",
    "HdZiYzUKzPTEyH2mVoVpaaSKKhQqqozE4vmhKAe11HJZ",
    "HdfKhooZtohHHxG8jR9UMFM7VWFXi9PAKcUmWVxfNEyJ",
    "HdujpAR3Pa7UCbcmWWw3zxKyCTCL6VZY23uszJ1EQyaq",
    "HeDN4LZeL8Bwv6KZVooWfTzgA5X4j8cuQemRpsjgJ6Gg",
    "HeK2FUFS8vSqJNm73nXfiyjtJ5dNszTX6zcYcFB3RTwU",
    "HeQBtjxbjzgzBUtuFccnTN7K5pcDN87aEouxKjovwNs9",
    "HeQbGY7xCW1ZRt6NvquQ4MyhyUeZkmdEwVhiUhjaYU6Q",
    "HejYyfkyZMoFhqPg8uSB5k8U4EzsSTG6rTDdaLo5B3sg",
    "Hf7quaf9JvjvGyhhoaVW5ZQ7ShNej2Rimn8w7t1yQuNU",
    "HfL7ZXPCENqEJE8rgiKvr1NMt3hyEcwu41eV4xKqMnWm",
    "HfTMZwLbVoVeJehA3WDcPSmNPZQAgswQG7mL2RYqHm29",
    "HfpX3VeHiuM9MP54gCF5vfwkcjThv7s5SrvFw53fp3EV",
    "HfqMvfb4LJ9cSVMveMVGzDJicY4vXVixuTEzyR4XD7xM",
    "HfwWXkekgZzgGBRvqJxtDRPpETFa8rh81HyfPPRZGmBo",
    "HfyRWDq1XijBcxvN1bPyXbsZQsFJW3mHd8iCspqJAyR5",
    "HgEgDpvnGqm6YfHDv1RPn3sGQJWKGvXBPFxjb3Z9ZPvw",
    "HgF2zVMigG9xkEgiSekUmUDyZamuvW7EgVCdxh3GAGTs",
    "HgJ3MLideXRnCM6rnHsDe3LB2bQYy3YKZi6bKuXosVkg",
    "Hgb8WBazBEniAzjkSdnWTNPDaEQfKct1knKqyPbPHzNo",
    "Hgdm5vCEXRUyLphf9wyX17nsF4Mw3eCBofquBxJBj61F",
    "Hgkee59aowhpAFmdgSuTtXVgAjsBJc7HTgSqTPVkNmoi",
    "HgtVthdUdLEuGSG4ZLXKTDLb9MfuJ9GTf2rdB6SFqYwL",
    "HgyAk43gJTcirf7dUJDALHbcb42RJ8XNvfH6fxYwkTsM",
    "HgywxTAqjnnoceqWHhbFF6siCfs6Xsz7jCuRrRo5hQYB",
    "Hh3NcZKcUmJAJoVgJCVeNAdFrh9XWgyT7H6thPHL2aA",
    "HhRCUVM9xq6ezAr2yyDRnBCD2YNEoLXHZKxjoH9hpuuP",
    "HhY5UHwAfkrAtooa1gWqUcYkCvGhqH5bxSkcXMmAJbML",
    "HhgyJV6HtyipyM2AiE4bVVNZ3mykFoRe6syWGS3TZffJ",
    "HhnnRfSWVfDJS6A9hqk5H2ugTngUGngZDGb3gXY7t737",
    "HhpTpnKXdfcwh1KkbAKiG5JyVezQwLCpsQWxSXhE73jo",
    "HhsyDS1j2h6wK3hhcLyz4odEVBCJUicywbCqmwCpYfE3",
    "Hhu3fNM9s7xoThu7Sn8h4EvdCtcCpSCeD5XjhmC7zoHm",
    "Hi3nBUhz2X96ZM5nU2FESvGBKVK1bEfND84nSM2mT1xC",
    "Hi5q1HjNtLJSx2CpLhtUL5TMRwnH5HWaRvRxuB8KTDUn",
    "HiBnakYRQ3ZfVjrwcehGQDKwFrHt9j96oeoaSxkRGWxP",
    "HiHVpZ1B9MAdWxyVmN8P3T7JMVowNLtFveomsQzQFzT7",
    "HiLxVSDt27tt28j4m4qLx5aNQGD2Ws4egiUxuneTHuhk",
    "HiMuWMqaKuBHc18dtx8gNptPCCYGyC8JX3Vgy5ytki2Z",
    "HiP2UD7tBP3khuQD3mwe3XN3C4hSBpwkLoe6mE3rRFpi",
    "HiY7exZGxFApQ4MipkPPhtPvFdTPZC9i6jiQ7UTVYQjR",
    "HjACCFwRtoUf7uhfRvemeD6WYz1BuwsCKGUGnrdz114u",
    "HjMtjkQ9w3mDWCgRvyCdgrEKviGiid9wiDPtZ8SmYnJB",
    "HjRZD1KgKcofPAMxqAVVBPZNg5X17awucZ3RGaWnShXt",
    "HjZUcizyrLHxseY41UssAwJDU7pFuHWuScastgXBc7fs",
    "HjnFgBaoA7v8CzTuN7dxdaQkkgC3ATCQgYXfq3eqXz1G",
    "HjzfWZ24VG48DfXw4tSce8q2CCyqCXhDKB2B1psmPZdB",
    "Hk79FTKtbeABx7h34TAEEkJaJkhTdT6pxU8EMJKnY6H9",
    "Hk8iFkTpsLLdphXQAfuSRWX8A4Z1qfp2ubRix6DhojJg",
    "Hk9ZybyLe2J4XV33F5Lkj4ZZdTuoRJG3vjESe25aDHJi",
    "HkMA93PA793ywxKz7PCkFHhTrVseEtch9yH1J9F5bX8P",
    "HkVJSrwdD5vESbDUkUanTq8KReF18dDJgfZpwVAsLvr8",
    "HkiDaPGeFih4gFCf7262Ewz9uifq1NbYNiumiPRoD1LJ",
    "Hkq8RuoUWPUExY2kwdK2o5y2H37imcpQQi9hHWP4zVzV",
    "Hm9VrMmRAUgvv8kWSF1czL37dqp6qMZip6dWC445fkiS",
    "HmCqQr3k6ArNvTJqLizdSsHRz6eLu7Hd7RACd1QMeTvk",
    "HmJ8HUkJY3nCujGsN5KfSEbVhN1wAB7cWCXmrmNddkfV",
    "HmNd7wbWWVwsbwTdAVHuCQnGhHEkvgNCrNVfeycZ8eYq",
    "HmUYCUsSwJEPHx2rAy1ME4osYeue7qBkt3fwSCK1DEe7",
    "HmWodrhoTE31kisod86bn3rXk7aUATjkzoy4B2ZkALwV",
    "Hmb14XHJ3rz2iqMbkt7uQ5x6cctXBa4ULaAJFchj2k9y",
    "HmgHE88coyMTpCW2UYPCLDoHxGjwSn1gXrBHM5wYtGe5",
    "Hmn7PYcXnnk1vrjh8w2PWqKNuhQizvZ8QeABm9XWKHwJ",
    "HmwChUXzhexDjTCMBtBB4Jo2EXRrZn9qUkPJY73YVq6",
    "HnKwJk5TiuvMCYPbQ87XNB6pnE63SHRvVnkf1ZwyNV9g",
    "HnYJgzjqz2fzJGCBcF54yX2UpGe6siMWtMxRda1UU7C4",
    "HnZGYbMcze1xYVjPmZ3LGApYL87o1nB1pXfA5LYjiKNi",
    "HnvEdohM1KkBztWhwHuBvmnp76HaQXnFEsgup6yLLMc2",
    "HoFcCq22HepJTweBoM6JdFN4hF9sJVirsSFH4ZbyGYxh",
    "HoQYLSMQdJX5bUHpreTi857uUZBWYmX8uGi7M9Z2ma2B",
    "HoVcFiExK9W73tMtaqx8zHBJhGVmcMXxc9AZpbMckFeb",
    "HokPXcqonPcjv3swZfpLbpjYQoUMHjffpP9Hrg9AWnLw",
    "HpBvhtswCis1GrvQaGmJo7JoERAE7TBBvs2SWegRGuqD",
    "HpCP3MS2ZttDhRHETuLHHMpsMUSdzXSbyX2q2qgUReSo",
    "HpG9ZupUYXkWcG8R1zXStvQ3uiDRRkmukqCMLakoRR9v",
    "HpRfUHm4KC7WRHLd8SKTYdFdwEr5r9FmWLkYFmKSKEz2",
    "HpXg4fjPqg7KqFBZbPvaGnsB2LbUWvoC57W93oGobPjw",
    "HpaASZUDvj2zY65UXb6eZjN7YoWDg3Zh9MzpZeRTcL4v",
    "Hphwh2tKF5CSxdfKqAX9iGfefQyK3JmfNLRNXBVkMrrK",
    "HpqmV7gP85zTMpaLyp95ag7f2DQHgAP7nP8QmKiJDNhZ",
    "HpqzzD6WjNAhzZQQr4LcJFLpzwH7VmMaDWHtnxaokVzP",
    "HqCeeLQjc4sCmTdHdKPY71U5qgdRdRCAAvSpm1bMXgdf",
    "HqGeDi97jwVpCnuN66AYuZyhpWB2tnbfZqrFBEdTgSip",
    "HqSLv3Y1RAD3uuePeqZba5U8TvC1yFfS5hz6vEgZcdNw",
    "HqcWetiH4s5yERsatiYWN1EpUNjKRk27nGPPYZYvxmL6",
    "HquSWYwWfRySDgYc6y62ZGr1ggZYNH9TTyQacFrj75D1",
    "HrFqnNyELYvhYddsY4McaBSM3eBsQFvPgSYRy8s7ijZt",
    "HrMv1kwEw1fGbwUq3dBuWdYuVW4ZSJMmkDxHWaHLFYp4",
    "HrTzeLy9L974mFgSLWuUByuwjJDrfpydU1RwAi6kxwxM",
    "HrZpfCFsEoHp7gn4d7FiGvNgrJo6Gn3zm5LBiAvBveCN",
    "Hs6DDP8sYbKHZRgZqdhFoY7rDwrmBi5XqwMDTn38tFDQ",
    "Hsoy5cTDAG5NXwooXaZwvEu3AqZmrc41PTvBVJ9xFX8W",
    "Hsqw7LxCzR4AENM4NGDCmtBLKDL1mBDojEvXGeJmgchy",
    "HsuyDhWnavkVo7TnQLiERN6BspdGWi2oEyCuGNQSbb2Y",
    "Ht1DQkiFS5L48WLLrpqTQ58eT9MjqEfL2QSXnVMBmH4N",
    "HtCxrSbbM85ouW8Q9tAvTmN31o8TQkf6u3Qjf2BtT2op",
    "HtMZoGyet8HxUd75QWxwjH77KzFtrjBbeoiA5ZVKtnrV",
    "Htik7a6rhLr5VbuiGAhfBgTxY6oW88Jt52TEFTcn9QaK",
    "HuQAHWzrAVxWDb7zREErj9ezP3XWe2VoLbMxJPdM7x8w",
    "HuT1Knw8J6kp2of5sHrwgUyFP59MtW6Tqey3U2KmHPKR",
    "HuiV7p8gTCjv1tZ1x234RzKwH2125cVSjPrPmju32FVu",
    "HunvbK7yfKKQzX2KqyVn5L7udj6SJykjxh9xnaH4NMnK",
    "Hv3cNTvErwgeZsZoGcH2TP36PeHfiUdE3foFaWLmR4ag",
    "HvFYkEzgW22K2TR1ExZRFhRqnPqBAJx9ZSjX82MoNtQq",
    "HvJFGbScULq8Vn334pQSBB1Ejo91or9uvzerJ46VKUoY",
    "HvLydw7gu2n9mdMkwpq9WAVf8omdgvXkjzoKWSYvQrGM",
    "HvVgLyKdLz6rUdjja8SzFtAu7mNwaUNc3ivqEMARibvj",
    "Hw8zFgF3rcmZJn2ZPYdVV1fiN6bR4RXWMZHXBNBUPa3c",
    "Hw96Hdykzf6U8KQftuyqPnhA36HprnEGgvqEesxe884o",
    "HwDgd1mid1Ssza6imYNyTjCba9HG6GQ67D4CqReKsji9",
    "HwMKHvE5Shg8Fsct6PYUFU6weZoLb76yPK5gVNkf6hge",
    "HwQgurck2MHDvRdFnLKLTnH3vpatEsnVejWRBKWrEYpR",
    "HwRM1DzoCH7kXaAsrSSuQq3AzjzXHXf5NFZr7v6sY3Uu",
    "HwXFNcKP7bjRAozZLxQJSDWCvAwifbEywVt9mwUbXDu8",
    "Hwq7aPXKTreFWL7Sx61WURfDtjpx54yLzBEARDHNY9Dm",
    "Hx2eFiG2xWdGpdWbrJ4hzNMjyq32Ys5PX7B954jXTs9K",
    "Hx5apQQ7a8vZTwfp1zcTkfEVueRsPMGxnh9SGAdvNdUY",
    "HxGQd7JV1L5JKgE3X5zUH6ZyqdhhJ8baLZn2koecctML",
    "HxQBHoCJnvWPxUkHv5dTZaWFFSDW3ZBmrWjK6aiSPpLE",
    "HxjLoWSvD9Zu4zo6RFgBjXnrR2mDK9KBCueY11Yv8NFb",
    "HxjdcbvDoRkQuQk1dqnFuhttQDvDyWH7zDBKVMmiNBJa",
    "Hxq6B3NRV1fAmJtjcD6eS1wR3AbMCbyZECHeDHxqAiWt",
    "HxqhcJL1CgzHV8vHzT1wTk1QacTdZqg6XtXVVaNu9uDn",
    "Hy57EPmmPksiWNkQ4QYqB6c29DHqazK72T84EQHGA1Lj",
    "HyKYtUCZLrwGLM6v2c9bQ35BBm1emBELqpaNAjR7SvNp",
    "HycDGa7FsCWsUhAtVPTRSDQCPJkUrtMFNpJpM1RgL4Pw",
    "HyoLwSxVi9pnGBkqBLpeB7H4ektzgUtyvZgQgszdt1bR",
    "HyshduPXPSBDQ9rtJUvH9fagfKxc5x7awmNzLwLN6xoe",
    "Hz9sxqK2XDoBdztiz6ktCJVweb7uWjCgJSiA6wThMKtY",
    "HzUfmgr2VR82oMCHLhHxWkA64kN8eQgRinn6kyVi256n",
    "HzZsSSwb49rinPrfKe8WRyTEq8jr9qkS3EckLvzs3D5n",
    "HzeUYsvrpqCuRtxx1QWrEJdVvueohnPjzhphXH5KLBGX",
    "HzvVu81EmoPGk7fVwY1jYv8PivDiFMBbbWrsc3Y6EcS1",
    "J17Lgfa9poiAZ77p5pB6tSu7A7Vt3vzpj1VyAHdv59Ft",
    "J1DBbCRQY5puRM6gChhyjjzfeC7w2mRTVauVHGN5w7RJ",
    "J1RgjiXALBd7wAvVxUrx8YYrSFSxDzrCzNuB76mavbT4",
    "J1nRcyCzZvL8M4R4wsGg1e3XP9B23aCSWNF5MqpmmAGc",
    "J2EbpKpuqEfGq91TCvuCHAzCsnB5y2d65Qjd7CFUBpiR",
    "J2SoLvfe2S5EpChdM8QJRkio4P7d9nq72BccwsYQnD2H",
    "J2YDcFKb5oTY4PXvGaMCYMppcd9t5KVDJBzQnyVSwc3p",
    "J2ZM6U6i4eYt6yGnRrKDoP5kWeSB5Zg3s41kbQJagGX6",
    "J2a2FdEBKxr1QmkubV2DFm346D3i8kjfmfuQFAyBkya4",
    "J2h3qxkZWdZGRPRH9qSN6kXVCmikJoxWUw1heDTw3ibE",
    "J2hicXJxRx1ephyXcbowwd6VukWRu3iYnV6ThFbwovUx",
    "J2t5Rr7gJ97YV1M1sd9a3VmhfeqRUDFWR5Cg4tTP5da3",
    "J3Ra9L1HmGa783kKd3bc53V7xYHD1pm4wZnvCW8pFwg9",
    "J3a82tHYgrTCurgbbeae4snVCioPeWgrUjDR5tCt8Ji",
    "J3ibUNZc2hNC1abXwRuEDz2bRGf1zvLb1AEbY7CNsnXb",
    "J3nRo9rCF3Lbx4zy9K4xYbtKwSJW1FVPPVstcNH4J6tC",
    "J3xNZipLwq1FoLYjUxrgnpbo8wN3P7pqFwZ5P66tN7JV",
    "J49yWYpt7nNdm1BfZMPFGHspzXQGSaF5QNaijo1JUbJE",
    "J4RTKrSwUBwmFQnqy3z7GGT5E143gexWAinenmo2ikSR",
    "J4SfFJTn7Vc6iS8TYF17DCLFYLEDvUUS9DV5QgJSyXZG",
    "J4nh369jU8wAc7HKGyURShcuaX2VD7XtSCmDhbo1NEM1",
    "J4zF2sjjMNDLBg14zKqe9EydQaonX2Qid8pbFj4DBHJi",
    "J575aCzU1tzcNP7VAVVH4ZDtpbrPBmbRthQB1UQHzncA",
    "J597jvaAaH9Mnp36iPtQ94EgxCsKFijLDTnHY8dvDU3Z",
    "J5GFgx76jAdTXb6y7KLo8G5UZKr86ZwsLPGxKWm6v6GF",
    "J5JB6MP73n9q8ULayTk4vYzmsd1PGdT5TQbCcawFHBsX",
    "J5JJSCkpVRjbw4wyiFM3o4FbrDRPXLkJE2AggRbPymai",
    "J5LTMrtaWiNkeBWkEriWDrLW4rna3oPeZj7sdsGQPJgh",
    "J5TVRRrXBhphDUAqmwSUbrkNS87Yp69iXr9WHkcLMz9W",
    "J5UG8Py4LPg9AQMSamE9gegoxDQqZAM5hjmJae9nCJKv",
    "J5gyxgzWuotP2HiuYL5MMMMVFXbwJENKmHXWAKu87ZTV",
    "J5zkSzsUBVaDvVeZ1Vv6NTnRNJskRiBBpUKBgEQwbeJD",
    "J6HW9MHERdcewH4i11QFL4krRWGkFqeWAqz4HLhcMt3e",
    "J6MEM7eSXzLuCAhWwx94raP6jZX25jFSuvEpQPWk7kfz",
    "J6W5MaEGwBVJh22kLSJbx1Y5hvPyrDpB2H96Py2ATQ3m",
    "J6ZGFJUc4h9b7Jb1iepFP3s4pu3g5Ucgsig11j6WxJVp",
    "J6teUFLbJZZFVnL8gPLi4PvLf6RvPnVnszhYsB3Y42hS",
    "J72XyjxqwoabmWPsGD9mDZYZ7F2t9cpR23N6Gz32yYAs",
    "J78Sovr23acLAa3DgAZuW9znWFUPc72WLGECNJi1Fpcv",
    "J7EGtDCbSMALfq4qEPH8RSfJJAivaQTEWoEw6RPHPXck",
    "J7SX6Ymgvm6TQJcfzunnGbbXJSqAmqAY33VQjjktYk73",
    "J7WkLGxsrGASXd1gxpHrzBHiB6waZ373F8hp3hGGf9C9",
    "J7YUE2uCt9u24BgSUqwhVVEF8zeGAryBtBnRWJdkjmGy",
    "J7rZGkyrxzZSG8oeVANj3KLAGSNrkEnpDssUBRHAjZLi",
    "J7ryZLz4WtYKV523RBrwL6eVNsqc8EdVmE2uL6Zotsif",
    "J87DG3ukff74wEprEvdKedvL1gjbTiBYHNgcP8PcpEYU",
    "J8RqFH9LtmLXPDjMTTvwmWzxp7zccRP45s2KxByBc1ny",
    "J8Ws9DbKev7kXQKjcaU7PCYrzi6uf3c5dV9bxTADy7Jx",
    "J8kvjTZtCnAC85DavibNtVygRoHD1izNmsvNq5oaH8VF",
    "J97tU9sDE9J8DjExNhczKNwMxjdyReztCwnXgaJb8e1h",
    "J99pGET2VzLNCEKavDWYdexvSDdSQiJc343Wo4m9bCUg",
    "J9qJPVpWa3WBnJ4sPoYtMCNGzKzFhH564y4sdoXskM6J",
    "J9qVSzvZKuEzU9JfGsdqiqmv5uof8npaCSg9Pi4JW9Z9",
    "J9xgNmKRAZSWVWhuLng94mF8vGTXZro8pX1KZSJgEXhs",
    "JA8doTSFdmc1ji4bw49hV1owM3xTdC1PWWbeXAKoDAxU",
    "JARx19DS26ZEmv85imq9BaKKc4hU3LiJjSq9KWZpoeVG",
    "JAbRmT212n2UryHrdFGCyMZD27QDcs3sAsD7YmqGQdL2",
    "JAdCdrqQDZ8fFtCPS5X4i4MEq9f65NHssT5jAHVEs4Gf",
    "JAhtZW2QpYhTpPbchvBmKP21r3bJP2y7CYNL3kfTrBXR",
    "JAj3tJG9M1J8BzecX4eBFpdGNo1s4dqvED43Yy6bzuq5",
    "JAzqdrHingBpJ4gWfJj48Ng5r6gec79EQNhPFYd7WFPt",
    "JBD45wK9CT7nMth8RKQap7btskZMkMB4QH52k7AYvevU",
    "JBEVAdw2TpcHq3Gze4trbpZPPPP8JMXWXbYa6EVyKuGV",
    "JBSfV49ErSD1kM9PwEnkde1JJaruDvqdrDGQBarMEgjG",
    "JBbs9n8SGUPWGzoGjt8Kg6tjvRYpXBjpoU1aRcuBeCh7",
    "JBkM5oWFt4AnFQ2GTuNvoHEuiyt4Sks46da4hbRZa2ap",
    "JBkZAruKrj2HKyYw4aSdoWZZGYv1NH31THdQYK5Dcdr6",
    "JBxbQoeNSHiRxzSDKYDXJdVCpumrEoKY8MpC4ZA3kdk4",
    "JBzoRmU4zN89MEURce89TkSZCvV5SkjG2kXF874RrFeR",
    "JC439S4o4BPqazx3PU6cZ4xVU2FcfMtkqZx4QgrVVQf9",
    "JCHAKsbHD3w2xufYgNHEiPBARdaojtjqej7DCEWkqSL6",
    "JCj8ECgzLAKkLncJqrUxExF71jmTTef3ywRhrZwBF5CT",
    "JCjL4oDUKk5ohmMrQMLDPyUBtNnjzToU7pkcxqUjCLgA",
    "JCqXNfQTuvgN1ztTBFBcDoxGTeUscZH4zLLFMptzQMyY",
    "JD2AxjdVty4XMMxEySsbtsCDKCSuY9M7qSTZVJ5FeXSY",
    "JD53qTUxukSFdcxGgGXqsDZAV7SvLaRjCHtD8yEN7yep",
    "JDJupZ82tu7hMWShgryAdGduZZ6F6iCYKehJ2zbvZuzb",
    "JDLUTqHaWpMafseJCdnJVZx7SV8BbFCbTvWXkN79k6te",
    "JDSx3w84CjkMfTbMShKXJiYRGFXWGrvuKLGnLBro77Uh",
    "JDmf4HAJwqz1CoheLu9mYhY8CvTjizDFyUCJ9fCuXV1L",
    "JDvBPcLDYDmFisDEuz14w5Y1GCq3uy1gxXAHNGK4dj8F",
    "JDvzDBKKdZRZ2MUcWPtCue9RiQUrydiTMx4Rsc9pppoZ",
    "JEA1JXj6Mvc2X85rT1Vj9tobsGtGXhUAfhTMWygogh9X",
    "JEHeEuyQ2uRLK3dwc7hUhaj4wXmo7Noc5yoZv2Xtosb",
    "JN3efsyqMA1vfPa87hSuPPJEdG9XnyTFsgTP9AprD7d",
    "JYFQduCkkpT8KM9rMhtcG6VSTnx2rcL7UgnhfmevQyL",
    "JYUcgxTZDJfeogrxoD7TNwFbNcr6kDxoVAB55sCRDPA",
    "Jh7415hpPd2fj8d6MtLnQixcA9RisUoFfiJtNeSSjWS",
    "JjWBNVLss3xi58ovkB479xWZb36484fMEumrL9H19Bg",
    "Jpe9i4iR9qY7ZoEvqd1Z8VsoBzMiWX5sfzb7tGKAVEF",
    "JwWJ7T9TJiQaa1fb6tTnwz8Y83FWRK41h5ySD657pDr",
    "K5jP6bHfGEMHHGkbQnnL2Wk5a8TmFhcAjFgTod31J5t",
    "K8B1cRVRhTCeZsg8Qp1jA92Qkqmsc7XGVPtpAgniMNC",
    "KF7gjtBvuS4EHE8jnEBDTK2zX2BrRcqskJpreJxfA23",
    "KLiA4WWndLkCJfCBegdPwPgvaeEkdXK2ddEfuU5DokQ",
    "KQ1ZcrdTZp18yLDENaeRC71s6EqBjPYbxuzNdsBmW2x",
    "KQriHpY9PaN2QF5gNEDPmEhCH7trPEgEu1uvRTW4XR3",
    "KUFy9uDTjoRm3Bt8X1tQQihSNcBJDXKR7fTNY1CM9cL",
    "Kci6kjUKXQrdmzf4M1pEPRDqgoQ2rsFaVaov7zfuCVE",
    "KuV7nHinuDgb8JBBCTQdzX2bAt2tVymWU78mnxqkqaN",
    "KvEjH79Jg9sS8yLQUrcqczXmquRy3HcHZ6nkEn5aDKV",
    "KvZYHfjgJk4zaKWiLBc2dL5zveupniBFbXuokmDfSV6",
    "L1mHgnBx6yqckyR18Kf8NZ7EDgpBRVFKtk2TWrPczr4",
    "L5GSM4uNewnAthHqPQep3hMBhSFiF3JxDKVNgS6sFsV",
    "L5xt1S1WQiGFEpXdPc6qYBKbaeCHJTTyRdSNC22Gv7v",
    "LFAWX2qHYkS7b7HbMZ81PtKvi1S8m98bGMXnJCH1y7h",
    "LYqCFLNwphCAc5BNUXs3cR1PkZHeFE3BB7XYaSMjvkH",
    "LbVETfYiwE9sbUSqhBLDiaCjqTaF9jAHWdcGHjnzEnn",
    "LboaAsfnt6HEN6AP9zgAe1FppNQNHtBJedVHa2c3L9L",
    "MGmMzhsKTtKfEY46rxZhTKsjeu475rnDetEWZ9DT1GM",
    "MZtGw5FtT8yNjNxo2Fmq6yzUxXSJwDibd6Qg6HfbDsa",
    "Md1Twm4Zgh8a8GdvZiCA8HAkUShbkmkbjrKQy1HpbRw",
    "MkcD8HGDcoUK1aJdMRMHmJSRBt6hhEY7Pp7eJnsWDSG",
    "MoJPzsgJPtTCMzBRwYJ4JyRPNSqQ2kbyaPHJJmqLmqP",
    "MpjCVj6YCg22m8YW2dmfH7EzbQh1GtjU7dByKDFkMma",
    "MqFiLQ3SePQWQaJnXZpcjXd8KpnhDff9nqy3V9UZh9Z",
    "N66j5yP9cYyjFmeTZEqx7gUUtDfbZ8fyfz9uVauMHo1",
    "NBx2Xg6WQAiHonfsE5ewyRT28XdxPFGyEhxzRSQmsXs",
    "NEZMXpNkAXU7wWmFLi4aNRCMY7a1yVfsjzNa7R4RMk3",
    "NMGWRSc1pgcmw7rbJcGpVupRnXziRXMGoTkgyE6Tzu4",
    "NMg58hbgqNPds91nsTrPaq6WrPkC6PS8iKJKkRAW8Q3",
    "NSnch5iJH8i5QYtDrFKDuZjKF1h2GQXfs3uGb5o78Uk",
    "NVJxZS5sjHNBSFgEXis4RxgBBoQ2gUg4Gbxk4kouTxe",
    "NeP2UrdSvcHg9a2Sboj95QC9hvR13YNgkqP75pFvynu",
    "Nu7kfRVDSCacxB3joF6o7dpsXhzjFTLgpsHhdWEp9xf",
    "NwXy2aGruHZahNYYdPs4WSxTAaKph4S8A2oxk483UrQ",
    "PFqUVBUwwULdcQiCoNXbNMf8S7rSbKeYMfz6VcCHo7b",
    "PGYEQY6eckcwytTunhTEDChQjMagAmBEtb1GqUJEQW9",
    "PJ1Dh82RoAyvbdJRFikjVnqbbq9BLE7Hp8Ebr1Xp1f2",
    "PSwbzxeYNnK9jNKMttxbscEkLVand5y8hRrGnutskwQ",
    "PUcZzDyitPAHZGe9i8tKyKyKKFEawKpegE9ZxBWJtXg",
    "PjP2mQKJutADbHXJQhRzxjxDP2VZGXYJ2M6U16JQH3k",
    "PmpWCjwrM9ebfx6sgomjTL3r36JVcAAZjAkmGYB1vkn",
    "PmvNJgTFDu47UoiBwDiNGvuqkzkzVbd13QEgyLWuyaK",
    "PwpdTUHbwvb7b3S928HTi1KM28tracQFyteu6MGNKDJ",
    "Q51bEnySmvyxDr9PUEYGXjthCU1Q9rfDDFWeVpD6Pj6",
    "QMmV5pA7vigMZJVHbmhgbrKpmYodJ9DyAVYzk5vj1pN",
    "QP5aiRjCxtQvtRPzmEN5axz9xQ9AUqdp5nt31dUTWur",
    "QZb9GtAJWwrtsoyxF6HGk8rwVcTwYhDXHdv9omC3RQZ",
    "QdG6C1q2Vwmms9RZ7wPaF96DvLRhKBGAw6edUhD91hY",
    "QhL423PKxqPtNqnFcd6nFjT2nMXRaYHeZYZQmW38xJX",
    "R4ekxKSn1qwCSb8twYoLEiXTf6nafAL1X9Hgtwsk6sB",
    "RPbAn4CWdDRTp2hu5YZAZ436Vcfxgus2t9yE89MXi6J",
    "RXCudisMFen742uxsws88Vp42v2CiVdy14LtJoctKE8",
    "RdUGqkJdDSNJUWNNdMbK1Vc1SV6D4L5rBbPrCwm72dh",
    "Rxr7oHfUkGLCJix8etxmdzAv6U3s3oCHKP2ruWYThCn",
    "S3f1e4vDMF8zCPh5syQpVKzgiB8wac8bHizA4rpaokf",
    "SWaeUHvaUEfrmsCi1L61pe5r4GLw7ZktFQihPNcvNAK",
    "SaL7CGGZ2bUprmnyRWT1tpej7cv4RCJrk12u8t4CrsT",
    "SjXYiB5jFKhHDU6DX1ZCBKpayENJ2ESVPQ5121HeN8H",
    "TLvHQyEV12YuRjwcdMTqS5bpFRpm5c47oCQqZkJQLJA",
    "TNSsfkRyibaQtxE6yCnHjiSL2jDGyPxMQGLqQmdAoJj",
    "Tb9WwSkmeU52tWXGtiw82xVn28PGVxFLy5R4XjeZTZ1",
    "TmV3NYbRd56UY76EqSwWQFsYvbwoZuFGmAoQTdj6bcr",
    "TxyfKPF4dfKgy5XzZ6reZBuGUV977BkJnCoG9yyG1eb",
    "U8iCF7kLYbkKdbiH1K7KgExto7ncLbZB8DYhP3yRkMS",
    "UHj8XARZzPMiHnWDEJ7untNN23pGx3EC7iNXKGner3V",
    "UShmB4PRMifcXRcjXHhkk5EVp5DdXEVAfsPCXqp7h2v",
    "UVJPa31Rm6b3V4bL5AiXDdWJpWwKAUjjJyakjt4Fx5v",
    "UnFWyVw4cZ5QLDiEKrGtXHoKxCYj8ybumYR9nFP88Wn",
    "UuD6P3HfAbMqPHvN4XyLWLt5RwTyfXzpV95QQQ5CuoQ",
    "UxZ1jYEQgbmGiWgm2zCP4aSydxZz8Xmqqu8zDGQaVZf",
    "V1RAysg1ryvPBDfYR54BEh4em7hdn4oQBPBZzDCzfYe",
    "V9Xsw6otwJxA2QF1GpuSEDt7rezN4bvAcU795nf35ta",
    "VeawwgC29EqiEXrwKWrpg5HdRRXSDaKnwr1q2HU56Xa",
    "WA7UkXSMURhjgcaddcZEgXoCSgdyoPVpQGsu5zCLrKx",
    "WBqFpXNydPg4TDC7Q6bjPWrvRKY2uyFy7ML31nDhT2S",
    "WCWG2RBiKJ6eFGN51LuNGjpnccr4euAvfae9MwQJAZ2",
    "WcgNCo77nXspkzEsjMNBReLXqvNRkyKgRUCarN3pRCa",
    "WitwrYmNZZT6PhTyDkkLmVbToi1RfwBNdioYyLAVCaa",
    "Wiwst2W2pvi7KSRD3FB5WBKbxFFaKoxdaiWq6wELv91",
    "X4Q1afMQ8XJCTqYcnCy6Bb8t5B1kZ8E43pWjazv8mgd",
    "X7rzi5rHazVFUJDA19ap9DHfbNN3MnHeLq6HCBF3jTa",
    "XCsUD8vfwi4yxhLUtav8pVkxUWFMfP5jdeFwwfk24Rs",
    "XVS8DC6YQN64xpijGKoCMACy5DkcY7PCnChH8PBc8ge",
    "XZgKMP5KsvUxbHGyV6XfwUS9eadBLr1swbtTFR6vcdA",
    "Xm7yLZicgnXabJUNj5J2t5XDoe2upCEcLQSo5pcxWYr",
    "XtFC7b9KSaBuLUcReaWRGQGMb6vbB3Xvoz9KKpxUskn",
    "XyBZdVyF51U7Dr4nH1tZAcduDk662ZfGMubc6iiRRDV",
    "Y3bCtdf1PxugYrbWK1aakJ2FNtw7fuexXApPt4KTe5Z",
    "YSfKeoWQ3LGdN2popoW6sEVw8jH7SuYakXJ4QSkDpUF",
    "YZS9RfxjstwZte2CvSGXokwW42rpB8E8HpR1XHa3VZb",
    "YiTxWZxkNF6ji212EqaFd2U34sw5z3a79zuz774fqjA",
    "Z7QTaZwW4d3vLqWZsF2xmsTTrozMfdnXD7KnLt6k2Fb",
    "Z8joUC1fn62uc5HvtT1PwDEUNvj1LumMG9oWVLxWaeD",
    "Zab1sc2LwmPRMLiVBitTQud7EjD93W618TvHg87SD2J",
    "Zfjh3tupNSVNk5Ad9LwEXFQm4g8eEegKVcfcCNjYkha",
    "ZinBdvd7bcsoXVPPT6sQDkPfhiyFe7DErKTBT6RF3h1",
    "aCin7yroaiwnSuvrP9DXWo9gXEhesjqwjQMNPHBtbPR",
    "aGYivBKowTk8msBKZosnA9JQV6DUxuLVJnxBVw2FPrS",
    "aLR6EMeb5xPzyPHtMjKxpjvEEbpsZvJEJU3m8LKJJeT",
    "aNbJ1eawZBAaGMF8PwNT3QzSpawA1qx8HrqTrMZhEfd",
    "aSXCYRFPhYKGCU4dCgyjSNjppkdSDhaTy6fj5vcGMhc",
    "afhYX9aZ7FwbzgeYMJfzz8sesJGV3nnGvrAFd8Xgjc8",
    "apsdWcUf8NGew8a92DheLWHtMyAsST3Yu6SfzLjjvr3",
    "b9GbA9ibujY3AUiERAze6SdTL4oQwm5mbiV5zhrguUt",
    "bNyMdmwP9jTEghDextiz4CAXqS4SmKE6aR5th9kuFvw",
    "baSYDSRKDkiScUehWLxedrUqKi1LWEqXGYLeCCyXzrz",
    "bfsxWqefSiYg5J8HxPokCdJposAMtKE1aXeAahx5mMR",
    "c6TUwPGTbxNDetMtLPsHThXRfLqcFwF1rDPQVZvt6EV",
    "cApPo5WCdXUVwWkqFqUK4hGKmq2DFjpHcEXfCAY5nGM",
    "cYUzJBg9rXycbKFpR9UUd1cnaorv8BupyQrh6sqkSKc",
    "cvVBDwKtUiJTY34YFM2Dh6L9acpz4rXsrnTG2d1ftbX",
    "d6axFMCfv6bSxoCvkqNnffJoTjFKJpHcgujnpXCPnjb",
    "dG6er9HNnADkuSTec2Ri6B62hUuyTrETcLpnBeF4fTC",
    "dgeqjrogLga7a2LWyAbcdQjAww7C96dRSBoBo46dYUm",
    "dkaCzTZ4bU4dVd3EaAN5osJN9PT2EEeogCZ1GCNCtzD",
    "e1TkK8EJ2bgEXYUGFpwdsXUAbTw77VYZtMkrfjd2iVo",
    "eHvQmjG7xmesSuPBKVGXwmL8yFVcom7472vgPt6qN8y",
    "ePHawcunWMtMU5inbTU2n8bd5BTvpE2rVrincmsEXfo",
    "ePNKsyjyzvsbu3XMcWBdjJ9ycCkopHb5qsbiCa85NFA",
    "eZoL9PRnjLQwLqD9qoD6cWPmLyLKVoruMnnqBxKmamT",
    "efQVVSwCMhDgac3KEVyTZNGEeQvACfQnH1RDm1Ydt2w",
    "enSzhXrmxcogXyr8nQ4SUvt15yDBM5v87jgDeD2QSLe",
    "ewfAiUo9xdkfvc2FWBj7Yzhq878dat4baw2fDK1u3wD",
    "eyhMPd4UVULHaRJ4hcQQrq3juKvjoKR1poADxNtxWT7",
    "fBRS8UWNuAgpZBcpCv3ZzUQ9S6hUKRZdGwU44voBmcd",
    "fK4a4a6EEHQwMTAKTap4UUdBvvTU2j7EHMdTbYq7QQC",
    "fL1dGyoP9uncJL1YStU5r265rKsaMmrEGo3BJnUFEih",
    "fbA4DsXuRC3dfsUtp8Cp3HjDN7ZXf7t7qvmS3mA9syB",
    "fzNYeRfgDh8MSSQzT24kio3ppV1e2Yq1mWPSRnXGsZu",
    "g1AAxgxLPzawgMg8djoxpeRSEBxFVmYYYgAaLjaGZhm",
    "g2QtcKUQiFWi1JUU1imzdYCoEevnQbfdXCVQQJ2tYNG",
    "g5FBzjtg68uusU4wT8YhJQ29DDDPfbrV9S2D79LKzMR",
    "g9huRd7hH2UAw9QQJM1qHzd3mHT6aKwy2DDWuFVehBt",
    "gSvnNoxAKzUnSLQ9XuoN5vVhGC17ibMbgco7J1USnB4",
    "gjsg6TcBEAc2QbALf9imv2YPrEB1dYmnFijCPmd5gRu",
    "gn5fjpsL9J4Vn5NcYJLDB7n1ZAW8fjh4YoR6W7nFmSG",
    "h5UyXP9zUMBdmQGknPaMfV7xkjh5FqYxnHBwX6s8NhA",
    "hR7gVr68JXdS1KSjatUN8nSjb4n2QGDfEo3bXtLaUzz",
    "hVpdEvR2wrZQbcZ442gV8dBtXLr3jvPcpNMBREVdfNH",
    "hjMvpKnAJyxtJn7TJnA5GQfXJK3kN49VB1gaoecVuTq",
    "hnymbJp34eLZLysW59tsK3u4ESQSXasFRpJpGLMVPxV",
    "hoywJsoLusYYHaoNSeS3gPNYg4TW2ez1RyjsdXHhX5H",
    "htjTMqtNyW5ZjXK813x6Rp8UVG8KdKszU3vkPNwFc5i",
    "htrMQuaf1sWQxTz1R4VqwvYiuaSbhRTXrmyrptgHiec",
    "ifUpEHuNKXUb9iGUf3cEmr6XZM3DLKS86viPiH75zzo",
    "ioxwkLrofAtKqmTvbRQz4bNXAFCCxaYNE2o4DtwhhqE",
    "iqaYviFxtS8UModBftFS1LvN8jawyqKZ3BLWpWLrhgW",
    "irM2KyL3SjraiPpumv7nFewfyj4hWiwYbJFhsvMA6aB",
    "iyfD8sQ6C34GutUzPAkuYdwK2kcF8uGmC2Vd7GT9vRE",
    "jAKTwQuWGBgoppNh8SJAQvsA9omKgyzLrQfzijdVBMy",
    "jEXoFxXTr9tRmah8XEcAc8d8u2H1Fog4VhbJ4TMiPmF",
    "jLtwLk3WqQJtuWaCUL9mrf4NHmqiYA6EvL1UYWJ2ouo",
    "jWuSCSrYwRoiGTKnAqXXUnGrzFF74HexpkC5ESD8z4S",
    "jafFkuevjEYEqqpgj6RXd9rLjBHt4gbDJSE4PNuAj9W",
    "jxmcsabLXAvxqAaQ3FuoGi5hBVH98dG4X5vq2R3RZN3",
    "jzf8BBMFiWoZmrJosgnr6Jz8M3U62fHjeFHaMjxHhbT",
    "k734dzqGtsL5VD5h93QainiJcqkGQN3ZGFbikiMZovw",
    "kCyG4HgCjz4U4J3oypr5ehKLjkqXhbc3xd9bYB4hGrS",
    "kPbZZt5mEaSQjUufCo6B1XxJfjYv8oeLEsSUmZgzb5Z",
    "kgXZBc7T8EXrbayUUeQ2owYVX2UxqnybgPXEVne5y1k",
    "knHF6nwQgw8FjHBMrKZ92AhT3HZHhhnezsVaiP6P8H8",
    "kvg6M7woP2SEsbGh7LFHM2gHtMhagQxwpcMnEoNpsJG",
    "m34AmUm4E9aoT7CJwXXqGe5gVGgMeVmcwhck1pgm7tN",
    "m7mB2Z1xyttm4dQq5uhfic7gCott1NadmEPeCQiV1wW",
    "m8cY5NSR2nKF4pku8KVCv8v71itShdfe3WbvKHmPyfU",
    "mAryTMiimBPBP9Y6TSP616qTvBiMqR6hjrnCa2u2zTP",
    "mCVhMpBQs2yog8KxznRhn2EgfKd3gZz5dZKPE8vsTCY",
    "mHh1zcJzYpM1mf9G5GXq9RmJYTrrjZiVjzXTMqMzmTV",
    "mLSYQfA6vyZAp2jL8VmEj4LYorsJZ69EZjFwu3ZozDj",
    "mMGa8Gimv9udjKA4na9VgGVSFkxvLy4Rm9kfkxjC7nh",
    "mWQcdh3jvmVXqnC4tw1TnwLjnifNBjdohPqdLMqUvwk",
    "mjaf8LzRQ9GYBjgX3xUFHs9EVWVnXzeDSpBQAqJMfkK",
    "mjfDdpXtD5SB94eP8DGZfbbfKhwCfsnetq7KUHAcFJV",
    "n3af9JGLhtLWVRixGsf8Ji3fQPvsqjnwugwgEGHRr4D",
    "n6wjQ46UgNvwizw3T5NYpB8TuWVt43yhKHjpAUi7Cm7",
    "n8JBii9rtu2Dn8VGp7PLuJ5ccg5UDwVnoFPDAceHBGh",
    "nBtxicr6xSW7GNzjkBZX3Rke5zom4YVQeczJTWJqknV",
    "nL5112rCbRNrWE8BQsmouB2zyPiacufwUt898xziprQ",
    "nMhuyvnzNNH3FJjHBHjrcMyAe12CRvjJgJ7Z6wvoTzb",
    "nTH9bXnBtRfmBL6pLkPdiBZQ3fpZMcYh36kGJz2iUfB",
    "nZ6H1gNDuwA1sSZ2GKE1zjkpMkDJVtioYVaZauCjZNx",
    "nZsAPNrQGHHCyYUxsxKYHViEnbpSK5SGKSQp3N4DJfp",
    "npi7LegwnvbDosbxnzvfsLj24ydfAckHJ2Pbt8owDk2",
    "nwhEwXddXc3R4kPATqFFKtP6h33jvrFJ85GdtvLofD2",
    "nz4mkqge47SB7rxFX4J5SkXVGZyJqYR13qynmGqGwxw",
    "nz6EM5hNouUk7DFHo2uvFvahN3xqkRQA1Mm8yfhFbXM",
    "oC5VmAqvJBbFDKxMahY3FiJw8vePAcHCaQ9d18eNzBo",
    "oEgCRyBYvfdiF4iBrgAUW7Yj7JF4vUWbwLjthiYx66c",
    "oHCpQEnHaYnD7TXRqJK6CiwBRxWpXnxTwsHdZ23vqHK",
    "oKQ2gkXtFDp8iuoYwt8gmZiU3HXJmADNKRsYrehZ1xQ",
    "oKvtaSX8okYo4T5rJ77hHdtpJ7TqvPZLQbvC7gHvEbC",
    "oQXtqmEPwCaUsR6qJU55vjLb9ggPmjd78CjkzUrzQmm",
    "obEM5GkdzucaGXgiU6KFsY82VURX3PaNsVkk6JCyQUi",
    "ogtZpRepos8CxvfcECtwHHVPpPiKuq5nStwyTzVhWP8",
    "ouoNChthPYt9YXViRp5v3Fktg28BfSTJC1DxvxyPquE",
    "p7UxvXemHNytsFvQJpBEi2iKhujXaX9xcAm6sGnwEG1",
    "pU2hku7Sa14n8nBN49fjw6g5CdthgFTcu635XoCw5Ep",
    "pVso2ZXx11PEewT67m6WYxate1QzeJznnUiXjZKatNR",
    "pZdYGnb631aJpnbvkAmxDfEG5vrkvv4nztEQVpvtDsF",
    "pn81AZ74EXBZ5tvJcaS6Uzg7kqN5skNtye5vR6RapHe",
    "pue2U1oLjcQu4kEUjjkXfL4rskDSxeKYLJTJZPTv5m8",
    "q1WkEjjBtsQNr6ZRZtLxjbaoSdzHw6qVFjiRmD9TXGP",
    "q7BjAr7LC23Dbhi676WTfgMm2QSUp3fAcxYh1dEFCJS",
    "qQ1C9BfW6p37veMM8CgSw3YHdSCbZJMpJVQU8gnKpk3",
    "qVSBneuncPU6TZiGK78cT4A56LWKR9p8eNmr2v4TVS3",
    "qbmCg5MCXjE6APXcV5gVCRrD7Xcg7sSLPQCwPwohee3",
    "r1WVSqz2d1GGxEi7PcaY78UH9nTBwQtmawqaG4t7hka",
    "rEw2eBrboRGhqtF15LttU5dVRfev4oUMuHqGeNQiKfG",
    "rQo5go91RyxBQCZkkQGfRsrD6c92CtZKZ5kMKXhNnDb",
    "rVa1wBm7kYYdFz4hLbqGcPiuc913xhmtLQZUjLcpMBq",
    "rWL6HtU1ccUEqJHVjd44y9sAbam1K5KP79Syw3dN9sh",
    "rYa9v4StADpeMv8f2HZQeFsMgmjnJSRTU7JVB9nYPRd",
    "rfiykAPbB5HQuDki1FjZFJzJeXddkjkrTsQmCzxwgD3",
    "rmG1VJ3196vx6dvE4LKJk6P1r8FfCm1mZyaKygSDJjk",
    "rtMPiq9Nof7f4eqeEhqxTBZukdqXUzAUiYjmtnCdTQj",
    "runVPCEFTdaYEhqEp8m2hRd2FeSmHvMXZ7FNdUpcEAQ",
    "s7pjeoEf84Fz3J9bDC89RobYhiFhZzhpXn7YLDzd1aC",
    "s8dPdpat5e9MdxgpKs95b8b6PPmi77tYzyibya8o7XU",
    "sZ4kGCjpt2ej9MTnig88YRobki2NnESFYcWuhcPpbUr",
    "srLbQkciavniB3XK6SC78s2sYcZHXuFU1yBrQTokQGt",
    "stx15ChMkb1hLKapA338YLNUNnGnxCZXUS69Ghq1bo4",
    "svWQdBFaiQWWsjwL2TBYbEdRU37YsmbGfJawrVA61gu",
    "tCVysmZSiyatcfztakbXxUsgCkRCiKzGQhYpyDxKywp",
    "tNzoZTxhH5eqwEppvyPXJuji5HzuEyrA4RpVZRCMdc2",
    "tfDchWs2GyMJeMgiDHcekoCBWFn1Aywm4XGEyenwttr",
    "tjiXJZwwcwGUhj5M85jzENt7bWTaUanc5jWXtzV3DpW",
    "toJkP5ZTDv3WSYekpmVjqtSYCx14ijsoHxF7gDyF8Zc",
    "tpCCJrPykQJuyVX45snyKpmZ2idRsXrX75zQewn3TWx",
    "twBin1r3yqTxj1mw2j6fXJEiJqKNLdRieYhJpojGv9P",
    "uGtkCwyuqpZ9KBDBz1nBwJLE4ESDQa2LEpbmS16huTq",
    "uJe17YFUoPUvhJd3UoYe8e75KdfQp8ttq6uvM9Toc9S",
    "uKFJjVJNxPXwmMJAmtnExn15CgD9u62NPeBMbKEGpsn",
    "uVTp5ZQhsnpW1JHojEN8LYDmU8sureVFQi3a7zDxeaU",
    "uVv9eygAhY7hC7fQTBGdxUkg9og6WghvEnfVwaBedsT",
    "uW4sxyTYnpMCBNiPwTmJheLyoq1fh9E9ULAmCDCjtvP",
    "udw2LAXPSpj3gaubNp9Rp2M3xmGMU3PstwDtr5iUn8x",
    "ueZESmCsjmdHRQ5L3oyxZtyxNWqVfsQnRDAq81SuMfK",
    "uhMCsojrnmHPTzZXiYEbXUEaLywgCRPxQqJk3WxG2Hf",
    "ujoy69kJPzptb7Dd8RRqbyWkzz6uoLtpYN3PThnSPgR",
    "un5bat95fikzFhj6UGVywa9LEzFt73fYGG75BS6qQ2F",
    "uvVg43AvEb1Whh5pN7F7v3Z7SpY2rXDwaMd3yBWWAzP",
    "vEFqgk7FjreNoY1rjM4yS7EoYkg45xMD6nKHR4VUPi4",
    "vHXz2iJHDZAPTVkTesHLmbqr9shFvXmx5Gnb4Qub4fH",
    "vTe4KTNgZBfBNQwfszNo7wxGtV5yFCCexTmyUFKUqYS",
    "vaxcWfFynXBgBWE6qfgt3mGyXJHxRYJnuBGDNDx5QYG",
    "viS9jZkQa4j4E6yttnEmavyerBUiKkWwnEouZFQUVs8",
    "wCiXJD4zbzFoHJrbxQBjb447zvknrAXMARzL4w7NC1g",
    "wDHoVZbpanApQ66vHD8gAkpNxX2HbYPtN8YjyRqbs8g",
    "wTzdjESAhwnRAZGFZaXsvRCyGVb5xjaXVU5RuWHyC1k",
    "wdJPbo67vVeMkvDVSVq1ZmiFQxVCRP9JGk45pvhZeoc",
    "we8mfNuyAtdQx2drQEa1uR1agNyqRwS24PGizhvFFZP",
    "x3gThpozoRpDND1FAqYQcX5bsCmw8MqCTJNPyhCaRHF",
    "x7WAWMStr3TGCZp55eaf4HarziD1Q8KWKNnHdjytGLh",
    "xFByqFvLZHd1DsXFVc3qb4W9wTkngyMwik63s8Kr8xi",
    "xLdKvgnNnC1WoreXTPDegVWCjZHoYoAF1T7LS3BudYE",
    "xXGbQbrKKEqtz7FpRAXL2wG1cjmjdy1R4Zwacbun7pQ",
    "xcbtkSugSvFKoxhijNYqyePRRzKYSu458tjFedKXWdL",
    "xdWp4eCxkJxMGYt7dPFFTgj7jacwxPbMKw9wX4JheX1",
    "xjkHG1UBTf4ai2ZbNXGqU2S612aJAhdVjnrZf9ERDPa",
    "xvycah4nnUmqtfvVGQEbqKfCHPkTJQCQctChWBGeuPg",
    "y367t4QEiZwXYc1ooQagSR9S36WYXX3HV28aAXNGgCU",
    "yAxoks64LADEhp2AUYFRb79KXMMw3hL7NeKW6RqZTXG",
    "ynj9M71SWHvRDEG2GGKQUMgLNkv19Uo5VeBHoXxjwn4",
    "zMuJ7SZS3JrMvUuXnRSXrVi7y34WgrqTNoLDwyrHLG8",
    "zPY3S6TRtgWXv87LuxTKzxt37FJTKkJpry4izKgiAhV",
    "zWNEG1QrR4uE2p3n4ukowdNaoXwxxfyHEvJFctAXuRF",
    "zwHrQ1RKcLvfy7pkfcNfFkPEkRMZejs4BqKJ8KqYtXn",
    "zxxRCeXjEPdKZMCkZ8eDG9tXVgcQXhv1hRQoagVLMMh",
    "zzTUBPec8wGSNKXf6EgjijGad8eQE3YhJkpkRtCD4yh"
]

},{}],4:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],5:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],6:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],7:[function(require,module,exports){
var toPropertyKey = require("./toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPropertyKey.js":15}],8:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],9:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./setPrototypeOf.js":13}],10:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],11:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var assertThisInitialized = require("./assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./assertThisInitialized.js":4,"./typeof.js":16}],12:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./typeof.js":16}],13:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],14:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./typeof.js":16}],15:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var toPrimitive = require("./toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPrimitive.js":14,"./typeof.js":16}],16:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],17:[function(require,module,exports){
// TODO(Babel 8): Remove this file.

var runtime = require("../helpers/regeneratorRuntime")();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{"../helpers/regeneratorRuntime":12}],18:[function(require,module,exports){
"use strict";
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.curve25519 = exports.getSharedSecret = exports.sync = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;
const nodeCrypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _8n = BigInt(8);
const CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');
const CURVE = Object.freeze({
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
    l: CU_O,
    n: CU_O,
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
});
exports.CURVE = CURVE;
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
const SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
const SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
class ExtendedPoint {
    constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('ExtendedPoint#fromAffine: expected Point');
        }
        if (p.equals(Point.ZERO))
            return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
    }
    equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod(X1 * Z2);
        const X2Z1 = mod(X2 * Z1);
        const Y1Z2 = mod(Y1 * Z2);
        const Y2Z1 = mod(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    negate() {
        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(_2n * mod(Z1 * Z1));
        const D = mod(a * A);
        const x1y1 = X1 + Y1;
        const E = mod(mod(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod(E * F);
        const Y3 = mod(G * H);
        const T3 = mod(E * H);
        const Z3 = mod(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod((Y1 - X1) * (Y2 + X2));
        const B = mod((Y1 + X1) * (Y2 - X2));
        const F = mod(B - A);
        if (F === _0n)
            return this.double();
        const C = mod(Z1 * _2n * T2);
        const D = mod(T1 * _2n * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod(E * F);
        const Y3 = mod(G * H);
        const T3 = mod(E * H);
        const Z3 = mod(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE))
            affinePoint = Point.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = ExtendedPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = ExtendedPoint.ZERO;
        let f = ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            }
            else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
        }
        return ExtendedPoint.normalizeZ([p, f])[0];
    }
    multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
    }
    multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n)
            return P0;
        if (this.equals(P0) || n === _1n)
            return this;
        if (this.equals(G))
            return this.wNAF(n);
        let p = P0;
        let d = this;
        while (n > _0n) {
            if (n & _1n)
                p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n)
            p = p.add(this);
        return p.equals(ExtendedPoint.ZERO);
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(ExtendedPoint.ZERO);
        if (invZ == null)
            invZ = is0 ? _8n : invert(z);
        const ax = mod(x * invZ);
        const ay = mod(y * invZ);
        const zz = mod(z * invZ);
        if (is0)
            return Point.ZERO;
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
    fromRistrettoBytes() {
        legacyRist();
    }
    toRistrettoBytes() {
        legacyRist();
    }
    fromRistrettoHash() {
        legacyRist();
    }
}
exports.ExtendedPoint = ExtendedPoint;
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
function assertExtPoint(other) {
    if (!(other instanceof ExtendedPoint))
        throw new TypeError('ExtendedPoint expected');
}
function assertRstPoint(other) {
    if (!(other instanceof RistrettoPoint))
        throw new TypeError('RistrettoPoint expected');
}
function legacyRist() {
    throw new Error('Legacy method: switch to RistrettoPoint');
}
class RistrettoPoint {
    constructor(ep) {
        this.ep = ep;
    }
    static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!edIsNegative(s_))
            s_ = mod(-s_);
        if (!Ns_D_is_sq)
            s = s_;
        if (!Ns_D_is_sq)
            c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
    }
    static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
            throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if (edIsNegative(x))
            x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || edIsNegative(t) || y === _0n)
            throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
    }
    toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2;
        }
        if (edIsNegative(x * zInv))
            y = mod(-y);
        let s = mod((z - y) * D);
        if (edIsNegative(s))
            s = mod(-s);
        return numberTo32BytesLE(s);
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod(a.x * b.y) === mod(a.y * b.x);
        const two = mod(a.y * b.y) === mod(a.x * b.x);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
    }
}
exports.RistrettoPoint = RistrettoPoint;
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~0x80;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
            throw new Error('Expected 0 < hex < P');
        if (!strict && y >= POW_2_256)
            throw new Error('Expected 0 < hex < 2**256');
        const y2 = mod(y * y);
        const u = mod(y2 - _1n);
        const v = mod(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
            throw new Error('Point.fromHex: invalid y coordinate');
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 0x80) !== 0;
        if (isLastByteOdd !== isXOdd) {
            x = mod(-x);
        }
        return new Point(x, y);
    }
    static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
    }
    toRawBytes() {
        const bytes = numberTo32BytesLE(this.y);
        bytes[31] |= this.x & _1n ? 0x80 : 0;
        return bytes;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toX25519() {
        const { y } = this;
        const u = mod((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
    }
    isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(mod(-this.x), this.y);
    }
    add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
}
exports.Point = Point;
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes.slice(0, 32), false);
        const s = bytesToNumberLE(bytes.slice(32, 64));
        return new Signature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point))
            throw new Error('Expected Point instance');
        normalizeScalar(s, CURVE.l, false);
        return this;
    }
    toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
}
exports.Signature = Signature;
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Expected Uint8Array list');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function numberTo32BytesBE(num) {
    const length = 32;
    const hex = num.toString(16).padStart(length * 2, '0');
    return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
    return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
    return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function bytes255ToNumberLE(bytes) {
    return mod(bytesToNumberLE(bytes) & MAX_255B);
}
function mod(a, b = CURVE.P) {
    const res = a % b;
    return res >= _0n ? res : b + res;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
            return acc;
        tmp[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n)
            return acc;
        tmp[i] = mod(acc * tmp[i], p);
        return mod(acc * num, p);
    }, inverted);
    return tmp;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= P;
    }
    return res;
}
function pow_2_252_3(x) {
    const { P } = CURVE;
    const _5n = BigInt(5);
    const _10n = BigInt(10);
    const _20n = BigInt(20);
    const _40n = BigInt(40);
    const _80n = BigInt(80);
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P;
    const b4 = (pow2(b2, _2n) * b2) % P;
    const b5 = (pow2(b4, _1n) * x) % P;
    const b10 = (pow2(b5, _5n) * b5) % P;
    const b20 = (pow2(b10, _10n) * b10) % P;
    const b40 = (pow2(b20, _20n) * b20) % P;
    const b80 = (pow2(b40, _40n) * b40) % P;
    const b160 = (pow2(b80, _80n) * b80) % P;
    const b240 = (pow2(b160, _80n) * b80) % P;
    const b250 = (pow2(b240, _10n) * b10) % P;
    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;
    return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
    const v3 = mod(v * v * v);
    const v7 = mod(v3 * v3 * v);
    const pow = pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow);
    const vx2 = mod(v * x * x);
    const root1 = x;
    const root2 = mod(x * SQRT_M1);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u);
    const noRoot = vx2 === mod(-u * SQRT_M1);
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2;
    if (edIsNegative(x))
        x = mod(-x);
    return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number) {
    return uvRatio(_1n, number);
}
function modlLE(hash) {
    return mod(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    for (let i = 0; i < b1.length; i++) {
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}
function ensureBytes(hex, expectedLength) {
    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)
        throw new Error(`Expected ${expectedLength} bytes`);
    return bytes;
}
function normalizeScalar(num, max, strict = true) {
    if (!max)
        throw new TypeError('Specify max value');
    if (typeof num === 'number' && Number.isSafeInteger(num))
        num = BigInt(num);
    if (typeof num === 'bigint' && num < max) {
        if (strict) {
            if (_0n < num)
                return num;
        }
        else {
            if (_0n <= num)
                return num;
        }
    }
    throw new TypeError('Expected valid scalar: 0 < scalar < max');
}
function adjustBytes25519(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
}
function decodeScalar25519(n) {
    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
}
function checkPrivateKey(key) {
    key =
        typeof key === 'bigint' || typeof key === 'number'
            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))
            : ensureBytes(key);
    if (key.length !== 32)
        throw new Error(`Expected 32 bytes`);
    return key;
}
function getKeyFromHash(hashed) {
    const head = adjustBytes25519(hashed.slice(0, 32));
    const prefix = hashed.slice(32, 64);
    const scalar = modlLE(head);
    const point = Point.BASE.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
}
let _sha512Sync;
function sha512s(...m) {
    if (typeof _sha512Sync !== 'function')
        throw new Error('utils.sha512Sync must be set to use sync methods');
    return _sha512Sync(...m);
}
async function getExtendedPublicKey(key) {
    return getKeyFromHash(await exports.utils.sha512(checkPrivateKey(key)));
}
function getExtendedPublicKeySync(key) {
    return getKeyFromHash(sha512s(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).pointBytes;
}
exports.getPublicKey = getPublicKey;
function getPublicKeySync(privateKey) {
    return getExtendedPublicKeySync(privateKey).pointBytes;
}
async function sign(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
    const r = modlLE(await exports.utils.sha512(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(await exports.utils.sha512(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
exports.sign = sign;
function signSync(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
    const r = modlLE(sha512s(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey) {
    message = ensureBytes(message);
    if (!(publicKey instanceof Point))
        publicKey = Point.fromHex(publicKey, false);
    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
    return { r, s, SB, pub: publicKey, msg: message };
}
function finishVerification(publicKey, r, SB, hashed) {
    const k = modlLE(hashed);
    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    const RkA = ExtendedPoint.fromAffine(r).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = await exports.utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
exports.verify = verify;
function verifySync(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
exports.sync = {
    getExtendedPublicKey: getExtendedPublicKeySync,
    getPublicKey: getPublicKeySync,
    sign: signSync,
    verify: verifySync,
};
async function getSharedSecret(privateKey, publicKey) {
    const { head } = await getExtendedPublicKey(privateKey);
    const u = Point.fromHex(publicKey).toX25519();
    return exports.curve25519.scalarMult(head, u);
}
exports.getSharedSecret = getSharedSecret;
Point.BASE._setWindowSize(8);
function cswap(swap, x_2, x_3) {
    const dummy = mod(swap * (x_2 - x_3));
    x_2 = mod(x_2 - dummy);
    x_3 = mod(x_3 + dummy);
    return [x_2, x_3];
}
function montgomeryLadder(pointU, scalar) {
    const { P } = CURVE;
    const u = normalizeScalar(pointU, P);
    const k = normalizeScalar(scalar, P);
    const a24 = BigInt(121665);
    const x_1 = u;
    let x_2 = _1n;
    let z_2 = _0n;
    let x_3 = u;
    let z_3 = _1n;
    let swap = _0n;
    let sw;
    for (let t = BigInt(255 - 1); t >= _0n; t--) {
        const k_t = (k >> t) & _1n;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = mod(A * A);
        const B = x_2 - z_2;
        const BB = mod(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = mod(D * A);
        const CB = mod(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = mod(dacb * dacb);
        z_3 = mod(x_1 * mod(da_cb * da_cb));
        x_2 = mod(AA * BB);
        z_2 = mod(E * (AA + mod(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);
    return mod(x_2 * xp2);
}
function encodeUCoordinate(u) {
    return numberTo32BytesLE(mod(u, CURVE.P));
}
function decodeUCoordinate(uEnc) {
    const u = ensureBytes(uEnc, 32);
    u[31] &= 127;
    return bytesToNumberLE(u);
}
exports.curve25519 = {
    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',
    scalarMult(privateKey, publicKey) {
        const u = decodeUCoordinate(publicKey);
        const p = decodeScalar25519(privateKey);
        const pu = montgomeryLadder(u, p);
        if (pu === _0n)
            throw new Error('Invalid private or public key received');
        return encodeUCoordinate(pu);
    },
    scalarMultBase(privateKey) {
        return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);
    },
};
const crypto = {
    node: nodeCrypto,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
exports.utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    getExtendedPublicKey,
    mod,
    invert,
    TORSION_SUBGROUP: [
        '0100000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
        '0000000000000000000000000000000000000000000000000000000000000080',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
        '0000000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
    ],
    hashToPrivateScalar: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
    },
    randomBytes: (bytesLength = 32) => {
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => {
        return exports.utils.randomBytes(32);
    },
    sha512: async (...messages) => {
        const message = concatBytes(...messages);
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());
        }
        else {
            throw new Error("The environment doesn't have sha512 function");
        }
    },
    precompute(windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
    },
    sha512Sync: undefined,
};
Object.defineProperties(exports.utils, {
    sha512Sync: {
        configurable: false,
        get() {
            return _sha512Sync;
        },
        set(val) {
            if (!_sha512Sync)
                _sha512Sync = val;
        },
    },
});

},{"crypto":60}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

},{"./_assert.js":19,"./utils.js":27}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

},{}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new TypeError('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);

},{"./_assert.js":19,"./utils.js":27}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());

},{"./_sha2.js":20,"./utils.js":27}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

},{"./_assert.js":19,"./_u64.js":21,"./utils.js":27}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());

},{"./_sha2.js":20,"./_u64.js":21,"./utils.js":27}],27:[function(require,module,exports){
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

},{"@noble/hashes/crypto":22}],28:[function(require,module,exports){
"use strict";
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
const nodeCrypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const CURVE = Object.freeze({
    a: _0n,
    b: BigInt(7),
    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: _1n,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
});
exports.CURVE = CURVE;
const divNearest = (a, b) => (a + b / _2n) / b;
const endo = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar(k) {
        const { n } = CURVE;
        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
        const b2 = a1;
        const POW_2_128 = BigInt('0x100000000000000000000000000000000');
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
            k1 = n - k1;
        if (k2neg)
            k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
        }
        return { k1neg, k1, k2neg, k2 };
    },
};
const fieldLen = 32;
const groupLen = 32;
const hashLen = 32;
const compressedLen = fieldLen + 1;
const uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class ShaError extends Error {
    constructor(message) {
        super(message);
    }
}
function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint))
        throw new TypeError('JacobianPoint expected');
}
class JacobianPoint {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }
        if (p.equals(Point.ZERO))
            return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(B * B);
        const x1b = X1 + B;
        const D = mod(_2n * (mod(x1b * x1b) - A - C));
        const E = mod(_3n * A);
        const F = mod(E * E);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
            return this;
        if (X1 === _0n || Y1 === _0n)
            return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) {
                return this.double();
            }
            else {
                return JacobianPoint.ZERO;
            }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n)
            return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
            return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
                k1p = k1p.add(d);
            if (k2 & _1n)
                k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg)
            k1p = k1p.negate();
        if (k2neg)
            k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            }
            else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
        }
        return { p, f };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            k1p = constTimeNegate(k1neg, k1p);
            k2p = constTimeNegate(k2neg, k2p);
            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        }
        else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null)
            invZ = is0 ? _8n : invert(z);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (is0)
            return Point.ZERO;
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    hasEvenY() {
        return this.y % _2n === _0n;
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
            throw new Error('Point is not on curve');
        const y2 = weierstrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd)
                y = mod(-y);
        }
        else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
                y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen)
            return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 0x02 || header === 0x03)) {
            return this.fromCompressedHex(bytes);
        }
        if (len === uncompressedLen && header === 0x04)
            return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        const { r, s } = normalizeSignature(signature);
        if (![0, 1, 2, 3].includes(recovery))
            throw new Error('Cannot recover: invalid recovery bit');
        const h = truncateHash(ensureBytes(msgHash));
        const { n } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert(radj, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const prefix = recovery & 1 ? '03' : '02';
        const R = Point.fromHex(prefix + numTo32bStr(radj));
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
            throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.hasEvenY() ? '02' : '03';
            return `${prefix}${x}`;
        }
        else {
            return `04${x}${numTo32bStr(this.y)}`;
        }
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = 'Point is not on elliptic curve';
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
            throw new Error(msg);
        const left = mod(y * y);
        const right = weierstrass(x);
        if (mod(left - right) !== _0n)
            throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
exports.Point = Point;
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0x00 && res[1] <= 0x7f) {
        throw new Error('Invalid signature integer: trailing length');
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
        throw new Error('Invalid signature: incorrect length');
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
}
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
            throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
            throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s))
            throw new Error('Invalid Signature: s must be 0 < s < n');
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
        return hexToBytes(this.toDERHex());
    }
    toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
exports.Signature = Signature;
function concatBytes(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function numTo32bStr(num) {
    if (typeof num !== 'bigint')
        throw new Error('Expected bigint');
    if (!(_0n <= num && num < POW_2_256))
        throw new Error('Expected number 0 <= n < 2^256');
    return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32)
        throw new Error('Error: expected 32 bytes');
    return b;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
    }
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num))
        return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = (x * x * x) % P;
    const b3 = (b2 * b2 * x) % P;
    const b6 = (pow2(b3, _3n) * b3) % P;
    const b9 = (pow2(b6, _3n) * b3) % P;
    const b11 = (pow2(b9, _2n) * b2) % P;
    const b22 = (pow2(b11, _11n) * b11) % P;
    const b44 = (pow2(b22, _22n) * b22) % P;
    const b88 = (pow2(b44, _44n) * b44) % P;
    const b176 = (pow2(b88, _88n) * b88) % P;
    const b220 = (pow2(b176, _44n) * b44) % P;
    const b223 = (pow2(b220, _3n) * b3) % P;
    const t1 = (pow2(b223, _23n) * b22) % P;
    const t2 = (pow2(t1, _6n) * b2) % P;
    const rt = pow2(t2, _2n);
    const xc = (rt * rt) % P;
    if (xc !== x)
        throw new Error('Cannot find square root');
    return rt;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
function bits2int_2(bytes) {
    const delta = bytes.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes);
    return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash, truncateOnly = false) {
    const h = bits2int_2(hash);
    if (truncateOnly)
        return h;
    const { n } = CURVE;
    return h >= n ? h - n : h;
}
let _sha256Sync;
let _hmacSha256Sync;
class HmacDrbg {
    constructor(hashLen, qByteLen) {
        this.hashLen = hashLen;
        this.qByteLen = qByteLen;
        if (typeof hashLen !== 'number' || hashLen < 2)
            throw new Error('hashLen must be a number');
        if (typeof qByteLen !== 'number' || qByteLen < 2)
            throw new Error('qByteLen must be a number');
        this.v = new Uint8Array(hashLen).fill(1);
        this.k = new Uint8Array(hashLen).fill(0);
        this.counter = 0;
    }
    hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
        if (typeof _hmacSha256Sync !== 'function')
            throw new ShaError('hmacSha256Sync needs to be set');
    }
    incr() {
        if (this.counter >= 1000)
            throw new Error('Tried 1,000 k values for sign(), all were invalid');
        this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
            return;
        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
        this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
            return;
        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
        this.v = this.hmacSync(this.v);
    }
    async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
            this.v = await this.hmac(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
    generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
            this.v = this.hmacSync(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k))
        return;
    const kinv = invert(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n)
        return;
    const s = mod(kinv * mod(m + d * r, n), n);
    if (s === _0n)
        return;
    let sig = new Signature(r, s);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
    }
    return { sig, recovery };
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
    }
    else if (typeof key === 'string') {
        if (key.length !== 2 * groupLen)
            throw new Error('Expected 32 bytes of private key');
        num = hexToNumber(key);
    }
    else if (key instanceof Uint8Array) {
        if (key.length !== groupLen)
            throw new Error('Expected 32 bytes of private key');
        num = bytesToNumber(key);
    }
    else {
        throw new TypeError('Expected valid private key');
    }
    if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    return num;
}
function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
    }
    else {
        return Point.fromHex(publicKey);
    }
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    }
    catch (error) {
        return Signature.fromCompact(signature);
    }
}
function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
exports.getPublicKey = getPublicKey;
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
exports.recoverPublicKey = recoverPublicKey;
function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === 'string';
    const len = (arr || str) && item.length;
    if (arr)
        return len === compressedLen || len === uncompressedLen;
    if (str)
        return len === compressedLen * 2 || len === uncompressedLen * 2;
    if (item instanceof Point)
        return true;
    return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isProbPub(privateA))
        throw new TypeError('getSharedSecret: first arg must be private key');
    if (!isProbPub(publicB))
        throw new TypeError('getSharedSecret: second arg must be public key');
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
exports.getSharedSecret = getSharedSecret;
function bits2int(bytes) {
    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
    return bytesToNumber(slice);
}
function bits2octets(bytes) {
    const z1 = bits2int(bytes);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
    return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d), bits2octets(h1)];
    if (extraEntropy != null) {
        if (extraEntropy === true)
            extraEntropy = exports.utils.randomBytes(fieldLen);
        const e = ensureBytes(extraEntropy);
        if (e.length !== fieldLen)
            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return { seed, m, d };
}
function finalizeSig(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    await drbg.reseed(seed);
    let sig;
    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
        await drbg.reseed();
    return finalizeSig(sig, opts);
}
exports.sign = sign;
function signSync(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    drbg.reseedSync(seed);
    let sig;
    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
        drbg.reseedSync();
    return finalizeSig(sig, opts);
}
exports.signSync = signSync;
const vopts = { strict: true };
function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
    }
    catch (error) {
        return false;
    }
    const { r, s } = sig;
    if (opts.strict && sig.hasHighS())
        return false;
    const h = truncateHash(msgHash);
    let P;
    try {
        P = normalizePublicKey(publicKey);
    }
    catch (error) {
        return false;
    }
    const { n } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R)
        return false;
    const v = mod(R.x, n);
    return v === r;
}
exports.verify = verify;
function schnorrChallengeFinalize(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
}
class SchnorrSignature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
            throw new Error('Invalid signature');
    }
    toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
        return hexToBytes(this.toHex());
    }
}
function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
}
class InternalSchnorrSignature {
    constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
        if (message == null)
            throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32)
            throw new TypeError('sign: Expected 32 bytes of aux randomness');
    }
    getScalar(priv) {
        const point = Point.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return { point, scalar, x: point.toRawX() };
    }
    initNonce(d, t0h) {
        return numTo32b(d ^ bytesToNumber(t0h));
    }
    finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n)
            throw new Error('sign: Creation of signature failed. k is zero');
        const { point: R, x: rx, scalar: k } = this.getScalar(k0);
        return { R, rx, k };
    }
    finalizeSig(R, k, e, d) {
        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
    error() {
        throw new Error('sign: Invalid signature produced');
    }
    async calc() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHash;
        const t = this.initNonce(d, await tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!(await schnorrVerify(sig, m, px)))
            this.error();
        return sig;
    }
    calcSync() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHashSync;
        const t = this.initNonce(d, tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!schnorrVerifySync(sig, m, px))
            this.error();
        return sig;
    }
}
async function schnorrSign(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
}
function schnorrSignSync(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
}
function initSchnorrVerify(signature, message, publicKey) {
    const raw = signature instanceof SchnorrSignature;
    const sig = raw ? signature : SchnorrSignature.fromHex(signature);
    if (raw)
        sig.assertValidity();
    return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey),
    };
}
function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !R.hasEvenY() || R.x !== r)
        return false;
    return true;
}
async function schnorrVerify(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        return false;
    }
}
function schnorrVerifySync(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        if (error instanceof ShaError)
            throw error;
        return false;
    }
}
exports.schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync,
};
Point.BASE._setWindowSize(8);
const crypto = {
    node: nodeCrypto,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
const TAGS = {
    challenge: 'BIP0340/challenge',
    aux: 'BIP0340/aux',
    nonce: 'BIP0340/nonce',
};
const TAGGED_HASH_PREFIXES = {};
exports.utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey(privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        }
        catch (error) {
            return false;
        }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) {
            throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
    precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    },
    sha256: async (...messages) => {
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHash } = crypto.node;
            const hash = createHash('sha256');
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have sha256 function");
        }
    },
    hmacSha256: async (key, ...messages) => {
        if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHmac } = crypto.node;
            const hash = createHmac('sha256', key);
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have hmac-sha256 function");
        }
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== 'function')
            throw new ShaError('sha256Sync is undefined, you need to set it');
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
    },
    _JacobianPoint: JacobianPoint,
};
Object.defineProperties(exports.utils, {
    sha256Sync: {
        configurable: false,
        get() {
            return _sha256Sync;
        },
        set(val) {
            if (!_sha256Sync)
                _sha256Sync = val;
        },
    },
    hmacSha256Sync: {
        configurable: false,
        get() {
            return _hmacSha256Sync;
        },
        set(val) {
            if (!_hmacSha256Sync)
                _hmacSha256Sync = val;
        },
    },
});

},{"crypto":60}],29:[function(require,module,exports){
/* The MIT License (MIT)
 *
 * Copyright 2015-2018 Peter A. Bigot
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
const buffer_1 = require("buffer");
/* Check if a value is a Uint8Array.
 *
 * @ignore */
function checkUint8Array(b) {
    if (!(b instanceof Uint8Array)) {
        throw new TypeError('b must be a Uint8Array');
    }
}
exports.checkUint8Array = checkUint8Array;
/* Create a Buffer instance from a Uint8Array.
 *
 * @ignore */
function uint8ArrayToBuffer(b) {
    checkUint8Array(b);
    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
}
exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
/**
 * Base class for layout objects.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support the {@link
 * Layout#encode|encode} or {@link Layout#decode|decode} functions.
 *
 * @param {Number} span - Initializer for {@link Layout#span|span}.  The
 * parameter must be an integer; a negative value signifies that the
 * span is {@link Layout#getSpan|value-specific}.
 *
 * @param {string} [property] - Initializer for {@link
 * Layout#property|property}.
 *
 * @abstract
 */
class Layout {
    constructor(span, property) {
        if (!Number.isInteger(span)) {
            throw new TypeError('span must be an integer');
        }
        /** The span of the layout in bytes.
         *
         * Positive values are generally expected.
         *
         * Zero will only appear in {@link Constant}s and in {@link
         * Sequence}s where the {@link Sequence#count|count} is zero.
         *
         * A negative value indicates that the span is value-specific, and
         * must be obtained using {@link Layout#getSpan|getSpan}. */
        this.span = span;
        /** The property name used when this layout is represented in an
         * Object.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances.  If left undefined the span of the unnamed layout will
         * be treated as padding: it will not be mutated by {@link
         * Layout#encode|encode} nor represented as a property in the
         * decoded Object. */
        this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */
    makeDestinationObject() {
        return {};
    }
    /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Uint8Array} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */
    getSpan(b, offset) {
        if (0 > this.span) {
            throw new RangeError('indeterminate span');
        }
        return this.span;
    }
    /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */
    replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
    }
    /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */
    fromArray(values) {
        return undefined;
    }
}
exports.Layout = Layout;
/* Provide text that carries a name (such as for a function that will
 * be throwing an error) annotated with the property of a given layout
 * (such as one for which the value was unacceptable).
 *
 * @ignore */
function nameWithProperty(name, lo) {
    if (lo.property) {
        return name + '[' + lo.property + ']';
    }
    return name;
}
exports.nameWithProperty = nameWithProperty;
/**
 * Augment a class so that instances can be encoded/decoded using a
 * given layout.
 *
 * Calling this function couples `Class` with `layout` in several ways:
 *
 * * `Class.layout_` becomes a static member property equal to `layout`;
 * * `layout.boundConstructor_` becomes a static member property equal
 *    to `Class`;
 * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
 *   property of `layout` is set to a function that returns a `new
 *   Class()`;
 * * `Class.decode(b, offset)` becomes a static member function that
 *   delegates to {@link Layout#decode|layout.decode}.  The
 *   synthesized function may be captured and extended.
 * * `Class.prototype.encode(b, offset)` provides an instance member
 *   function that delegates to {@link Layout#encode|layout.encode}
 *   with `src` set to `this`.  The synthesized function may be
 *   captured and extended, but when the extension is invoked `this`
 *   must be explicitly bound to the instance.
 *
 * @param {class} Class - a JavaScript class with a nullary
 * constructor.
 *
 * @param {Layout} layout - the {@link Layout} instance used to encode
 * instances of `Class`.
 */
// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function bindConstructorLayout(Class, layout) {
    if ('function' !== typeof Class) {
        throw new TypeError('Class must be constructor');
    }
    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {
        throw new Error('Class is already bound to a layout');
    }
    if (!(layout && (layout instanceof Layout))) {
        throw new TypeError('layout must be a Layout');
    }
    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {
        throw new Error('layout is already bound to a constructor');
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = (() => new Class());
    Object.defineProperty(Class.prototype, 'encode', {
        value(b, offset) {
            return layout.encode(this, b, offset);
        },
        writable: true,
    });
    Object.defineProperty(Class, 'decode', {
        value(b, offset) {
            return layout.decode(b, offset);
        },
        writable: true,
    });
}
exports.bindConstructorLayout = bindConstructorLayout;
/**
 * An object that behaves like a layout but does not consume space
 * within its containing layout.
 *
 * This is primarily used to obtain metadata about a member, such as a
 * {@link OffsetLayout} that can provide data about a {@link
 * Layout#getSpan|value-specific span}.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support {@link
 * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @abstract
 * @augments {Layout}
 */
class ExternalLayout extends Layout {
    /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */
    isCount() {
        throw new Error('ExternalLayout is abstract');
    }
}
exports.ExternalLayout = ExternalLayout;
/**
 * An {@link ExternalLayout} that determines its {@link
 * Layout#decode|value} based on offset into and length of the buffer
 * on which it is invoked.
 *
 * *Factory*: {@link module:Layout.greedy|greedy}
 *
 * @param {Number} [elementSpan] - initializer for {@link
 * GreedyCount#elementSpan|elementSpan}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {ExternalLayout}
 */
class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
        if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {
            throw new TypeError('elementSpan must be a (positive) integer');
        }
        super(-1, property);
        /** The layout for individual elements of the sequence.  The value
         * must be a positive integer.  If not provided, the value will be
         * 1. */
        this.elementSpan = elementSpan;
    }
    /** @override */
    isCount() {
        return true;
    }
    /** @override */
    decode(b, offset = 0) {
        checkUint8Array(b);
        const rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
    }
    /** @override */
    encode(src, b, offset) {
        return 0;
    }
}
exports.GreedyCount = GreedyCount;
/**
 * An {@link ExternalLayout} that supports accessing a {@link Layout}
 * at a fixed offset from the start of another Layout.  The offset may
 * be before, within, or after the base layout.
 *
 * *Factory*: {@link module:Layout.offset|offset}
 *
 * @param {Layout} layout - initializer for {@link
 * OffsetLayout#layout|layout}, modulo `property`.
 *
 * @param {Number} [offset] - Initializes {@link
 * OffsetLayout#offset|offset}.  Defaults to zero.
 *
 * @param {string} [property] - Optional new property name for a
 * {@link Layout#replicate| replica} of `layout` to be used as {@link
 * OffsetLayout#layout|layout}.  If not provided the `layout` is used
 * unchanged.
 *
 * @augments {Layout}
 */
class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property) {
        if (!(layout instanceof Layout)) {
            throw new TypeError('layout must be a Layout');
        }
        if (!Number.isInteger(offset)) {
            throw new TypeError('offset must be integer or undefined');
        }
        super(layout.span, property || layout.property);
        /** The subordinated layout. */
        this.layout = layout;
        /** The location of {@link OffsetLayout#layout} relative to the
         * start of another layout.
         *
         * The value may be positive or negative, but an error will thrown
         * if at the point of use it goes outside the span of the Uint8Array
         * being accessed.  */
        this.offset = offset;
    }
    /** @override */
    isCount() {
        return ((this.layout instanceof UInt)
            || (this.layout instanceof UIntBE));
    }
    /** @override */
    decode(b, offset = 0) {
        return this.layout.decode(b, offset + this.offset);
    }
    /** @override */
    encode(src, b, offset = 0) {
        return this.layout.encode(src, b, offset + this.offset);
    }
}
exports.OffsetLayout = OffsetLayout;
/**
 * Represent an unsigned integer in little-endian format.
 *
 * *Factory*: {@link module:Layout.u8|u8}, {@link
 *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
 *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
 *  module:Layout.u48|u48}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class UInt extends Layout {
    constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
            throw new RangeError('span must not exceed 6 bytes');
        }
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
        return this.span;
    }
}
exports.UInt = UInt;
/**
 * Represent an unsigned integer in big-endian format.
 *
 * *Factory*: {@link module:Layout.u8be|u8be}, {@link
 * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
 * {@link module:Layout.u32be|u32be}, {@link
 * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class UIntBE extends Layout {
    constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
            throw new RangeError('span must not exceed 6 bytes');
        }
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
        return this.span;
    }
}
exports.UIntBE = UIntBE;
/**
 * Represent a signed integer in little-endian format.
 *
 * *Factory*: {@link module:Layout.s8|s8}, {@link
 *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
 *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
 *  module:Layout.s48|s48}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Int extends Layout {
    constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
            throw new RangeError('span must not exceed 6 bytes');
        }
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
        return this.span;
    }
}
exports.Int = Int;
/**
 * Represent a signed integer in big-endian format.
 *
 * *Factory*: {@link module:Layout.s8be|s8be}, {@link
 * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
 * {@link module:Layout.s32be|s32be}, {@link
 * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
 *
 * @param {Number} span - initializer for {@link Layout#span|span}.
 * The parameter can range from 1 through 6.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class IntBE extends Layout {
    constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
            throw new RangeError('span must not exceed 6 bytes');
        }
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
        return this.span;
    }
}
exports.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
/* True modulus high and low 32-bit words, where low word is always
 * non-negative. */
function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - (hi32 * V2E32);
    return { hi32, lo32 };
}
/* Reconstruct Number from quotient and non-negative remainder */
function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
}
/**
 * Represent an unsigned 64-bit integer in little-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.nu64|nu64}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */
class NearUInt64 extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeUInt32LE(split.hi32, offset + 4);
        return 8;
    }
}
exports.NearUInt64 = NearUInt64;
/**
 * Represent an unsigned 64-bit integer in big-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.nu64be|nu64be}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */
class NearUInt64BE extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
    }
}
exports.NearUInt64BE = NearUInt64BE;
/**
 * Represent a signed 64-bit integer in little-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.ns64|ns64}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */
class NearInt64 extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset);
        const hi32 = buffer.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeInt32LE(split.hi32, offset + 4);
        return 8;
    }
}
exports.NearInt64 = NearInt64;
/**
 * Represent a signed 64-bit integer in big-endian format when
 * encoded and as a near integral JavaScript Number when decoded.
 *
 * *Factory*: {@link module:Layout.ns64be|ns64be}
 *
 * **NOTE** Values with magnitude greater than 2^52 may not decode to
 * the exact value of the encoded representation.
 *
 * @augments {Layout}
 */
class NearInt64BE extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset);
        const lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
    }
}
exports.NearInt64BE = NearInt64BE;
/**
 * Represent a 32-bit floating point number in little-endian format.
 *
 * *Factory*: {@link module:Layout.f32|f32}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Float extends Layout {
    constructor(property) {
        super(4, property);
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src, offset);
        return 4;
    }
}
exports.Float = Float;
/**
 * Represent a 32-bit floating point number in big-endian format.
 *
 * *Factory*: {@link module:Layout.f32be|f32be}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class FloatBE extends Layout {
    constructor(property) {
        super(4, property);
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src, offset);
        return 4;
    }
}
exports.FloatBE = FloatBE;
/**
 * Represent a 64-bit floating point number in little-endian format.
 *
 * *Factory*: {@link module:Layout.f64|f64}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Double extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
        return 8;
    }
}
exports.Double = Double;
/**
 * Represent a 64-bit floating point number in big-endian format.
 *
 * *Factory*: {@link module:Layout.f64be|f64be}
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class DoubleBE extends Layout {
    constructor(property) {
        super(8, property);
    }
    /** @override */
    decode(b, offset = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset);
    }
    /** @override */
    encode(src, b, offset = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
        return 8;
    }
}
exports.DoubleBE = DoubleBE;
/**
 * Represent a contiguous sequence of a specific layout as an Array.
 *
 * *Factory*: {@link module:Layout.seq|seq}
 *
 * @param {Layout} elementLayout - initializer for {@link
 * Sequence#elementLayout|elementLayout}.
 *
 * @param {(Number|ExternalLayout)} count - initializer for {@link
 * Sequence#count|count}.  The parameter must be either a positive
 * integer or an instance of {@link ExternalLayout}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Sequence extends Layout {
    constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
            throw new TypeError('elementLayout must be a Layout');
        }
        if (!(((count instanceof ExternalLayout) && count.isCount())
            || (Number.isInteger(count) && (0 <= count)))) {
            throw new TypeError('count must be non-negative integer '
                + 'or an unsigned integer ExternalLayout');
        }
        let span = -1;
        if ((!(count instanceof ExternalLayout))
            && (0 < elementLayout.span)) {
            span = count * elementLayout.span;
        }
        super(span, property);
        /** The layout for individual elements of the sequence. */
        this.elementLayout = elementLayout;
        /** The number of elements in the sequence.
         *
         * This will be either a non-negative integer or an instance of
         * {@link ExternalLayout} for which {@link
         * ExternalLayout#isCount|isCount()} is `true`. */
        this.count = count;
    }
    /** @override */
    getSpan(b, offset = 0) {
        if (0 <= this.span) {
            return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
            count = count.decode(b, offset);
        }
        if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
        }
        else {
            let idx = 0;
            while (idx < count) {
                span += this.elementLayout.getSpan(b, offset + span);
                ++idx;
            }
        }
        return span;
    }
    /** @override */
    decode(b, offset = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
            count = count.decode(b, offset);
        }
        while (i < count) {
            rv.push(this.elementLayout.decode(b, offset));
            offset += this.elementLayout.getSpan(b, offset);
            i += 1;
        }
        return rv;
    }
    /** Implement {@link Layout#encode|encode} for {@link Sequence}.
     *
     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
     * the unused space in the buffer is left unchanged.  If `src` is
     * longer than {@link Sequence#count|count} the unneeded elements are
     * ignored.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src, b, offset = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span, v) => {
            return span + elo.encode(v, b, offset + span);
        }, 0);
        if (this.count instanceof ExternalLayout) {
            this.count.encode(src.length, b, offset);
        }
        return span;
    }
}
exports.Sequence = Sequence;
/**
 * Represent a contiguous sequence of arbitrary layout elements as an
 * Object.
 *
 * *Factory*: {@link module:Layout.struct|struct}
 *
 * **NOTE** The {@link Layout#span|span} of the structure is variable
 * if any layout in {@link Structure#fields|fields} has a variable
 * span.  When {@link Layout#encode|encoding} we must have a value for
 * all variable-length fields, or we wouldn't be able to figure out
 * how much space to use for storage.  We can only identify the value
 * for a field when it has a {@link Layout#property|property}.  As
 * such, although a structure may contain both unnamed fields and
 * variable-length fields, it cannot contain an unnamed
 * variable-length field.
 *
 * @param {Layout[]} fields - initializer for {@link
 * Structure#fields|fields}.  An error is raised if this contains a
 * variable-length field for which a {@link Layout#property|property}
 * is not defined.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @param {Boolean} [decodePrefixes] - initializer for {@link
 * Structure#decodePrefixes|property}.
 *
 * @throws {Error} - if `fields` contains an unnamed variable-length
 * layout.
 *
 * @augments {Layout}
 */
class Structure extends Layout {
    constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields)
            && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {
            throw new TypeError('fields must be array of Layout instances');
        }
        if (('boolean' === typeof property)
            && (undefined === decodePrefixes)) {
            decodePrefixes = property;
            property = undefined;
        }
        /* Verify absence of unnamed variable-length fields. */
        for (const fd of fields) {
            if ((0 > fd.span)
                && (undefined === fd.property)) {
                throw new Error('fields cannot contain unnamed variable-length layout');
            }
        }
        let span = -1;
        try {
            span = fields.reduce((span, fd) => span + fd.getSpan(), 0);
        }
        catch (e) {
            // ignore error
        }
        super(span, property);
        /** The sequence of {@link Layout} values that comprise the
         * structure.
         *
         * The individual elements need not be the same type, and may be
         * either scalar or aggregate layouts.  If a member layout leaves
         * its {@link Layout#property|property} undefined the
         * corresponding region of the buffer associated with the element
         * will not be mutated.
         *
         * @type {Layout[]} */
        this.fields = fields;
        /** Control behavior of {@link Layout#decode|decode()} given short
         * buffers.
         *
         * In some situations a structure many be extended with additional
         * fields over time, with older installations providing only a
         * prefix of the full structure.  If this property is `true`
         * decoding will accept those buffers and leave subsequent fields
         * undefined, as long as the buffer ends at a field boundary.
         * Defaults to `false`. */
        this.decodePrefixes = !!decodePrefixes;
    }
    /** @override */
    getSpan(b, offset = 0) {
        if (0 <= this.span) {
            return this.span;
        }
        let span = 0;
        try {
            span = this.fields.reduce((span, fd) => {
                const fsp = fd.getSpan(b, offset);
                offset += fsp;
                return span + fsp;
            }, 0);
        }
        catch (e) {
            throw new RangeError('indeterminate span');
        }
        return span;
    }
    /** @override */
    decode(b, offset = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
            if (undefined !== fd.property) {
                dest[fd.property] = fd.decode(b, offset);
            }
            offset += fd.getSpan(b, offset);
            if (this.decodePrefixes
                && (b.length === offset)) {
                break;
            }
        }
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */
    encode(src, b, offset = 0) {
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = (0 < span) ? span : 0;
            if (undefined !== fd.property) {
                const fv = src[fd.property];
                if (undefined !== fv) {
                    lastWrote = fd.encode(fv, b, offset);
                    if (0 > span) {
                        /* Read the as-encoded span, which is not necessarily the
                         * same as what we wrote. */
                        span = fd.getSpan(b, offset);
                    }
                }
            }
            lastOffset = offset;
            offset += span;
        }
        /* Use (lastOffset + lastWrote) instead of offset because the last
         * item may have had a dynamic length and we don't want to include
         * the padding between it and the end of the space reserved for
         * it. */
        return (lastOffset + lastWrote) - firstOffset;
    }
    /** @override */
    fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
            if ((undefined !== fd.property)
                && (0 < values.length)) {
                dest[fd.property] = values.shift();
            }
        }
        return dest;
    }
    /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */
    layoutFor(property) {
        if ('string' !== typeof property) {
            throw new TypeError('property must be string');
        }
        for (const fd of this.fields) {
            if (fd.property === property) {
                return fd;
            }
        }
        return undefined;
    }
    /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */
    offsetOf(property) {
        if ('string' !== typeof property) {
            throw new TypeError('property must be string');
        }
        let offset = 0;
        for (const fd of this.fields) {
            if (fd.property === property) {
                return offset;
            }
            if (0 > fd.span) {
                offset = -1;
            }
            else if (0 <= offset) {
                offset += fd.span;
            }
        }
        return undefined;
    }
}
exports.Structure = Structure;
/**
 * An object that can provide a {@link
 * Union#discriminator|discriminator} API for {@link Union}.
 *
 * **NOTE** This is an abstract base class; you can create instances
 * if it amuses you, but they won't support the {@link
 * UnionDiscriminator#encode|encode} or {@link
 * UnionDiscriminator#decode|decode} functions.
 *
 * @param {string} [property] - Default for {@link
 * UnionDiscriminator#property|property}.
 *
 * @abstract
 */
class UnionDiscriminator {
    constructor(property) {
        /** The {@link Layout#property|property} to be used when the
         * discriminator is referenced in isolation (generally when {@link
         * Union#decode|Union decode} cannot delegate to a specific
         * variant). */
        this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */
    decode(b, offset) {
        throw new Error('UnionDiscriminator is abstract');
    }
    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */
    encode(src, b, offset) {
        throw new Error('UnionDiscriminator is abstract');
    }
}
exports.UnionDiscriminator = UnionDiscriminator;
/**
 * An object that can provide a {@link
 * UnionDiscriminator|discriminator API} for {@link Union} using an
 * unsigned integral {@link Layout} instance located either inside or
 * outside the union.
 *
 * @param {ExternalLayout} layout - initializes {@link
 * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
 * ExternalLayout#isCount|isCount()}.
 *
 * @param {string} [property] - Default for {@link
 * UnionDiscriminator#property|property}, superseding the property
 * from `layout`, but defaulting to `variant` if neither `property`
 * nor layout provide a property name.
 *
 * @augments {UnionDiscriminator}
 */
class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
        if (!((layout instanceof ExternalLayout)
            && layout.isCount())) {
            throw new TypeError('layout must be an unsigned integer ExternalLayout');
        }
        super(property || layout.property || 'variant');
        /** The {@link ExternalLayout} used to access the discriminator
         * value. */
        this.layout = layout;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    decode(b, offset) {
        return this.layout.decode(b, offset);
    }
    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
    }
}
exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
/**
 * Represent any number of span-compatible layouts.
 *
 * *Factory*: {@link module:Layout.union|union}
 *
 * If the union has a {@link Union#defaultLayout|default layout} that
 * layout must have a non-negative {@link Layout#span|span}.  The span
 * of a fixed-span union includes its {@link
 * Union#discriminator|discriminator} if the variant is a {@link
 * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
 * of its {@link Union#defaultLayout|default layout}.
 *
 * If the union does not have a default layout then the encoded span
 * of the union depends on the encoded span of its variant (which may
 * be fixed or variable).
 *
 * {@link VariantLayout#layout|Variant layout}s are added through
 * {@link Union#addVariant|addVariant}.  If the union has a default
 * layout, the span of the {@link VariantLayout#layout|layout
 * contained by the variant} must not exceed the span of the {@link
 * Union#defaultLayout|default layout} (minus the span of a {@link
 * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
 * span of the variant will equal the span of the union itself.
 *
 * The variant for a buffer can only be identified from the {@link
 * Union#discriminator|discriminator} {@link
 * UnionDiscriminator#property|property} (in the case of the {@link
 * Union#defaultLayout|default layout}), or by using {@link
 * Union#getVariant|getVariant} and examining the resulting {@link
 * VariantLayout} instance.
 *
 * A variant compatible with a JavaScript object can be identified
 * using {@link Union#getSourceVariant|getSourceVariant}.
 *
 * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
 * identify the layout used to interpret the union contents.  The
 * parameter must be an instance of {@link UnionDiscriminator}, an
 * {@link ExternalLayout} that satisfies {@link
 * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
 * UIntBE}).  When a non-external layout element is passed the layout
 * appears at the start of the union.  In all cases the (synthesized)
 * {@link UnionDiscriminator} instance is recorded as {@link
 * Union#discriminator|discriminator}.
 *
 * @param {(Layout|null)} defaultLayout - initializer for {@link
 * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
 * If `null` there is no default layout: the union has data-dependent
 * length and attempts to decode or encode unrecognized variants will
 * throw an exception.  A {@link Layout} instance must have a
 * non-negative {@link Layout#span|span}, and if it lacks a {@link
 * Layout#property|property} the {@link
 * Union#defaultLayout|defaultLayout} will be a {@link
 * Layout#replicate|replica} with property `content`.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Union extends Layout {
    constructor(discr, defaultLayout, property) {
        let discriminator;
        if ((discr instanceof UInt)
            || (discr instanceof UIntBE)) {
            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        }
        else if ((discr instanceof ExternalLayout)
            && discr.isCount()) {
            discriminator = new UnionLayoutDiscriminator(discr);
        }
        else if (!(discr instanceof UnionDiscriminator)) {
            throw new TypeError('discr must be a UnionDiscriminator '
                + 'or an unsigned integer layout');
        }
        else {
            discriminator = discr;
        }
        if (undefined === defaultLayout) {
            defaultLayout = null;
        }
        if (!((null === defaultLayout)
            || (defaultLayout instanceof Layout))) {
            throw new TypeError('defaultLayout must be null or a Layout');
        }
        if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
                throw new Error('defaultLayout must have constant span');
            }
            if (undefined === defaultLayout.property) {
                defaultLayout = defaultLayout.replicate('content');
            }
        }
        /* The union span can be estimated only if there's a default
         * layout.  The union spans its default layout, plus any prefix
         * variant layout.  By construction both layouts, if present, have
         * non-negative span. */
        let span = -1;
        if (defaultLayout) {
            span = defaultLayout.span;
            if ((0 <= span) && ((discr instanceof UInt)
                || (discr instanceof UIntBE))) {
                span += discriminator.layout.span;
            }
        }
        super(span, property);
        /** The interface for the discriminator value in isolation.
         *
         * This a {@link UnionDiscriminator} either passed to the
         * constructor or synthesized from the `discr` constructor
         * argument.  {@link
         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
         * `true` iff the `discr` parameter was a non-offset {@link
         * Layout} instance. */
        this.discriminator = discriminator;
        /** `true` if the {@link Union#discriminator|discriminator} is the
         * first field in the union.
         *
         * If `false` the discriminator is obtained from somewhere
         * else. */
        this.usesPrefixDiscriminator = (discr instanceof UInt)
            || (discr instanceof UIntBE);
        /** The layout for non-discriminator content when the value of the
         * discriminator is not recognized.
         *
         * This is the value passed to the constructor.  It is
         * structurally equivalent to the second component of {@link
         * Union#layout|layout} but may have a different property
         * name. */
        this.defaultLayout = defaultLayout;
        /** A registry of allowed variants.
         *
         * The keys are unsigned integers which should be compatible with
         * {@link Union.discriminator|discriminator}.  The property value
         * is the corresponding {@link VariantLayout} instances assigned
         * to this union by {@link Union#addVariant|addVariant}.
         *
         * **NOTE** The registry remains mutable so that variants can be
         * {@link Union#addVariant|added} at any time.  Users should not
         * manipulate the content of this property. */
        this.registry = {};
        /* Private variable used when invoking getSourceVariant */
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        /** Function to infer the variant selected by a source object.
         *
         * Defaults to {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
         * be overridden using {@link
         * Union#configGetSourceVariant|configGetSourceVariant}.
         *
         * @param {Object} src - as with {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
         *
         * @returns {(undefined|VariantLayout)} The default variant
         * (`undefined`) or first registered variant that uses a property
         * available in `src`. */
        this.getSourceVariant = function (src) {
            return boundGetSourceVariant(src);
        };
        /** Function to override the implementation of {@link
         * Union#getSourceVariant|getSourceVariant}.
         *
         * Use this if the desired variant cannot be identified using the
         * algorithm of {@link
         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
         *
         * **NOTE** The provided function will be invoked bound to this
         * Union instance, providing local access to {@link
         * Union#registry|registry}.
         *
         * @param {Function} gsv - a function that follows the API of
         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */
        this.configGetSourceVariant = function (gsv) {
            boundGetSourceVariant = gsv.bind(this);
        };
    }
    /** @override */
    getSpan(b, offset = 0) {
        if (0 <= this.span) {
            return this.span;
        }
        /* Default layouts always have non-negative span, so we don't have
         * one and we have to recognize the variant which will in turn
         * determine the span. */
        const vlo = this.getVariant(b, offset);
        if (!vlo) {
            throw new Error('unable to determine span for unrecognized variant');
        }
        return vlo.getSpan(b, offset);
    }
    /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisfied rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */
    defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property
                && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
                return undefined;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo
                && ((!vlo.layout)
                    || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {
                return vlo;
            }
        }
        else {
            for (const tag in this.registry) {
                const vlo = this.registry[tag];
                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                    return vlo;
                }
            }
        }
        throw new Error('unable to infer src variant');
    }
    /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */
    decode(b, offset = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset);
        const clo = this.registry[discr];
        if (undefined === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
                contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            // defaultLayout.property can be undefined, but this is allowed by buffer-layout
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
        }
        else {
            dest = clo.decode(b, offset);
        }
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */
    encode(src, b, offset = 0) {
        const vlo = this.getSourceVariant(src);
        if (undefined === vlo) {
            const dlo = this.discriminator;
            // this.defaultLayout is not undefined when vlo is undefined
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
                contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset);
            // clo.property is not undefined when vlo is undefined
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
        }
        return vlo.encode(src, b, offset);
    }
    /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */
    addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
    }
    /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Uint8Array)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Uint8Array}.
     *
     * @return {({VariantLayout}|undefined)}
     */
    getVariant(vb, offset = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
            variant = this.discriminator.decode(vb, offset);
        }
        else {
            variant = vb;
        }
        return this.registry[variant];
    }
}
exports.Union = Union;
/**
 * Represent a specific variant within a containing union.
 *
 * **NOTE** The {@link Layout#span|span} of the variant may include
 * the span of the {@link Union#discriminator|discriminator} used to
 * identify it, but values read and written using the variant strictly
 * conform to the content of {@link VariantLayout#layout|layout}.
 *
 * **NOTE** User code should not invoke this constructor directly.  Use
 * the union {@link Union#addVariant|addVariant} helper method.
 *
 * @param {Union} union - initializer for {@link
 * VariantLayout#union|union}.
 *
 * @param {Number} variant - initializer for {@link
 * VariantLayout#variant|variant}.
 *
 * @param {Layout} [layout] - initializer for {@link
 * VariantLayout#layout|layout}.  If absent the variant carries no
 * data.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.  Unlike many other layouts, variant
 * layouts normally include a property name so they can be identified
 * within their containing {@link Union}.  The property identifier may
 * be absent only if `layout` is is absent.
 *
 * @augments {Layout}
 */
class VariantLayout extends Layout {
    constructor(union, variant, layout, property) {
        if (!(union instanceof Union)) {
            throw new TypeError('union must be a Union');
        }
        if ((!Number.isInteger(variant)) || (0 > variant)) {
            throw new TypeError('variant must be a (non-negative) integer');
        }
        if (('string' === typeof layout)
            && (undefined === property)) {
            property = layout;
            layout = null;
        }
        if (layout) {
            if (!(layout instanceof Layout)) {
                throw new TypeError('layout must be a Layout');
            }
            if ((null !== union.defaultLayout)
                && (0 <= layout.span)
                && (layout.span > union.defaultLayout.span)) {
                throw new Error('variant span exceeds span of containing union');
            }
            if ('string' !== typeof property) {
                throw new TypeError('variant must have a String property');
            }
        }
        let span = union.span;
        if (0 > union.span) {
            span = layout ? layout.span : 0;
            if ((0 <= span) && union.usesPrefixDiscriminator) {
                span += union.discriminator.layout.span;
            }
        }
        super(span, property);
        /** The {@link Union} to which this variant belongs. */
        this.union = union;
        /** The unsigned integral value identifying this variant within
         * the {@link Union#discriminator|discriminator} of the containing
         * union. */
        this.variant = variant;
        /** The {@link Layout} to be used when reading/writing the
         * non-discriminator part of the {@link
         * VariantLayout#union|union}.  If `null` the variant carries no
         * data. */
        this.layout = layout || null;
    }
    /** @override */
    getSpan(b, offset = 0) {
        if (0 <= this.span) {
            /* Will be equal to the containing union span if that is not
             * variable. */
            return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
        }
        /* Span is defined solely by the variant (and prefix discriminator) */
        let span = 0;
        if (this.layout) {
            span = this.layout.getSpan(b, offset + contentOffset);
        }
        return contentOffset + span;
    }
    /** @override */
    decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset)) {
            throw new Error('variant mismatch');
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset + contentOffset);
        }
        else if (this.property) {
            dest[this.property] = true;
        }
        else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
    }
    /** @override */
    encode(src, b, offset = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout
            && (!Object.prototype.hasOwnProperty.call(src, this.property))) {
            throw new TypeError('variant lacks property ' + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset);
        let span = contentOffset;
        if (this.layout) {
            this.layout.encode(src[this.property], b, offset + contentOffset);
            span += this.layout.getSpan(b, offset + contentOffset);
            if ((0 <= this.union.span)
                && (span > this.union.span)) {
                throw new Error('encoded variant overruns containing union');
            }
        }
        return span;
    }
    /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */
    fromArray(values) {
        if (this.layout) {
            return this.layout.fromArray(values);
        }
        return undefined;
    }
}
exports.VariantLayout = VariantLayout;
/** JavaScript chose to define bitwise operations as operating on
 * signed 32-bit values in 2's complement form, meaning any integer
 * with bit 31 set is going to look negative.  For right shifts that's
 * not a problem, because `>>>` is a logical shift, but for every
 * other bitwise operator we have to compensate for possible negative
 * results. */
function fixBitwiseResult(v) {
    if (0 > v) {
        v += 0x100000000;
    }
    return v;
}
/**
 * Contain a sequence of bit fields as an unsigned integer.
 *
 * *Factory*: {@link module:Layout.bits|bits}
 *
 * This is a container element; within it there are {@link BitField}
 * instances that provide the extracted properties.  The container
 * simply defines the aggregate representation and its bit ordering.
 * The representation is an object containing properties with numeric
 * or {@link Boolean} values.
 *
 * {@link BitField}s are added with the {@link
 * BitStructure#addField|addField} and {@link
 * BitStructure#addBoolean|addBoolean} methods.

 * @param {Layout} word - initializer for {@link
 * BitStructure#word|word}.  The parameter must be an instance of
 * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
 *
 * @param {bool} [msb] - `true` if the bit numbering starts at the
 * most significant bit of the containing word; `false` (default) if
 * it starts at the least significant bit of the containing word.  If
 * the parameter at this position is a string and `property` is
 * `undefined` the value of this argument will instead be used as the
 * value of `property`.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class BitStructure extends Layout {
    constructor(word, msb, property) {
        if (!((word instanceof UInt)
            || (word instanceof UIntBE))) {
            throw new TypeError('word must be a UInt or UIntBE layout');
        }
        if (('string' === typeof msb)
            && (undefined === property)) {
            property = msb;
            msb = false;
        }
        if (4 < word.span) {
            throw new RangeError('word cannot exceed 32 bits');
        }
        super(word.span, property);
        /** The layout used for the packed value.  {@link BitField}
         * instances are packed sequentially depending on {@link
         * BitStructure#msb|msb}. */
        this.word = word;
        /** Whether the bit sequences are packed starting at the most
         * significant bit growing down (`true`), or the least significant
         * bit growing up (`false`).
         *
         * **NOTE** Regardless of this value, the least significant bit of
         * any {@link BitField} value is the least significant bit of the
         * corresponding section of the packed value. */
        this.msb = !!msb;
        /** The sequence of {@link BitField} layouts that comprise the
         * packed structure.
         *
         * **NOTE** The array remains mutable to allow fields to be {@link
         * BitStructure#addField|added} after construction.  Users should
         * not manipulate the content of this property.*/
        this.fields = [];
        /* Storage for the value.  Capture a variable instead of using an
         * instance property because we don't want anything to change the
         * value without going through the mutator. */
        let value = 0;
        this._packedSetValue = function (v) {
            value = fixBitwiseResult(v);
            return this;
        };
        this._packedGetValue = function () {
            return value;
        };
    }
    /** @override */
    decode(b, offset = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
            if (undefined !== fd.property) {
                dest[fd.property] = fd.decode(b);
            }
        }
        return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the packed
     * value is left unmodified.  Unused bits are also left unmodified. */
    encode(src, b, offset = 0) {
        const value = this.word.decode(b, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
            if (undefined !== fd.property) {
                const fv = src[fd.property];
                if (undefined !== fv) {
                    fd.encode(fv);
                }
            }
        }
        return this.word.encode(this._packedGetValue(), b, offset);
    }
    /** Register a new bitfield with a containing bit structure.  The
     * resulting bitfield is returned.
     *
     * @param {Number} bits - initializer for {@link BitField#bits|bits}.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {BitField} */
    addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
    }
    /** As with {@link BitStructure#addField|addField} for single-bit
     * fields with `boolean` value representation.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {Boolean} */
    // `Boolean` conflicts with the native primitive type
    // eslint-disable-next-line @typescript-eslint/ban-types
    addBoolean(property) {
        // This is my Boolean, not the Javascript one.
        const bf = new Boolean(this, property);
        this.fields.push(bf);
        return bf;
    }
    /**
     * Get access to the bit field for a given property.
     *
     * @param {String} property - the bit field of interest.
     *
     * @return {BitField} - the field associated with `property`, or
     * undefined if there is no such property.
     */
    fieldFor(property) {
        if ('string' !== typeof property) {
            throw new TypeError('property must be string');
        }
        for (const fd of this.fields) {
            if (fd.property === property) {
                return fd;
            }
        }
        return undefined;
    }
}
exports.BitStructure = BitStructure;
/**
 * Represent a sequence of bits within a {@link BitStructure}.
 *
 * All bit field values are represented as unsigned integers.
 *
 * **NOTE** User code should not invoke this constructor directly.
 * Use the container {@link BitStructure#addField|addField} helper
 * method.
 *
 * **NOTE** BitField instances are not instances of {@link Layout}
 * since {@link Layout#span|span} measures 8-bit units.
 *
 * @param {BitStructure} container - initializer for {@link
 * BitField#container|container}.
 *
 * @param {Number} bits - initializer for {@link BitField#bits|bits}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 */
class BitField {
    constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
            throw new TypeError('container must be a BitStructure');
        }
        if ((!Number.isInteger(bits)) || (0 >= bits)) {
            throw new TypeError('bits must be positive integer');
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if ((bits + usedBits) > totalBits) {
            throw new Error('bits too long for span remainder ('
                + (totalBits - usedBits) + ' of '
                + totalBits + ' remain)');
        }
        /** The {@link BitStructure} instance to which this bit field
         * belongs. */
        this.container = container;
        /** The span of this value in bits. */
        this.bits = bits;
        /** A mask of {@link BitField#bits|bits} bits isolating value bits
         * that fit within the field.
         *
         * That is, it masks a value that has not yet been shifted into
         * position within its containing packed integer. */
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) { // shifted value out of range
            this.valueMask = 0xFFFFFFFF;
        }
        /** The offset of the value within the containing packed unsigned
         * integer.  The least significant bit of the packed value is at
         * offset zero, regardless of bit ordering used. */
        this.start = usedBits;
        if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
        }
        /** A mask of {@link BitField#bits|bits} isolating the field value
         * within the containing packed unsigned integer. */
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        /** The property name used when this bitfield is represented in an
         * Object.
         *
         * Intended to be functionally equivalent to {@link
         * Layout#property}.
         *
         * If left undefined the corresponding span of bits will be
         * treated as padding: it will not be mutated by {@link
         * Layout#encode|encode} nor represented as a property in the
         * decoded Object. */
        this.property = property;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field. */
    decode(b, offset) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field.
     *
     * **NOTE** This is not a specialization of {@link
     * Layout#encode|Layout.encode} and there is no return value. */
    encode(value) {
        if ('number' !== typeof value
            || !Number.isInteger(value)
            || (value !== fixBitwiseResult(value & this.valueMask))) {
            throw new TypeError(nameWithProperty('BitField.encode', this)
                + ' value must be integer not exceeding ' + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)
            | wordValue);
    }
}
exports.BitField = BitField;
/**
 * Represent a single bit within a {@link BitStructure} as a
 * JavaScript boolean.
 *
 * **NOTE** User code should not invoke this constructor directly.
 * Use the container {@link BitStructure#addBoolean|addBoolean} helper
 * method.
 *
 * @param {BitStructure} container - initializer for {@link
 * BitField#container|container}.
 *
 * @param {string} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {BitField}
 */
/* eslint-disable no-extend-native */
class Boolean extends BitField {
    constructor(container, property) {
        super(container, 1, property);
    }
    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */
    decode(b, offset) {
        return !!super.decode(b, offset);
    }
    /** @override */
    encode(value) {
        if ('boolean' === typeof value) {
            // BitField requires integer values
            value = +value;
        }
        super.encode(value);
    }
}
exports.Boolean = Boolean;
/* eslint-enable no-extend-native */
/**
 * Contain a fixed-length block of arbitrary data, represented as a
 * Uint8Array.
 *
 * *Factory*: {@link module:Layout.blob|blob}
 *
 * @param {(Number|ExternalLayout)} length - initializes {@link
 * Blob#length|length}.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Blob extends Layout {
    constructor(length, property) {
        if (!(((length instanceof ExternalLayout) && length.isCount())
            || (Number.isInteger(length) && (0 <= length)))) {
            throw new TypeError('length must be positive integer '
                + 'or an unsigned integer ExternalLayout');
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
            span = length;
        }
        super(span, property);
        /** The number of bytes in the blob.
         *
         * This may be a non-negative integer, or an instance of {@link
         * ExternalLayout} that satisfies {@link
         * ExternalLayout#isCount|isCount()}. */
        this.length = length;
    }
    /** @override */
    getSpan(b, offset) {
        let span = this.span;
        if (0 > span) {
            span = this.length.decode(b, offset);
        }
        return span;
    }
    /** @override */
    decode(b, offset = 0) {
        let span = this.span;
        if (0 > span) {
            span = this.length.decode(b, offset);
        }
        return uint8ArrayToBuffer(b).slice(offset, offset + span);
    }
    /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src, b, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
            span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
            throw new TypeError(nameWithProperty('Blob.encode', this)
                + ' requires (length ' + span + ') Uint8Array as src');
        }
        if ((offset + span) > b.length) {
            throw new RangeError('encoding overruns Uint8Array');
        }
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');
        if (this.length instanceof ExternalLayout) {
            this.length.encode(span, b, offset);
        }
        return span;
    }
}
exports.Blob = Blob;
/**
 * Contain a `NUL`-terminated UTF8 string.
 *
 * *Factory*: {@link module:Layout.cstr|cstr}
 *
 * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
 * not be correctly decoded by this layout.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class CString extends Layout {
    constructor(property) {
        super(-1, property);
    }
    /** @override */
    getSpan(b, offset = 0) {
        checkUint8Array(b);
        let idx = offset;
        while ((idx < b.length) && (0 !== b[idx])) {
            idx += 1;
        }
        return 1 + idx - offset;
    }
    /** @override */
    decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');
    }
    /** @override */
    encode(src, b, offset = 0) {
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */
        if ('string' !== typeof src) {
            src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, 'utf8');
        const span = srcb.length;
        if ((offset + span) > b.length) {
            throw new RangeError('encoding overruns Buffer');
        }
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset);
        buffer[offset + span] = 0;
        return span + 1;
    }
}
exports.CString = CString;
/**
 * Contain a UTF8 string with implicit length.
 *
 * *Factory*: {@link module:Layout.utf8|utf8}
 *
 * **NOTE** Because the length is implicit in the size of the buffer
 * this layout should be used only in isolation, or in a situation
 * where the length can be expressed by operating on a slice of the
 * containing buffer.
 *
 * @param {Number} [maxSpan] - the maximum length allowed for encoded
 * string content.  If not provided there is no bound on the allowed
 * content.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class UTF8 extends Layout {
    constructor(maxSpan, property) {
        if (('string' === typeof maxSpan) && (undefined === property)) {
            property = maxSpan;
            maxSpan = undefined;
        }
        if (undefined === maxSpan) {
            maxSpan = -1;
        }
        else if (!Number.isInteger(maxSpan)) {
            throw new TypeError('maxSpan must be an integer');
        }
        super(-1, property);
        /** The maximum span of the layout in bytes.
         *
         * Positive values are generally expected.  Zero is abnormal.
         * Attempts to encode or decode a value that exceeds this length
         * will throw a `RangeError`.
         *
         * A negative value indicates that there is no bound on the length
         * of the content. */
        this.maxSpan = maxSpan;
    }
    /** @override */
    getSpan(b, offset = 0) {
        checkUint8Array(b);
        return b.length - offset;
    }
    /** @override */
    decode(b, offset = 0) {
        const span = this.getSpan(b, offset);
        if ((0 <= this.maxSpan)
            && (this.maxSpan < span)) {
            throw new RangeError('text length exceeds maxSpan');
        }
        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');
    }
    /** @override */
    encode(src, b, offset = 0) {
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */
        if ('string' !== typeof src) {
            src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, 'utf8');
        const span = srcb.length;
        if ((0 <= this.maxSpan)
            && (this.maxSpan < span)) {
            throw new RangeError('text length exceeds maxSpan');
        }
        if ((offset + span) > b.length) {
            throw new RangeError('encoding overruns Buffer');
        }
        srcb.copy(uint8ArrayToBuffer(b), offset);
        return span;
    }
}
exports.UTF8 = UTF8;
/**
 * Contain a constant value.
 *
 * This layout may be used in cases where a JavaScript value can be
 * inferred without an expression in the binary encoding.  An example
 * would be a {@link VariantLayout|variant layout} where the content
 * is implied by the union {@link Union#discriminator|discriminator}.
 *
 * @param {Object|Number|String} value - initializer for {@link
 * Constant#value|value}.  If the value is an object (or array) and
 * the application intends the object to remain unchanged regardless
 * of what is done to values decoded by this layout, the value should
 * be frozen prior passing it to this constructor.
 *
 * @param {String} [property] - initializer for {@link
 * Layout#property|property}.
 *
 * @augments {Layout}
 */
class Constant extends Layout {
    constructor(value, property) {
        super(0, property);
        /** The value produced by this constant when the layout is {@link
         * Constant#decode|decoded}.
         *
         * Any JavaScript value including `null` and `undefined` is
         * permitted.
         *
         * **WARNING** If `value` passed in the constructor was not
         * frozen, it is possible for users of decoded values to change
         * the content of the value. */
        this.value = value;
    }
    /** @override */
    decode(b, offset) {
        return this.value;
    }
    /** @override */
    encode(src, b, offset) {
        /* Constants take no space */
        return 0;
    }
}
exports.Constant = Constant;
/** Factory for {@link GreedyCount}. */
exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
/** Factory for {@link OffsetLayout}. */
exports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));
/** Factory for {@link UInt|unsigned int layouts} spanning one
 * byte. */
exports.u8 = ((property) => new UInt(1, property));
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning two bytes. */
exports.u16 = ((property) => new UInt(2, property));
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning three bytes. */
exports.u24 = ((property) => new UInt(3, property));
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning four bytes. */
exports.u32 = ((property) => new UInt(4, property));
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning five bytes. */
exports.u40 = ((property) => new UInt(5, property));
/** Factory for {@link UInt|little-endian unsigned int layouts}
 * spanning six bytes. */
exports.u48 = ((property) => new UInt(6, property));
/** Factory for {@link NearUInt64|little-endian unsigned int
 * layouts} interpreted as Numbers. */
exports.nu64 = ((property) => new NearUInt64(property));
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning two bytes. */
exports.u16be = ((property) => new UIntBE(2, property));
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning three bytes. */
exports.u24be = ((property) => new UIntBE(3, property));
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning four bytes. */
exports.u32be = ((property) => new UIntBE(4, property));
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning five bytes. */
exports.u40be = ((property) => new UIntBE(5, property));
/** Factory for {@link UInt|big-endian unsigned int layouts}
 * spanning six bytes. */
exports.u48be = ((property) => new UIntBE(6, property));
/** Factory for {@link NearUInt64BE|big-endian unsigned int
 * layouts} interpreted as Numbers. */
exports.nu64be = ((property) => new NearUInt64BE(property));
/** Factory for {@link Int|signed int layouts} spanning one
 * byte. */
exports.s8 = ((property) => new Int(1, property));
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning two bytes. */
exports.s16 = ((property) => new Int(2, property));
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning three bytes. */
exports.s24 = ((property) => new Int(3, property));
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning four bytes. */
exports.s32 = ((property) => new Int(4, property));
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning five bytes. */
exports.s40 = ((property) => new Int(5, property));
/** Factory for {@link Int|little-endian signed int layouts}
 * spanning six bytes. */
exports.s48 = ((property) => new Int(6, property));
/** Factory for {@link NearInt64|little-endian signed int layouts}
 * interpreted as Numbers. */
exports.ns64 = ((property) => new NearInt64(property));
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning two bytes. */
exports.s16be = ((property) => new IntBE(2, property));
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning three bytes. */
exports.s24be = ((property) => new IntBE(3, property));
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning four bytes. */
exports.s32be = ((property) => new IntBE(4, property));
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning five bytes. */
exports.s40be = ((property) => new IntBE(5, property));
/** Factory for {@link Int|big-endian signed int layouts}
 * spanning six bytes. */
exports.s48be = ((property) => new IntBE(6, property));
/** Factory for {@link NearInt64BE|big-endian signed int layouts}
 * interpreted as Numbers. */
exports.ns64be = ((property) => new NearInt64BE(property));
/** Factory for {@link Float|little-endian 32-bit floating point} values. */
exports.f32 = ((property) => new Float(property));
/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */
exports.f32be = ((property) => new FloatBE(property));
/** Factory for {@link Double|little-endian 64-bit floating point} values. */
exports.f64 = ((property) => new Double(property));
/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */
exports.f64be = ((property) => new DoubleBE(property));
/** Factory for {@link Structure} values. */
exports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
/** Factory for {@link BitStructure} values. */
exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
/** Factory for {@link Sequence} values. */
exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
/** Factory for {@link Union} values. */
exports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
/** Factory for {@link UnionLayoutDiscriminator} values. */
exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));
/** Factory for {@link Blob} values. */
exports.blob = ((length, property) => new Blob(length, property));
/** Factory for {@link CString} values. */
exports.cstr = ((property) => new CString(property));
/** Factory for {@link UTF8} values. */
exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
/** Factory for {@link Constant} values. */
exports.constant = ((value, property) => new Constant(value, property));

},{"buffer":61}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');
var sha512 = require('@noble/hashes/sha512');
var ed25519 = require('@noble/ed25519');
var BN = require('bn.js');
var bs58 = require('bs58');
var sha256 = require('@noble/hashes/sha256');
var borsh = require('borsh');
var BufferLayout = require('@solana/buffer-layout');
var bigintBuffer = require('bigint-buffer');
var superstruct = require('superstruct');
var RpcClient = require('jayson/lib/client/browser');
var RpcWebSocketCommonClient = require('rpc-websockets/dist/lib/client');
var createRpc = require('rpc-websockets/dist/lib/client/websocket.browser');
var sha3 = require('@noble/hashes/sha3');
var hmac = require('@noble/hashes/hmac');
var secp256k1 = require('@noble/secp256k1');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ed25519__namespace = /*#__PURE__*/_interopNamespace(ed25519);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);
var BufferLayout__namespace = /*#__PURE__*/_interopNamespace(BufferLayout);
var RpcClient__default = /*#__PURE__*/_interopDefaultLegacy(RpcClient);
var RpcWebSocketCommonClient__default = /*#__PURE__*/_interopDefaultLegacy(RpcWebSocketCommonClient);
var createRpc__default = /*#__PURE__*/_interopDefaultLegacy(createRpc);
var secp256k1__namespace = /*#__PURE__*/_interopNamespace(secp256k1);

/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

ed25519__namespace.utils.sha512Sync = (...m) => sha512.sha512(ed25519__namespace.utils.concatBytes(...m));

const generatePrivateKey = ed25519__namespace.utils.randomPrivateKey;
const generateKeypair = () => {
  const privateScalar = ed25519__namespace.utils.randomPrivateKey();
  const publicKey = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey,
    secretKey
  };
};
const getPublicKey = ed25519__namespace.sync.getPublicKey;
function isOnCurve(publicKey) {
  try {
    ed25519__namespace.Point.fromHex(publicKey, true
    /* strict */
    );
    return true;
  } catch {
    return false;
  }
}
const sign = (message, secretKey) => ed25519__namespace.sync.sign(message, secretKey.slice(0, 32));
const verify = ed25519__namespace.sync.verify;

const toBuffer = arr => {
  if (buffer.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};

class Struct {
  constructor(properties) {
    Object.assign(this, properties);
  }

  encode() {
    return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));
  }

  static decode(data) {
    return borsh.deserialize(SOLANA_SCHEMA, this, data);
  }

  static decodeUnchecked(data) {
    return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
  }

} // Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS

class Enum extends Struct {
  constructor(properties) {
    super(properties);
    this.enum = '';

    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }

    Object.keys(properties).map(key => {
      this.enum = key;
    });
  }

}
const SOLANA_SCHEMA = new Map();

let _Symbol$toStringTag;
/**
 * Maximum length of derived pubkey seed
 */

const MAX_SEED_LENGTH = 32;
/**
 * Size of public key in bytes
 */

const PUBLIC_KEY_LENGTH = 32;
/**
 * Value to be converted into public key
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
} // local counter used by PublicKey.unique()


let uniquePublicKeyCounter = 1;
/**
 * A public key
 */

_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  /** @internal */

  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;

    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        const decoded = bs58__default["default"].decode(value);

        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }

        this._bn = new BN__default["default"](decoded);
      } else {
        this._bn = new BN__default["default"](value);
      }

      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */


  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */


  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */


  toBase58() {
    return bs58__default["default"].encode(this.toBytes());
  }

  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */


  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */


  toBuffer() {
    const b = this._bn.toArrayLike(buffer.Buffer);

    if (b.length === PUBLIC_KEY_LENGTH) {
      return b;
    }

    const zeroPad = buffer.Buffer.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }

  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */


  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */

  /* eslint-disable require-await */


  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256.sha256(buffer$1);
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */

  /* eslint-disable require-await */


  static createProgramAddressSync(seeds, programId) {
    let buffer$1 = buffer.Buffer.alloc(0);
    seeds.forEach(function (seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }

      buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
    });
    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);
    const publicKeyBytes = sha256.sha256(buffer$1);

    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }

    return new PublicKey(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */

  /* eslint-disable require-await */


  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */


  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;

    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }

        nonce--;
        continue;
      }

      return [address, nonce];
    }

    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */


  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */


  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }

}
PublicKey.default = new PublicKey('11111111111111111111111111111111');
SOLANA_SCHEMA.set(PublicKey, {
  kind: 'struct',
  fields: [['_bn', 'u256']]
});

/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */

class Account {
  /** @internal */

  /** @internal */

  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  constructor(secretKey) {
    this._publicKey = void 0;
    this._secretKey = void 0;

    if (secretKey) {
      const secretKeyBuffer = toBuffer(secretKey);

      if (secretKey.length !== 64) {
        throw new Error('bad secret key size');
      }

      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey(this._secretKey));
    }
  }
  /**
   * The public key for this account
   */


  get publicKey() {
    return new PublicKey(this._publicKey);
  }
  /**
   * The **unencrypted** secret key for this account. The first 32 bytes
   * is the private scalar and the last 32 bytes is the public key.
   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */


  get secretKey() {
    return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
  }

}

const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
const PACKET_DATA_SIZE = 1280 - 40 - 8;
const VERSION_PREFIX_MASK = 0x7f;
const SIGNATURE_LENGTH_IN_BYTES = 64;

class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature;
  }

}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError'
});
class TransactionExpiredTimeoutError extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature;
  }

}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
  value: 'TransactionExpiredTimeoutError'
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature;
  }

}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
  value: 'TransactionExpiredNonceInvalidError'
});

class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }

  keySegments() {
    const keySegments = [this.staticAccountKeys];

    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }

    return keySegments;
  }

  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }

    return;
  }

  get length() {
    return this.keySegments().flat().length;
  }

  compileInstructions(instructions) {
    // Bail early if any account indexes would overflow a u8
    const U8_MAX = 255;

    if (this.length > U8_MAX + 1) {
      throw new Error('Account index overflow encountered during compilation');
    }

    const keyIndexMap = new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });

    const findKeyIndex = key => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
      return keyIndex;
    };

    return instructions.map(instruction => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map(meta => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }

}

/**
 * Layout for a public key
 */
const publicKey = (property = 'publicKey') => {
  return BufferLayout__namespace.blob(32, property);
};
/**
 * Layout for a signature
 */

const signature = (property = 'signature') => {
  return BufferLayout__namespace.blob(64, property);
};

/**
 * Layout for a Rust String type
 */
const rustString = (property = 'string') => {
  const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32('length'), BufferLayout__namespace.u32('lengthPadding'), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'chars')], property);

  const _decode = rsl.decode.bind(rsl);

  const _encode = rsl.encode.bind(rsl);

  const rslShim = rsl;

  rslShim.decode = (b, offset) => {
    const data = _decode(b, offset);

    return data['chars'].toString();
  };

  rslShim.encode = (str, b, offset) => {
    const data = {
      chars: buffer.Buffer.from(str, 'utf8')
    };
    return _encode(data, b, offset);
  };

  rslShim.alloc = str => {
    return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, 'utf8').length;
  };

  return rslShim;
};
/**
 * Layout for an Authorized object
 */

const authorized = (property = 'authorized') => {
  return BufferLayout__namespace.struct([publicKey('staker'), publicKey('withdrawer')], property);
};
/**
 * Layout for a Lockup object
 */

const lockup = (property = 'lockup') => {
  return BufferLayout__namespace.struct([BufferLayout__namespace.ns64('unixTimestamp'), BufferLayout__namespace.ns64('epoch'), publicKey('custodian')], property);
};
/**
 *  Layout for a VoteInit object
 */

const voteInit = (property = 'voteInit') => {
  return BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission')], property);
};
/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */

const voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {
  return BufferLayout__namespace.struct([BufferLayout__namespace.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
};
function getAlloc(type, fields) {
  const getItemAlloc = item => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === 'function') {
      return item.alloc(fields[item.property]);
    } else if ('count' in item && 'elementLayout' in item) {
      const field = fields[item.property];

      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ('fields' in item) {
      // This is a `Structure` whose size needs to be recursively measured.
      return getAlloc({
        layout: item
      }, fields[item.property]);
    } // Couldn't determine allocated size of layout


    return 0;
  };

  let alloc = 0;
  type.layout.fields.forEach(item => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}

function decodeLength(bytes) {
  let len = 0;
  let size = 0;

  for (;;) {
    let elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;

    if ((elem & 0x80) === 0) {
      break;
    }
  }

  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;

  for (;;) {
    let elem = rem_len & 0x7f;
    rem_len >>= 7;

    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

function assert (condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }

  static compile(instructions, payer) {
    const keyMetaMap = new Map();

    const getOrInsertDefault = pubkey => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);

      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }

      return keyMeta;
    };

    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;

    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;

      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }

    return new CompiledKeys(payer, keyMetaMap);
  }

  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    }; // sanity checks

    {
      assert(writableSigners.length > 0, 'Expected at least one writable signer key');
      const [payerAddress] = writableSigners[0];
      assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }

  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable); // Don't extract lookup if no keys were found

    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }

    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */


  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();

    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));

        if (lookupTableIndex >= 0) {
          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }

    return [lookupTableIndexes, drainedKeys];
  }

}

/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */

/**
 * List of instructions to be processed atomically
 */
class Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }

  get version() {
    return 'legacy';
  }

  get staticAccountKeys() {
    return this.accountKeys;
  }

  get compiledInstructions() {
    return this.instructions.map(ix => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: bs58__default["default"].decode(ix.data)
    }));
  }

  get addressTableLookups() {
    return [];
  }

  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }

  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map(ix => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: bs58__default["default"].encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }

  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }

  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;

    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }

  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }

  programIds() {
    return [...this.indexToProgramIds.values()];
  }

  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }

  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map(instruction => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(bs58__default["default"].decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach(instruction => {
      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout__namespace.blob(instruction.dataLength.length, 'dataLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('userdatum'), instruction.data.length, 'data')]);
      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, 'numRequiredSignatures'), BufferLayout__namespace.blob(1, 'numReadonlySignedAccounts'), BufferLayout__namespace.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout__namespace.blob(keyCount.length, 'keyCount'), BufferLayout__namespace.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
    const transaction = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map(key => toBuffer(key.toBytes())),
      recentBlockhash: bs58__default["default"].decode(this.recentBlockhash)
    };
    let signData = buffer.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */


  static from(buffer$1) {
    // Slice up wire data
    let byteArray = [...buffer$1];
    const numRequiredSignatures = byteArray.shift();

    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
    }

    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];

    for (let i = 0; i < accountCount; i++) {
      const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(buffer.Buffer.from(account)));
    }

    const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
    byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];

    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountCount = decodeLength(byteArray);
      const accounts = byteArray.slice(0, accountCount);
      byteArray = byteArray.slice(accountCount);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.slice(0, dataLength);
      const data = bs58__default["default"].encode(buffer.Buffer.from(dataSlice));
      byteArray = byteArray.slice(dataLength);
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }

    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58__default["default"].encode(buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }

}

/**
 * Message constructor arguments
 */

class MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }

  get version() {
    return 0;
  }

  get numAccountKeysFromLookups() {
    let count = 0;

    for (const lookup of this.addressTableLookups) {
      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
    }

    return count;
  }

  getAccountKeys(args) {
    let accountKeysFromLookups;

    if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
      }

      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error('Failed to get account keys because address table lookups were not resolved');
    }

    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }

  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }

  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;

    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }

  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };

    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));

      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }

      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }

      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }

    return accountKeysFromLookups;
  }

  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];

    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);

      if (extractResult !== undefined) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }

    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }

  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('prefix'), BufferLayout__namespace.struct([BufferLayout__namespace.u8('numRequiredSignatures'), BufferLayout__namespace.u8('numReadonlySignedAccounts'), BufferLayout__namespace.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout__namespace.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout__namespace.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout__namespace.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),
      recentBlockhash: bs58__default["default"].decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }

  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);

    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout__namespace.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout__namespace.blob(instruction.data.length, 'data')]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }

    return serializedInstructions.slice(0, serializedLength);
  }

  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);

    for (const lookup of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey('accountKey'), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }

    return serializedAddressTableLookups.slice(0, serializedLength);
  }

  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = byteArray.shift();
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version = maskedPrefix;
    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);
    const header = {
      numRequiredSignatures: byteArray.shift(),
      numReadonlySignedAccounts: byteArray.shift(),
      numReadonlyUnsignedAccounts: byteArray.shift()
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);

    for (let i = 0; i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
    }

    const recentBlockhash = bs58__default["default"].encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];

    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(byteArray.splice(0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }

    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];

    for (let i = 0; i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = byteArray.splice(0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }

    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }

}

// eslint-disable-next-line no-redeclare
const VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK; // if the highest bit of the prefix is not set, the message is not versioned

    if (maskedPrefix === prefix) {
      return 'legacy';
    } // the lower 7 bits of the prefix indicate the message version


    return maskedPrefix;
  },

  deserialize: serializedMessage => {
    const version = VersionedMessage.deserializeMessageVersion(serializedMessage);

    if (version === 'legacy') {
      return Message.from(serializedMessage);
    }

    if (version === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version} deserialization is not supported`);
    }
  }
};

/**
 * Transaction signature as base-58 encoded string
 */

exports.TransactionStatus = void 0;
/**
 * Default (empty) signature
 */

(function (TransactionStatus) {
  TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
})(exports.TransactionStatus || (exports.TransactionStatus = {}));

const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
/**
 * Account metadata used to define instructions
 */

/**
 * Transaction Instruction class
 */
class TransactionInstruction {
  /**
   * Public keys to include in this transaction
   * Boolean represents whether this pubkey needs to sign the transaction
   */

  /**
   * Program Id to execute
   */

  /**
   * Program input
   */
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = buffer.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;

    if (opts.data) {
      this.data = opts.data;
    }
  }
  /**
   * @internal
   */


  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }

}
/**
 * Pair of signature and corresponding public key
 */

/**
 * Transaction class
 */
class Transaction {
  /**
   * Signatures for the transaction.  Typically created by invoking the
   * `sign()` method
   */

  /**
   * The first (payer) Transaction signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }

    return null;
  }
  /**
   * The transaction fee payer
   */


  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;

    if (!opts) {
      return;
    }

    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }

    if (opts.signatures) {
      this.signatures = opts.signatures;
    }

    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;

      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }

      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */


  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map(instruction => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey
      }) => {
        return publicKey.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   */


  add(...items) {
    if (items.length === 0) {
      throw new Error('No instructions');
    }

    items.forEach(item => {
      if ('instructions' in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ('data' in item && 'programId' in item && 'keys' in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */


  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }

    let recentBlockhash;
    let instructions;

    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;

      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }

    if (!recentBlockhash) {
      throw new Error('Transaction recentBlockhash required');
    }

    if (instructions.length < 1) {
      console.warn('No instructions provided');
    }

    let feePayer;

    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      // Use implicit fee payer
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error('Transaction fee payer required');
    }

    for (let i = 0; i < instructions.length; i++) {
      if (instructions[i].programId === undefined) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }

    const programIds = [];
    const accountMetas = [];
    instructions.forEach(instruction => {
      instruction.keys.forEach(accountMeta => {
        accountMetas.push({ ...accountMeta
        });
      });
      const programId = instruction.programId.toString();

      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    }); // Append programID account metas

    programIds.forEach(programId => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    }); // Cull duplicate account metas

    const uniqueMetas = [];
    accountMetas.forEach(accountMeta => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.toString() === pubkeyString;
      });

      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    }); // Sort. Prioritizing first by signer, then by writable

    uniqueMetas.sort(function (x, y) {
      if (x.isSigner !== y.isSigner) {
        // Signers always come before non-signers
        return x.isSigner ? -1 : 1;
      }

      if (x.isWritable !== y.isWritable) {
        // Writable accounts always come before read-only accounts
        return x.isWritable ? -1 : 1;
      } // Otherwise, sort by pubkey, stringwise.


      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
    }); // Move fee payer to the front

    const feePayerIndex = uniqueMetas.findIndex(x => {
      return x.pubkey.equals(feePayer);
    });

    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    } // Disallow unknown signers


    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.equals(signature.publicKey);
      });

      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }

    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values

    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;

        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());

        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map(instruction => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58__default["default"].encode(data)
      };
    });
    compiledInstructions.forEach(instruction => {
      assert(instruction.programIdIndex >= 0);
      instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */


  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);

    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }

    this.signatures = signedKeys.map(publicKey => ({
      signature: null,
      publicKey
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */


  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   */


  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */


  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }

    const seen = new Set();
    this.signatures = signers.filter(publicKey => {
      const key = publicKey.toString();

      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map(publicKey => ({
      signature: null,
      publicKey
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   */


  sign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    } // Dedupe signers


    const seen = new Set();
    const uniqueSigners = [];

    for (const signer of signers) {
      const key = signer.publicKey.toString();

      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }

    this.signatures = uniqueSigners.map(signer => ({
      signature: null,
      publicKey: signer.publicKey
    }));

    const message = this._compile();

    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   */


  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    } // Dedupe signers


    const seen = new Set();
    const uniqueSigners = [];

    for (const signer of signers) {
      const key = signer.publicKey.toString();

      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }

    const message = this._compile();

    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */


  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach(signer => {
      const signature = sign(signData, signer.secretKey);

      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   */


  addSignature(pubkey, signature) {
    this._compile(); // Ensure signatures array is populated


    this._addSignature(pubkey, signature);
  }
  /**
   * @internal
   */


  _addSignature(pubkey, signature) {
    assert(signature.length === 64);
    const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));

    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }

    this.signatures[index].signature = buffer.Buffer.from(signature);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   */


  verifySignatures(requireAllSignatures) {
    return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
  }
  /**
   * @internal
   */


  _verifySignatures(signData, requireAllSignatures) {
    for (const {
      signature,
      publicKey
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          return false;
        }
      } else {
        if (!verify(signature, signData, publicKey.toBytes())) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * Serialize the Transaction in the wire format.
   */


  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();

    if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
      throw new Error('Signature verification failed');
    }

    return this._serialize(signData);
  }
  /**
   * @internal
   */


  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = buffer.Buffer.alloc(transactionLength);
    assert(signatures.length < 256);
    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert(signature.length === 64, `signature has invalid length`);
        buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */


  get keys() {
    assert(this.instructions.length === 1);
    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */


  get programId() {
    assert(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */


  get data() {
    assert(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   */


  static from(buffer$1) {
    // Slice up wire data
    let byteArray = [...buffer$1];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];

    for (let i = 0; i < signatureCount; i++) {
      const signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(bs58__default["default"].encode(buffer.Buffer.from(signature)));
    }

    return Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   */


  static populate(message, signatures = []) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message.recentBlockhash;

    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }

    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == bs58__default["default"].encode(DEFAULT_SIGNATURE) ? null : bs58__default["default"].decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach(instruction => {
      const keys = instruction.accounts.map(account => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: bs58__default["default"].decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }

}

class TransactionMessage {
  constructor(args) {
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }

  static decompile(message, args) {
    const {
      header,
      compiledInstructions,
      recentBlockhash
    } = message;
    const {
      numRequiredSignatures,
      numReadonlySignedAccounts,
      numReadonlyUnsignedAccounts
    } = header;
    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
    assert(numWritableSignedAccounts > 0, 'Message header is invalid');
    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
    const accountKeys = message.getAccountKeys(args);
    const payerKey = accountKeys.get(0);

    if (payerKey === undefined) {
      throw new Error('Failed to decompile message because no account keys were found');
    }

    const instructions = [];

    for (const compiledIx of compiledInstructions) {
      const keys = [];

      for (const keyIndex of compiledIx.accountKeyIndexes) {
        const pubkey = accountKeys.get(keyIndex);

        if (pubkey === undefined) {
          throw new Error(`Failed to find key for account key index ${keyIndex}`);
        }

        const isSigner = keyIndex < numRequiredSignatures;
        let isWritable;

        if (isSigner) {
          isWritable = keyIndex < numWritableSignedAccounts;
        } else if (keyIndex < accountKeys.staticAccountKeys.length) {
          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
        } else {
          isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
          accountKeys.accountKeysFromLookups.writable.length;
        }

        keys.push({
          pubkey,
          isSigner: keyIndex < header.numRequiredSignatures,
          isWritable
        });
      }

      const programId = accountKeys.get(compiledIx.programIdIndex);

      if (programId === undefined) {
        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
      }

      instructions.push(new TransactionInstruction({
        programId,
        data: toBuffer(compiledIx.data),
        keys
      }));
    }

    return new TransactionMessage({
      payerKey,
      instructions,
      recentBlockhash
    });
  }

  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }

  compileToV0Message(addressLookupTableAccounts) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts
    });
  }

}

/**
 * Versioned transaction class
 */
class VersionedTransaction {
  get version() {
    return this.message.version;
  }

  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;

    if (signatures !== undefined) {
      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];

      for (let i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }

      this.signatures = defaultSignatures;
    }

    this.message = message;
  }

  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout__namespace.seq(signature(), this.signatures.length, 'signatures'), BufferLayout__namespace.blob(serializedMessage.length, 'serializedMessage')]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }

  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);

    for (let i = 0; i < signaturesLength; i++) {
      signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    }

    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new VersionedTransaction(message, signatures);
  }

  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);

    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));
      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }

  addSignature(publicKey, signature) {
    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(publicKey));
    assert(signerIndex >= 0, `Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature;
  }

}

const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
const SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
const SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;

  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature: signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
    }

    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }

  if (status.err) {
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }

  return signature;
}

// zzz
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */
function encodeData(type, fields) {
  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  const data = buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}
/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */

function decodeData$1(type, buffer) {
  let data;

  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }

  if (data.instruction !== type.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);
  }

  return data;
}

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */

const FeeCalculatorLayout = BufferLayout__namespace.nu64('lamportsPerSignature');
/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */

const NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('version'), BufferLayout__namespace.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout__namespace.struct([FeeCalculatorLayout], 'feeCalculator')]);
const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */

/**
 * NonceAccount class
 */
class NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */


  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }

}

const encodeDecode = layout => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return {
    decode,
    encode
  };
};

const bigInt = length => property => {
  const layout = BufferLayout.blob(length, property);
  const {
    encode,
    decode
  } = encodeDecode(layout);
  const bigIntLayout = layout;

  bigIntLayout.decode = (buffer$1, offset) => {
    const src = decode(buffer$1, offset);
    return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));
  };

  bigIntLayout.encode = (bigInt, buffer, offset) => {
    const src = bigintBuffer.toBufferLE(bigInt, length);
    return encode(src, buffer, offset);
  };

  return bigIntLayout;
};

const u64 = bigInt(8);

/**
 * Create account system transaction params
 */

/**
 * System Instruction class
 */
class SystemInstruction {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Decode a system instruction and retrieve the instruction type.
   */


  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a SystemInstruction');
    }

    return type;
  }
  /**
   * Decode a create account system instruction and retrieve the instruction params.
   */


  static decodeCreateAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */


  static decodeTransfer(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      lamports
    };
  }
  /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */


  static decodeTransferWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      basePubkey: instruction.keys[1].pubkey,
      toPubkey: instruction.keys[2].pubkey,
      lamports,
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */


  static decodeAllocate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      space
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      space
    };
  }
  /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */


  static decodeAllocateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign system instruction and retrieve the instruction params.
   */


  static decodeAssign(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */


  static decodeAssignWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */


  static decodeCreateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      base,
      seed,
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */


  static decodeNonceInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      authorized
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: new PublicKey(authorized)
    };
  }
  /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */


  static decodeNonceAdvance(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */


  static decodeNonceWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
  }
  /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */


  static decodeNonceAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(authorized)
    };
  }
  /**
   * @internal
   */


  static checkProgramId(programId) {
    if (!programId.equals(SystemProgram.programId)) {
      throw new Error('invalid instruction; programId is not SystemProgram');
    }
  }
  /**
   * @internal
   */


  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
/**
 * An enumeration of valid SystemInstructionType's
 */

/**
 * An enumeration of valid system InstructionType's
 * @internal
 */
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  }
});
/**
 * Factory class for transactions to interact with the System program
 */

class SystemProgram {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the System program
   */


  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */


  static transfer(params) {
    let data;
    let keys;

    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */


  static assign(params) {
    let data;
    let keys;

    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */


  static createAccountWithSeed(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];

    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */


  static createNonceAccount(params) {
    const transaction = new Transaction();

    if ('basePubkey' in params && 'seed' in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }

    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */


  static nonceInitialize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */


  static nonceAdvance(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */


  static nonceWithdraw(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */


  static nonceAuthorize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */


  static allocate(params) {
    let data;
    let keys;

    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }

}
SystemProgram.programId = new PublicKey('11111111111111111111111111111111');

// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
/**
 * Program loader interface
 */

class Loader {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Amount of program data placed in each load Transaction
   */


  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * ( // Every transaction requires two signatures (payer + program)
    Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
    1) // Add one for Finalize transaction
    ;
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */


  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length); // Fetch program account info to check if it has already been created

      const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');
      let transaction = null;

      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error('Program load failed, account is already executable');
          return false;
        }

        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }

        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }

        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      } // If the account is already created correctly, skip this step
      // and proceed directly to loading instructions


      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: 'confirmed'
        });
      }
    }
    const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.u32('offset'), BufferLayout__namespace.u32('bytesLength'), BufferLayout__namespace.u32('bytesLengthPadding'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('byte'), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'bytes')]);
    const chunkSize = Loader.chunkSize;
    let offset = 0;
    let array = data;
    let transactions = [];

    while (array.length > 0) {
      const bytes = array.slice(0, chunkSize);
      const data = buffer.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset,
        bytes: bytes,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'confirmed'
      })); // Delay between sends in an attempt to reduce rate limit errors

      if (connection._rpcEndpoint.includes('solana.com')) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }

      offset += chunkSize;
      array = array.slice(chunkSize);
    }

    await Promise.all(transactions); // Finalize the account loaded with program data for execution

    {
      const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')]);
      const data = buffer.Buffer.alloc(dataLayout.span);
      dataLayout.encode({
        instruction: 1 // Finalize instruction

      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data
      });
      await sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'confirmed'
      });
    } // success

    return true;
  }

}
Loader.chunkSize = CHUNK_SIZE;

const BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');
/**
 * Factory class for transactions to interact with a program loader
 */

class BpfLoader {
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return Loader.getMinNumSignatures(dataLength);
  }
  /**
   * Load a SBF program
   *
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the SBF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */


  static load(connection, payer, program, elf, loaderProgramId) {
    return Loader.load(connection, payer, program, loaderProgramId, elf);
  }

}

var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) {
			keys.push(name);
		}
		return keys;
	};

function stringify(val, isArrayProp) {
	var i, max, str, keys, key, propVal, toStr;
	if (val === true) {
		return "true";
	}
	if (val === false) {
		return "false";
	}
	switch (typeof val) {
		case "object":
			if (val === null) {
				return null;
			} else if (val.toJSON && typeof val.toJSON === "function") {
				return stringify(val.toJSON(), isArrayProp);
			} else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = '[';
					max = val.length - 1;
					for(i = 0; i < max; i++) {
						str += stringify(val[i], true) + ',';
					}
					if (max > -1) {
						str += stringify(val[i], true);
					}
					return str + ']';
				} else if (toStr === "[object Object]") {
					// only object is left
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i = 0;
					while (i < max) {
						key = keys[i];
						propVal = stringify(val[key], false);
						if (propVal !== undefined) {
							if (str) {
								str += ',';
							}
							str += JSON.stringify(key) + ':' + propVal;
						}
						i++;
					}
					return '{' + str + '}';
				} else {
					return JSON.stringify(val);
				}
			}
		case "function":
		case "undefined":
			return isArrayProp ? null : undefined;
		case "string":
			return JSON.stringify(val);
		default:
			return isFinite(val) ? val : null;
	}
}

var fastStableStringify = function(val) {
	var returnVal = stringify(val, false);
	if (returnVal !== undefined) {
		return ''+ returnVal;
	}
};

var fastStableStringify$1 = fastStableStringify;

const MINIMUM_SLOT_PER_EPOCH = 32; // Returns the number of trailing zeros in the binary representation of self.

function trailingZeros(n) {
  let trailingZeros = 0;

  while (n > 1) {
    n /= 2;
    trailingZeros++;
  }

  return trailingZeros;
} // Returns the smallest power of two greater than or equal to n


function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}
/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */


class EpochSchedule {
  /** The maximum number of slots in each epoch */

  /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */

  /** Indicates whether epochs start short and grow */

  /** The first epoch with `slotsPerEpoch` slots */

  /** The first slot of `firstNormalEpoch` */
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }

  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }

  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }

  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }

  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }

  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }

}

class SendTransactionError extends Error {
  constructor(message, logs) {
    super(message);
    this.logs = void 0;
    this.logs = logs;
  }

} // Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/

const SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
  constructor({
    code,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = void 0;
    this.data = void 0;
    this.code = code;
    this.data = data;
    this.name = 'SolanaJSONRPCError';
  }

}

var fetchImpl = globalThis.fetch;

class RpcWebSocketClient extends RpcWebSocketCommonClient__default["default"] {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = url => {
      const rpc = createRpc__default["default"](url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000,
        ...options
      });

      if ('socket' in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }

      return rpc;
    };

    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }

  call(...args) {
    const readyState = this.underlyingSocket?.readyState;

    if (readyState === 1
    /* WebSocket.OPEN */
    ) {
      return super.call(...args);
    }

    return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
  }

  notify(...args) {
    const readyState = this.underlyingSocket?.readyState;

    if (readyState === 1
    /* WebSocket.OPEN */
    ) {
      return super.notify(...args);
    }

    return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
  }

}

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
const NUM_TICKS_PER_SECOND = 160;
/**
 * @internal
 */

const DEFAULT_TICKS_PER_SLOT = 64;
/**
 * @internal
 */

const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
/**
 * @internal
 */

const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

/**
 * @internal
 */

/**
 * Decode account data buffer using an AccountType
 * @internal
 */
function decodeData(type, data) {
  let decoded;

  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }

  if (decoded.typeIndex !== type.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);
  }

  return decoded;
}

/// The serialized size of lookup table metadata
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }

  isActive() {
    const U64_MAX = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === U64_MAX;
  }

  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert(serializedAddressesLen >= 0, 'lookup table is invalid');
    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
      addresses: addresses.map(address => new PublicKey(address))
    };
  }

}
const LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('typeIndex'), u64('deactivationSlot'), BufferLayout__namespace.nu64('lastExtendedSlot'), BufferLayout__namespace.u8('lastExtendedStartIndex'), BufferLayout__namespace.u8(), // option
  BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), 'authority')])
};

const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  const matches = endpoint.match(URL_RE);

  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }

  const [_, // eslint-disable-line @typescript-eslint/no-unused-vars
  hostish, portWithColon, rest] = matches;
  const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint
  // is explictly specifying the endpoint port (HTTP-based RPC), assuming
  // we're directly trying to connect to solana-validator's ws listening port.
  // When the endpoint omits the port, we're connecting to the protocol
  // default ports: http(80) or https(443) and it's assumed we're behind a reverse
  // proxy which manages WebSocket upgrade and backend port redirection.
  startPort == null ? '' : `:${startPort + 1}`;
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}

const PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), value => new PublicKey(value));
const RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal('base64')]);
const BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, value => buffer.Buffer.from(value[0], 'base64'));
/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */

const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */

/* @internal */
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  }

  return putativeUrl;
}
/** @internal */


function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;

  if (typeof commitmentOrConfig === 'string') {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }

  return {
    commitment,
    config
  };
}
/**
 * @internal
 */


function createRpcResult(result) {
  return superstruct.union([superstruct.type({
    jsonrpc: superstruct.literal('2.0'),
    id: superstruct.string(),
    result
  }), superstruct.type({
    jsonrpc: superstruct.literal('2.0'),
    id: superstruct.string(),
    error: superstruct.type({
      code: superstruct.unknown(),
      message: superstruct.string(),
      data: superstruct.optional(superstruct.any())
    })
  })]);
}

const UnknownRpcResult = createRpcResult(superstruct.unknown());
/**
 * @internal
 */

function jsonRpcResult(schema) {
  return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, value => {
    if ('error' in value) {
      return value;
    } else {
      return { ...value,
        result: superstruct.create(value.result, schema)
      };
    }
  });
}
/**
 * @internal
 */


function jsonRpcResultAndContext(value) {
  return jsonRpcResult(superstruct.type({
    context: superstruct.type({
      slot: superstruct.number()
    }),
    value
  }));
}
/**
 * @internal
 */


function notificationResultAndContext(value) {
  return superstruct.type({
    context: superstruct.type({
      slot: superstruct.number()
    }),
    value
  });
}
/**
 * @internal
 */


function versionedMessageFromResponse(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map(accountKey => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map(ix => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58__default["default"].decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */


const GetInflationGovernorResult = superstruct.type({
  foundation: superstruct.number(),
  foundationTerm: superstruct.number(),
  initial: superstruct.number(),
  taper: superstruct.number(),
  terminal: superstruct.number()
});
/**
 * The inflation reward for an epoch
 */

/**
 * Expected JSON RPC response for the "getInflationReward" message
 */
const GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({
  epoch: superstruct.number(),
  effectiveSlot: superstruct.number(),
  amount: superstruct.number(),
  postBalance: superstruct.number(),
  commission: superstruct.optional(superstruct.nullable(superstruct.number()))
}))));

/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
const GetInflationRateResult = superstruct.type({
  total: superstruct.number(),
  validator: superstruct.number(),
  foundation: superstruct.number(),
  epoch: superstruct.number()
});
/**
 * Information about the current epoch
 */

const GetEpochInfoResult = superstruct.type({
  epoch: superstruct.number(),
  slotIndex: superstruct.number(),
  slotsInEpoch: superstruct.number(),
  absoluteSlot: superstruct.number(),
  blockHeight: superstruct.optional(superstruct.number()),
  transactionCount: superstruct.optional(superstruct.number())
});
const GetEpochScheduleResult = superstruct.type({
  slotsPerEpoch: superstruct.number(),
  leaderScheduleSlotOffset: superstruct.number(),
  warmup: superstruct.boolean(),
  firstNormalEpoch: superstruct.number(),
  firstNormalSlot: superstruct.number()
});
/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */

const GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
/**
 * Transaction error or null
 */

const TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
/**
 * Signature status for a transaction
 */

const SignatureStatusResult = superstruct.type({
  err: TransactionErrorResult
});
/**
 * Transaction signature received notification
 */

const SignatureReceivedResult = superstruct.literal('receivedSignature');
/**
 * Version info for a node
 */

const VersionResult = superstruct.type({
  'solana-core': superstruct.string(),
  'feature-set': superstruct.optional(superstruct.number())
});
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({
  err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
  logs: superstruct.nullable(superstruct.array(superstruct.string())),
  accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
    executable: superstruct.boolean(),
    owner: superstruct.string(),
    lamports: superstruct.number(),
    data: superstruct.array(superstruct.string()),
    rentEpoch: superstruct.optional(superstruct.number())
  }))))),
  unitsConsumed: superstruct.optional(superstruct.number()),
  returnData: superstruct.optional(superstruct.nullable(superstruct.type({
    programId: superstruct.string(),
    data: superstruct.tuple([superstruct.string(), superstruct.literal('base64')])
  })))
}));

/**
 * Expected JSON RPC response for the "getBlockProduction" message
 */
const BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({
  byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
  range: superstruct.type({
    firstSlot: superstruct.number(),
    lastSlot: superstruct.number()
  })
}));
/**
 * A performance sample
 */

function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch = customFetch ? customFetch : fetchImpl;
  let agent;

  {
    if (httpAgent != null) {
      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');
    }
  }

  let fetchWithMiddleware;

  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch(...modifiedFetchArgs);
    };
  }

  const clientBrowser = new RpcClient__default["default"](async (request, callback) => {
    const options = {
      method: 'POST',
      body: request,
      agent,
      headers: Object.assign({
        'Content-Type': 'application/json'
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };

    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;

      for (;;) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch(url, options);
        }

        if (res.status !== 429
        /* Too many requests */
        ) {
          break;
        }

        if (disableRetryOnRateLimit === true) {
          break;
        }

        too_many_requests_retries -= 1;

        if (too_many_requests_retries === 0) {
          break;
        }

        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }

      const text = await res.text();

      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error) callback(err);
    }
  }, {});
  return clientBrowser;
}

function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }

        resolve(response);
      });
    });
  };
}

function createRpcBatchRequest(client) {
  return requests => {
    return new Promise((resolve, reject) => {
      // Do nothing if requests is empty
      if (requests.length === 0) resolve([]);
      const batch = requests.map(params => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }

        resolve(response);
      });
    });
  };
}
/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */


const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */

const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */

const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */

const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */

const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */

const SlotRpcResult = jsonRpcResult(superstruct.number());
/**
 * Supply
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */
const GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({
  total: superstruct.number(),
  circulating: superstruct.number(),
  nonCirculating: superstruct.number(),
  nonCirculatingAccounts: superstruct.array(PublicKeyFromString)
}));
/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */

/**
 * Expected JSON RPC structure for token amounts
 */
const TokenAmountResult = superstruct.type({
  amount: superstruct.string(),
  uiAmount: superstruct.nullable(superstruct.number()),
  decimals: superstruct.number(),
  uiAmountString: superstruct.optional(superstruct.string())
});
/**
 * Token address and balance.
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */
const GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  address: PublicKeyFromString,
  amount: superstruct.string(),
  uiAmount: superstruct.nullable(superstruct.number()),
  decimals: superstruct.number(),
  uiAmountString: superstruct.optional(superstruct.string())
})));
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */

const GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  pubkey: PublicKeyFromString,
  account: superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString,
    lamports: superstruct.number(),
    data: BufferFromRawAccountData,
    rentEpoch: superstruct.number()
  })
})));
const ParsedAccountDataResult = superstruct.type({
  program: superstruct.string(),
  parsed: superstruct.unknown(),
  space: superstruct.number()
});
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */

const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  pubkey: PublicKeyFromString,
  account: superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString,
    lamports: superstruct.number(),
    data: ParsedAccountDataResult,
    rentEpoch: superstruct.number()
  })
})));
/**
 * Pair of an account address and its balance
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */
const GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
  lamports: superstruct.number(),
  address: PublicKeyFromString
})));
/**
 * @internal
 */

const AccountInfoResult = superstruct.type({
  executable: superstruct.boolean(),
  owner: PublicKeyFromString,
  lamports: superstruct.number(),
  data: BufferFromRawAccountData,
  rentEpoch: superstruct.number()
});
/**
 * @internal
 */

const KeyedAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), value => {
  if (Array.isArray(value)) {
    return superstruct.create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
/**
 * @internal
 */

const ParsedAccountInfoResult = superstruct.type({
  executable: superstruct.boolean(),
  owner: PublicKeyFromString,
  lamports: superstruct.number(),
  data: ParsedOrRawAccountData,
  rentEpoch: superstruct.number()
});
const KeyedParsedAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
/**
 * @internal
 */

const StakeActivationResult = superstruct.type({
  state: superstruct.union([superstruct.literal('active'), superstruct.literal('inactive'), superstruct.literal('activating'), superstruct.literal('deactivating')]),
  active: superstruct.number(),
  inactive: superstruct.number()
});
/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({
  signature: superstruct.string(),
  slot: superstruct.number(),
  err: TransactionErrorResult,
  memo: superstruct.nullable(superstruct.string()),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
})));
/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */

const GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({
  signature: superstruct.string(),
  slot: superstruct.number(),
  err: TransactionErrorResult,
  memo: superstruct.nullable(superstruct.string()),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
})));
/***
 * Expected JSON RPC response for the "accountNotification" message
 */

const AccountNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(AccountInfoResult)
});
/**
 * @internal
 */

const ProgramAccountInfoResult = superstruct.type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
/***
 * Expected JSON RPC response for the "programNotification" message
 */

const ProgramAccountNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
/**
 * @internal
 */

const SlotInfoResult = superstruct.type({
  parent: superstruct.number(),
  slot: superstruct.number(),
  root: superstruct.number()
});
/**
 * Expected JSON RPC response for the "slotNotification" message
 */

const SlotNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: SlotInfoResult
});
/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */

/**
 * @internal
 */
const SlotUpdateResult = superstruct.union([superstruct.type({
  type: superstruct.union([superstruct.literal('firstShredReceived'), superstruct.literal('completed'), superstruct.literal('optimisticConfirmation'), superstruct.literal('root')]),
  slot: superstruct.number(),
  timestamp: superstruct.number()
}), superstruct.type({
  type: superstruct.literal('createdBank'),
  parent: superstruct.number(),
  slot: superstruct.number(),
  timestamp: superstruct.number()
}), superstruct.type({
  type: superstruct.literal('frozen'),
  slot: superstruct.number(),
  timestamp: superstruct.number(),
  stats: superstruct.type({
    numTransactionEntries: superstruct.number(),
    numSuccessfulTransactions: superstruct.number(),
    numFailedTransactions: superstruct.number(),
    maxTransactionsPerEntry: superstruct.number()
  })
}), superstruct.type({
  type: superstruct.literal('dead'),
  slot: superstruct.number(),
  timestamp: superstruct.number(),
  err: superstruct.string()
})]);
/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */

const SlotUpdateNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: SlotUpdateResult
});
/**
 * Expected JSON RPC response for the "signatureNotification" message
 */

const SignatureNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))
});
/**
 * Expected JSON RPC response for the "rootNotification" message
 */

const RootNotificationResult = superstruct.type({
  subscription: superstruct.number(),
  result: superstruct.number()
});
const ContactInfoResult = superstruct.type({
  pubkey: superstruct.string(),
  gossip: superstruct.nullable(superstruct.string()),
  tpu: superstruct.nullable(superstruct.string()),
  rpc: superstruct.nullable(superstruct.string()),
  version: superstruct.nullable(superstruct.string())
});
const VoteAccountInfoResult = superstruct.type({
  votePubkey: superstruct.string(),
  nodePubkey: superstruct.string(),
  activatedStake: superstruct.number(),
  epochVoteAccount: superstruct.boolean(),
  epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
  commission: superstruct.number(),
  lastVote: superstruct.number(),
  rootSlot: superstruct.nullable(superstruct.number())
});
/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */

const GetVoteAccounts = jsonRpcResult(superstruct.type({
  current: superstruct.array(VoteAccountInfoResult),
  delinquent: superstruct.array(VoteAccountInfoResult)
}));
const ConfirmationStatus = superstruct.union([superstruct.literal('processed'), superstruct.literal('confirmed'), superstruct.literal('finalized')]);
const SignatureStatusResponse = superstruct.type({
  slot: superstruct.number(),
  confirmations: superstruct.nullable(superstruct.number()),
  err: TransactionErrorResult,
  confirmationStatus: superstruct.optional(ConfirmationStatus)
});
/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */

const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));
/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */

const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());
const AddressTableLookupStruct = superstruct.type({
  accountKey: PublicKeyFromString,
  writableIndexes: superstruct.array(superstruct.number()),
  readonlyIndexes: superstruct.array(superstruct.number())
});
const ConfirmedTransactionResult = superstruct.type({
  signatures: superstruct.array(superstruct.string()),
  message: superstruct.type({
    accountKeys: superstruct.array(superstruct.string()),
    header: superstruct.type({
      numRequiredSignatures: superstruct.number(),
      numReadonlySignedAccounts: superstruct.number(),
      numReadonlyUnsignedAccounts: superstruct.number()
    }),
    instructions: superstruct.array(superstruct.type({
      accounts: superstruct.array(superstruct.number()),
      data: superstruct.string(),
      programIdIndex: superstruct.number()
    })),
    recentBlockhash: superstruct.string(),
    addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))
  })
});
const AnnotatedAccountKey = superstruct.type({
  pubkey: PublicKeyFromString,
  signer: superstruct.boolean(),
  writable: superstruct.boolean(),
  source: superstruct.optional(superstruct.union([superstruct.literal('transaction'), superstruct.literal('lookupTable')]))
});
const ConfirmedTransactionAccountsModeResult = superstruct.type({
  accountKeys: superstruct.array(AnnotatedAccountKey),
  signatures: superstruct.array(superstruct.string())
});
const ParsedInstructionResult = superstruct.type({
  parsed: superstruct.unknown(),
  program: superstruct.string(),
  programId: PublicKeyFromString
});
const RawInstructionResult = superstruct.type({
  accounts: superstruct.array(PublicKeyFromString),
  data: superstruct.string(),
  programId: PublicKeyFromString
});
const InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);
const UnknownInstructionResult = superstruct.union([superstruct.type({
  parsed: superstruct.unknown(),
  program: superstruct.string(),
  programId: superstruct.string()
}), superstruct.type({
  accounts: superstruct.array(superstruct.string()),
  data: superstruct.string(),
  programId: superstruct.string()
})]);
const ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, value => {
  if ('accounts' in value) {
    return superstruct.create(value, RawInstructionResult);
  } else {
    return superstruct.create(value, ParsedInstructionResult);
  }
});
/**
 * @internal
 */

const ParsedConfirmedTransactionResult = superstruct.type({
  signatures: superstruct.array(superstruct.string()),
  message: superstruct.type({
    accountKeys: superstruct.array(AnnotatedAccountKey),
    instructions: superstruct.array(ParsedOrRawInstruction),
    recentBlockhash: superstruct.string(),
    addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))
  })
});
const TokenBalanceResult = superstruct.type({
  accountIndex: superstruct.number(),
  mint: superstruct.string(),
  owner: superstruct.optional(superstruct.string()),
  uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = superstruct.type({
  writable: superstruct.array(PublicKeyFromString),
  readonly: superstruct.array(PublicKeyFromString)
});
/**
 * @internal
 */

const ConfirmedTransactionMetaResult = superstruct.type({
  err: TransactionErrorResult,
  fee: superstruct.number(),
  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
    index: superstruct.number(),
    instructions: superstruct.array(superstruct.type({
      accounts: superstruct.array(superstruct.number()),
      data: superstruct.string(),
      programIdIndex: superstruct.number()
    }))
  })))),
  preBalances: superstruct.array(superstruct.number()),
  postBalances: superstruct.array(superstruct.number()),
  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  loadedAddresses: superstruct.optional(LoadedAddressesResult),
  computeUnitsConsumed: superstruct.optional(superstruct.number())
});
/**
 * @internal
 */

const ParsedConfirmedTransactionMetaResult = superstruct.type({
  err: TransactionErrorResult,
  fee: superstruct.number(),
  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
    index: superstruct.number(),
    instructions: superstruct.array(ParsedOrRawInstruction)
  })))),
  preBalances: superstruct.array(superstruct.number()),
  postBalances: superstruct.array(superstruct.number()),
  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
  loadedAddresses: superstruct.optional(LoadedAddressesResult),
  computeUnitsConsumed: superstruct.optional(superstruct.number())
});
const TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal('legacy')]);
/** @internal */

const RewardsResult = superstruct.type({
  pubkey: superstruct.string(),
  lamports: superstruct.number(),
  postBalance: superstruct.nullable(superstruct.number()),
  rewardType: superstruct.nullable(superstruct.string()),
  commission: superstruct.optional(superstruct.nullable(superstruct.number()))
});
/**
 * Expected JSON RPC response for the "getBlock" message
 */

const GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */

const GetNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */

const GetAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */

const GetParsedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ParsedConfirmedTransactionResult,
    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */

const GetParsedAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
    version: superstruct.optional(TransactionVersionStruct)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */

const GetParsedNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number()),
  blockHeight: superstruct.nullable(superstruct.number())
})));
/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */

const GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  transactions: superstruct.array(superstruct.type({
    transaction: ConfirmedTransactionResult,
    meta: superstruct.nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: superstruct.optional(superstruct.array(RewardsResult)),
  blockTime: superstruct.nullable(superstruct.number())
})));
/**
 * Expected JSON RPC response for the "getBlock" message
 */

const GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  blockhash: superstruct.string(),
  previousBlockhash: superstruct.string(),
  parentSlot: superstruct.number(),
  signatures: superstruct.array(superstruct.string()),
  blockTime: superstruct.nullable(superstruct.number())
})));
/**
 * Expected JSON RPC response for the "getTransaction" message
 */

const GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  slot: superstruct.number(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
  transaction: ConfirmedTransactionResult,
  version: superstruct.optional(TransactionVersionStruct)
})));
/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */

const GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
  slot: superstruct.number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
  version: superstruct.optional(TransactionVersionStruct)
})));
/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */

const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.type({
  blockhash: superstruct.string(),
  feeCalculator: superstruct.type({
    lamportsPerSignature: superstruct.number()
  })
}));
/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */

const GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({
  blockhash: superstruct.string(),
  lastValidBlockHeight: superstruct.number()
}));
const PerfSampleResult = superstruct.type({
  slot: superstruct.number(),
  numTransactions: superstruct.number(),
  numSlots: superstruct.number(),
  samplePeriodSecs: superstruct.number()
});
/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */

const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));
/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */

const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({
  feeCalculator: superstruct.type({
    lamportsPerSignature: superstruct.number()
  })
})));
/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */

const RequestAirdropRpcResult = jsonRpcResult(superstruct.string());
/**
 * Expected JSON RPC response for the "sendTransaction" message
 */

const SendTransactionRpcResult = jsonRpcResult(superstruct.string());
/**
 * Information about the latest slot being processed by a node
 */

/**
 * @internal
 */
const LogsResult = superstruct.type({
  err: TransactionErrorResult,
  logs: superstruct.array(superstruct.string()),
  signature: superstruct.string()
});
/**
 * Logs result.
 */

/**
 * Expected JSON RPC response for the "logsNotification" message.
 */
const LogsNotificationResult = superstruct.type({
  result: notificationResultAndContext(LogsResult),
  subscription: superstruct.number()
});
/**
 * Filter for log subscriptions.
 */

/** @internal */
const COMMON_HTTP_HEADERS = {
  'solana-client': `js/${"0.0.0-development" }`
};
/**
 * A connection to a fullnode JSON RPC endpoint
 */

class Connection {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal
   * A number that we increment every time an active connection closes.
   * Used to determine whether the same socket connection that was open
   * when an async operation started is the same one that's active when
   * its continuation fires.
   *
   */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Special case.
   * After a signature is processed, RPCs automatically dispose of the
   * subscription on the server side. We need to track which of these
   * subscriptions have been disposed in such a way, so that we know
   * whether the client is dealing with a not-yet-processed signature
   * (in which case we must tear down the server subscription) or an
   * already-processed signature (in which case the client can simply
   * clear out the subscription locally without telling the server).
   *
   * NOTE: There is a proposal to eliminate this special case, here:
   * https://github.com/solana-labs/solana/issues/18892
   */

  /** @internal */

  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint, commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = new Set();
    let wsEndpoint;
    let httpHeaders;
    let fetch;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;

    if (commitmentOrConfig && typeof commitmentOrConfig === 'string') {
      this._commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      this._commitment = commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = commitmentOrConfig.wsEndpoint;
      httpHeaders = commitmentOrConfig.httpHeaders;
      fetch = commitmentOrConfig.fetch;
      fetchMiddleware = commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = commitmentOrConfig.httpAgent;
    }

    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });

    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));

    this._rpcWebSocket.on('error', this._wsOnError.bind(this));

    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));

    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));

    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));

    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));

    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));

    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));

    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));

    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */


  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */


  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */


  async getBalanceAndContext(publicKey, commitmentOrConfig) {
    /** @internal */
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getBalance', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */


  async getBalance(publicKey, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {
      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */


  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }

    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */


  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
    }

    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */


  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);
    const res = superstruct.create(unsafeRes, SlotRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
    }

    return res.result;
  }
  /**
   * Fetch information about the current supply
   */


  async getSupply(config) {
    let configArg = {};

    if (typeof config === 'string') {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = { ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }

    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);
    const res = superstruct.create(unsafeRes, GetSupplyRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get supply');
    }

    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */


  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenSupply', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
    }

    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */


  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
    }

    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
   */


  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];

    if ('mint' in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }

    const args = this._buildArgs(_args, commitment, 'base64', config);

    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */


  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];

    if ('mint' in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }

    const args = this._buildArgs(_args, commitment, 'jsonParsed');

    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */


  async getLargestAccounts(config) {
    const arg = { ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);
    const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');
    }

    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */


  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);
    const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');
    }

    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */


  async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);

    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */


  async getParsedAccountInfo(publicKey, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);

    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */


  async getAccountInfo(publicKey, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */


  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const keys = publicKeys.map(key => key.toBase58());

    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);

    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }

    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */


  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys = publicKeys.map(key => key.toBase58());

    const args = this._buildArgs([keys], commitment, 'base64', config);

    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }

    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */


  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   */


  async getStakeActivation(publicKey, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined
    /* encoding */
    , { ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });

    const unsafeRes = await this._rpcRequest('getStakeActivation', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */


  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding,
      ...configWithoutEncoding
    } = config || {};

    const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);

    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedAccountInfoResult)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }

    return res.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */


  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);

    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);

    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }

    return res.result;
  }

  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    let rawSignature;

    if (typeof strategy == 'string') {
      rawSignature = strategy;
    } else {
      const config = strategy;

      if (config.abortSignal?.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }

      rawSignature = config.signature;
    }

    let decodedSignature;

    try {
      decodedSignature = bs58__default["default"].decode(rawSignature);
    } catch (err) {
      throw new Error('signature must be base58 encoded: ' + rawSignature);
    }

    assert(decodedSignature.length === 64, 'signature has invalid length');

    if (typeof strategy === 'string') {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ('lastValidBlockHeight' in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }

  getCancellationPromise(signal) {
    return new Promise((_, reject) => {
      if (signal == null) {
        return;
      }

      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener('abort', () => {
          reject(signal.reason);
        });
      }
    });
  }

  getTransactionConfirmationPromise({
    commitment,
    signature
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature, (result, context) => {
          signatureSubscriptionId = undefined;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: exports.TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise(resolveSubscriptionSetup => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, nextState => {
              if (nextState === 'subscribed') {
                resolveSubscriptionSetup();
              }
            });
          }
        });

        (async () => {
          await subscriptionSetupPromise;
          if (done) return;
          const response = await this.getSignatureStatus(signature);
          if (done) return;

          if (response == null) {
            return;
          }

          const {
            context,
            value
          } = response;

          if (value == null) {
            return;
          }

          if (value?.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case 'confirmed':
              case 'single':
              case 'singleGossip':
                {
                  if (value.confirmationStatus === 'processed') {
                    return;
                  }

                  break;
                }

              case 'finalized':
              case 'max':
              case 'root':
                {
                  if (value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed') {
                    return;
                  }

                  break;
                }
              // exhaust enums to ensure full coverage

              case 'processed':
              case 'recent':
            }

            done = true;
            resolve({
              __type: exports.TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });

    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = undefined;
      }

      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = undefined;
      }
    };

    return {
      abortConfirmation,
      confirmationPromise
    };
  }

  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise(resolve => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e) {
          return -1;
        }
      };

      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;

        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1000);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }

        resolve({
          __type: exports.TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;

    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);

      if (outcome.__type === exports.TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature);
      }
    } finally {
      done = true;
      abortConfirmation();
    }

    return result;
  }

  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise(resolve => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;

      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount?.nonce;
        } catch (e) {
          // If for whatever reason we can't reach/read the nonce
          // account, just keep using the last-known value.
          return currentNonceValue;
        }
      };

      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done) return;

        while (true // eslint-disable-line no-constant-condition
        ) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: exports.TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }

          await sleep(2000);
          if (done) return;
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;

    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);

      if (outcome.__type === exports.TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        // Double check that the transaction is indeed unconfirmed.
        let signatureStatus;

        while (true // eslint-disable-line no-constant-condition
        ) {
          const status = await this.getSignatureStatus(signature);

          if (status == null) {
            break;
          }

          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep(400);
            continue;
          }

          signatureStatus = status;
          break;
        }

        if (signatureStatus?.value) {
          const commitmentForStatus = commitment || 'finalized';
          const {
            confirmationStatus
          } = signatureStatus.value;

          switch (commitmentForStatus) {
            case 'processed':
            case 'recent':
              if (confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }

              break;

            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }

              break;

            case 'finalized':
            case 'max':
            case 'root':
              if (confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }

              break;

            default:
              // Exhaustive switch.
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              (_ => {})(commitmentForStatus);

          }

          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }

    return result;
  }

  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature
  }) {
    let timeoutId;
    const expiryPromise = new Promise(resolve => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;

      switch (commitment) {
        case 'processed':
        case 'recent':
        case 'single':
        case 'confirmed':
        case 'singleGossip':
          {
            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;
            break;
          }
      }

      timeoutId = setTimeout(() => resolve({
        __type: exports.TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    let result;

    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);

      if (outcome.__type === exports.TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }

    return result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */


  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest('getClusterNodes', []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');
    }

    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */


  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);
    const res = superstruct.create(unsafeRes, GetVoteAccounts);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');
    }

    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */


  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getSlot', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot');
    }

    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */


  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getSlotLeader', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');
    }

    return res.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */


  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');
    }

    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */


  async getSignatureStatus(signature, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature], config);
    assert(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */


  async getSignatureStatuses(signatures, config) {
    const params = [signatures];

    if (config) {
      params.push(config);
    }

    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);
    const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');
    }

    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */


  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getTransactionCount', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');
    }

    return res.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
   */


  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */


  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);
    const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');
    }

    return res.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */


  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([addresses.map(pubkey => pubkey.toBase58())], commitment, undefined
    /* encoding */
    , { ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });

    const unsafeRes = await this._rpcRequest('getInflationReward', args);
    const res = superstruct.create(unsafeRes, GetInflationRewardResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');
    }

    return res.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */


  async getInflationRate() {
    const unsafeRes = await this._rpcRequest('getInflationRate', []);
    const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');
    }

    return res.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */


  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getEpochInfo', args);
    const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');
    }

    return res.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */


  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);
    const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');
    }

    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */


  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);
    const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');
    }

    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */


  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);

    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);
    const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);

    if ('error' in res) {
      console.warn('Unable to fetch minimum balance for rent exemption');
      return 0;
    }

    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */


  async getRecentBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);
    const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');
    }

    return res.result;
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */


  async getRecentPerformanceSamples(limit) {
    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);
    const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');
    }

    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
   */


  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);

    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);
    const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');
    }

    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */


  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer(message.serialize()).toString('base64');

    const args = this._buildArgs([wireMessage], commitment);

    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');
    }

    if (res.result === null) {
      throw new Error('invalid blockhash');
    }

    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */


  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e) {
      throw new Error('failed to get recent blockhash: ' + e);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */


  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error('failed to get recent blockhash: ' + e);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */


  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);
    const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');
    }

    return res.result;
  }
  /**
   * Fetch the node version
   */


  async getVersion() {
    const unsafeRes = await this._rpcRequest('getVersion', []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get version');
    }

    return res.result;
  }
  /**
   * Fetch the genesis hash
   */


  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest('getGenesisHash', []);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');
    }

    return res.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */


  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);

    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getBlock', args);

    try {
      switch (config?.transactionDetails) {
        case 'accounts':
          {
            const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            return res.result;
          }

        case 'none':
          {
            const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            return res.result;
          }

        default:
          {
            const res = superstruct.create(unsafeRes, GetBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            const {
              result
            } = res;
            return result ? { ...result,
              transactions: result.transactions.map(({
                transaction,
                meta,
                version
              }) => ({
                meta,
                transaction: { ...transaction,
                  message: versionedMessageFromResponse(version, transaction.message)
                },
                version
              }))
            } : null;
          }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, 'failed to get confirmed block');
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */


  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);

    const args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);

    const unsafeRes = await this._rpcRequest('getBlock', args);

    try {
      switch (config?.transactionDetails) {
        case 'accounts':
          {
            const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            return res.result;
          }

        case 'none':
          {
            const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            return res.result;
          }

        default:
          {
            const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);

            if ('error' in res) {
              throw res.error;
            }

            return res.result;
          }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, 'failed to get block');
    }
  }
  /*
   * Returns the current block height of the node
   */


  async getBlockHeight(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgs([], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getBlockHeight', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
    }

    return res.result;
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */


  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;

    if (typeof configOrCommitment === 'string') {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c,
        ...rest
      } = configOrCommitment;
      commitment = c;
      extra = rest;
    }

    const args = this._buildArgs([], commitment, 'base64', extra);

    const unsafeRes = await this._rpcRequest('getBlockProduction', args);
    const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get block production information');
    }

    return res.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */


  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);

    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined
    /* encoding */
    , config);

    const unsafeRes = await this._rpcRequest('getTransaction', args);
    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }

    const result = res.result;
    if (!result) return result;
    return { ...result,
      transaction: { ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */


  async getParsedTransaction(signature, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);

    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);

    const unsafeRes = await this._rpcRequest('getTransaction', args);
    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }

    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */


  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);

      return {
        methodName: 'getTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);

      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
      }

      return res.result;
    });
    return res;
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */


  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined
      /* encoding */
      , config);

      return {
        methodName: 'getTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = superstruct.create(unsafeRes, GetTransactionRpcResult);

      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
      }

      const result = res.result;
      if (!result) return result;
      return { ...result,
        transaction: { ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
   */


  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);

    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
    const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
    }

    const result = res.result;

    if (!result) {
      throw new Error('Confirmed block ' + slot + ' not found');
    }

    const block = { ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: { ...transaction,
            message
          }
        };
      })
    };
    return { ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */


  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);

    const unsafeRes = await this._rpcRequest('getBlocks', args);
    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');
    }

    return res.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */


  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: 'signatures',
      rewards: false
    });

    const unsafeRes = await this._rpcRequest('getBlock', args);
    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get block');
    }

    const result = res.result;

    if (!result) {
      throw new Error('Block ' + slot + ' not found');
    }

    return result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
   */


  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: 'signatures',
      rewards: false
    });

    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
    }

    const result = res.result;

    if (!result) {
      throw new Error('Confirmed block ' + slot + ' not found');
    }

    return result;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
   */


  async getConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment);

    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }

    const result = res.result;
    if (!result) return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return { ...result,
      transaction: Transaction.populate(message, signatures)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
   */


  async getParsedConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');

    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');
    }

    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
   */


  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');

      return {
        methodName: 'getConfirmedTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);

      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
      }

      return res.result;
    });
    return res;
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */


  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();

    while (!('until' in options)) {
      startSlot--;

      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }

      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');

        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes('skipped')) {
          continue;
        } else {
          throw err;
        }
      }
    }

    let highestConfirmedRoot = await this.getSlot('finalized');

    while (!('before' in options)) {
      endSlot++;

      if (endSlot > highestConfirmedRoot) {
        break;
      }

      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);

        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes('skipped')) {
          continue;
        } else {
          throw err;
        }
      }
    }

    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map(info => info.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */


  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);

    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);
    const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');
    }

    return res.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */


  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);

    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);
    const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');
    }

    return res.result;
  }

  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;

    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }

    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */


  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;

    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }

    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */


  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(x => x.value).catch(e => {
      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */


  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);
    const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
    }

    return res.result;
  }
  /**
   * @internal
   */


  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      // Wait for polling to finish
      while (this._pollingBlockhash) {
        await sleep(100);
      }

      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;

      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;

      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }

    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */


  async _pollNewBlockhash() {
    this._pollingBlockhash = true;

    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;

      for (let i = 0; i < 50; i++) {
        const latestBlockhash = await this.getLatestBlockhash('finalized');

        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        } // Sleep for approximately half a slot


        await sleep(MS_PER_SLOT / 2);
      }

      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * get the stake minimum delegation
   */


  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config);

    const args = this._buildArgs([], commitment, 'base64', configArg);

    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);
    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));

    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }

    return res.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */


  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ('message' in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction = versionedTx.serialize();
      const encodedTransaction = buffer.Buffer.from(wireTransaction).toString('base64');

      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {
        throw new Error('Invalid arguments');
      }

      const config = configOrSigners || {};
      config.encoding = 'base64';

      if (!('commitment' in config)) {
        config.commitment = this.commitment;
      }

      const args = [encodedTransaction, config];
      const unsafeRes = await this._rpcRequest('simulateTransaction', args);
      const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);

      if ('error' in res) {
        throw new Error('failed to simulate transaction: ' + res.error.message);
      }

      return res.result;
    }

    let transaction;

    if (transactionOrMessage instanceof Transaction) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction();
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction.populate(transactionOrMessage); // HACK: this function relies on mutating the populated transaction

      transaction._message = transaction._json = undefined;
    }

    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {
      throw new Error('Invalid arguments');
    }

    const signers = configOrSigners;

    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;

      for (;;) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers) break;
        transaction.sign(...signers);

        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        }

        const signature = transaction.signature.toString('base64');

        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
          // The signature of this transaction has not been seen before with the
          // current recentBlockhash, all done. Let's break
          this._blockhashInfo.simulatedSignatures.push(signature);

          break;
        } else {
          // This transaction would be treated as duplicate (its derived signature
          // matched to one of already recorded signatures).
          // So, we must fetch a new blockhash for a different signature by disabling
          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
          disableCache = true;
        }
      }
    }

    const message = transaction._compile();

    const signData = message.serialize();

    const wireTransaction = transaction._serialize(signData);

    const encodedTransaction = wireTransaction.toString('base64');
    const config = {
      encoding: 'base64',
      commitment: this.commitment
    };

    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(key => key.toBase58());
      config['accounts'] = {
        encoding: 'base64',
        addresses
      };
    }

    if (signers) {
      config.sigVerify = true;
    }

    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest('simulateTransaction', args);
    const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);

    if ('error' in res) {
      let logs;

      if ('data' in res.error) {
        logs = res.error.data.logs;

        if (logs && Array.isArray(logs)) {
          const traceIndent = '\n    ';
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }

      throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);
    }

    return res.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */


  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction, signersOrOptions, options) {
    if ('version' in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error('Invalid arguments');
      }

      const wireTransaction = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction, options);
    }

    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {
      throw new Error('Invalid arguments');
    }

    const signers = signersOrOptions;

    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;

      for (;;) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);

        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        }

        const signature = transaction.signature.toString('base64');

        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
          // The signature of this transaction has not been seen before with the
          // current recentBlockhash, all done. Let's break
          this._blockhashInfo.transactionSignatures.push(signature);

          break;
        } else {
          // This transaction would be treated as duplicate (its derived signature
          // matched to one of already recorded signatures).
          // So, we must fetch a new blockhash for a different signature by disabling
          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
          disableCache = true;
        }
      }
    }

    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */


  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString('base64');
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */


  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: 'base64'
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = options && options.preflightCommitment || this.commitment;

    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }

    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }

    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }

    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }

    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest('sendTransaction', args);
    const res = superstruct.create(unsafeRes, SendTransactionRpcResult);

    if ('error' in res) {
      let logs;

      if ('data' in res.error) {
        logs = res.error.data.logs;
      }

      throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);
    }

    return res.result;
  }
  /**
   * @internal
   */


  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      // Ping server every 5s to prevent idle timeouts
      (async () => {
        try {
          await this._rpcWebSocket.notify('ping'); // eslint-disable-next-line no-empty
        } catch {}
      })();
    }, 5000);

    this._updateSubscriptions();
  }
  /**
   * @internal
   */


  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error('ws error:', err.message);
  }
  /**
   * @internal
   */


  _wsOnClose(code) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;

    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }

    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }

    if (code === 1000) {
      // explicit close, check if any subscriptions have been made since close
      this._updateSubscriptions();

      return;
    } // implicit close, prepare subscriptions for auto-reconnect


    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, { ...subscription,
        state: 'pending'
      });
    });
  }
  /**
   * @internal
   */


  _setSubscription(hash, nextSubscription) {
    const prevState = this._subscriptionsByHash[hash]?.state;
    this._subscriptionsByHash[hash] = nextSubscription;

    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];

      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach(cb => {
          try {
            cb(nextSubscription.state); // eslint-disable-next-line no-empty
          } catch {}
        });
      }
    }
  }
  /**
   * @internal
   */


  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _this$_subscriptionSt;

    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];

    if (hash == null) {
      return () => {};
    }

    const stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);

      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }
  /**
   * @internal
   */


  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;

          try {
            this._rpcWebSocket.close();
          } catch (err) {
            // swallow error if socket has already been closed.
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }

      return;
    }

    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }

    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();

      return;
    }

    const activeWebSocketGeneration = this._rpcWebSocketGeneration;

    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };

    await Promise.all( // Don't be tempted to change this to `Object.entries`. We call
    // `_updateSubscriptions` recursively when processing the state,
    // so it's important that we look up the *current* version of
    // each subscription, every time we process a hash.
    Object.keys(this._subscriptionsByHash).map(async hash => {
      const subscription = this._subscriptionsByHash[hash];

      if (subscription === undefined) {
        // This entry has since been deleted. Skip.
        return;
      }

      switch (subscription.state) {
        case 'pending':
        case 'unsubscribed':
          if (subscription.callbacks.size === 0) {
            /**
             * You can end up here when:
             *
             * - a subscription has recently unsubscribed
             *   without having new callbacks added to it
             *   while the unsubscribe was in flight, or
             * - when a pending subscription has its
             *   listeners removed before a request was
             *   sent to the server.
             *
             * Being that nobody is interested in this
             * subscription any longer, delete it.
             */
            delete this._subscriptionsByHash[hash];

            if (subscription.state === 'unsubscribed') {
              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
            }

            await this._updateSubscriptions();
            return;
          }

          await (async () => {
            const {
              args,
              method
            } = subscription;

            try {
              this._setSubscription(hash, { ...subscription,
                state: 'subscribing'
              });

              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);

              this._setSubscription(hash, { ...subscription,
                serverSubscriptionId,
                state: 'subscribed'
              });

              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
              await this._updateSubscriptions();
            } catch (e) {
              if (e instanceof Error) {
                console.error(`${method} error for argument`, args, e.message);
              }

              if (!isCurrentConnectionStillActive()) {
                return;
              } // TODO: Maybe add an 'errored' state or a retry limit?


              this._setSubscription(hash, { ...subscription,
                state: 'pending'
              });

              await this._updateSubscriptions();
            }
          })();
          break;

        case 'subscribed':
          if (subscription.callbacks.size === 0) {
            // By the time we successfully set up a subscription
            // with the server, the client stopped caring about it.
            // Tear it down now.
            await (async () => {
              const {
                serverSubscriptionId,
                unsubscribeMethod
              } = subscription;

              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                /**
                 * Special case.
                 * If we're dealing with a subscription that has been auto-
                 * disposed by the RPC, then we can skip the RPC call to
                 * tear down the subscription here.
                 *
                 * NOTE: There is a proposal to eliminate this special case, here:
                 * https://github.com/solana-labs/solana/issues/18892
                 */
                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
              } else {
                this._setSubscription(hash, { ...subscription,
                  state: 'unsubscribing'
                });

                this._setSubscription(hash, { ...subscription,
                  state: 'unsubscribing'
                });

                try {
                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                } catch (e) {
                  if (e instanceof Error) {
                    console.error(`${unsubscribeMethod} error:`, e.message);
                  }

                  if (!isCurrentConnectionStillActive()) {
                    return;
                  } // TODO: Maybe add an 'errored' state or a retry limit?


                  this._setSubscription(hash, { ...subscription,
                    state: 'subscribed'
                  });

                  await this._updateSubscriptions();
                  return;
                }
              }

              this._setSubscription(hash, { ...subscription,
                state: 'unsubscribed'
              });

              await this._updateSubscriptions();
            })();
          }

          break;
      }
    }));
  }
  /**
   * @internal
   */


  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];

    if (callbacks === undefined) {
      return;
    }

    callbacks.forEach(cb => {
      try {
        cb( // I failed to find a way to convince TypeScript that `cb` is of type
        // `TCallback` which is certainly compatible with `Parameters<TCallback>`.
        // See https://github.com/microsoft/TypeScript/issues/47615
        // @ts-ignore
        ...callbackArgs);
      } catch (e) {
        console.error(e);
      }
    });
  }
  /**
   * @internal
   */


  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, AccountNotificationResult);

    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */


  _makeSubscription(subscriptionConfig,
  /**
   * When preparing `args` for a call to `_makeSubscription`, be sure
   * to carefully apply a default `commitment` property, if necessary.
   *
   * - If the user supplied a `commitment` use that.
   * - Otherwise, if the `Connection::commitment` is set, use that.
   * - Otherwise, set it to the RPC server default: `finalized`.
   *
   * This is extremely important to ensure that these two fundamentally
   * identical subscriptions produce the same identifying hash:
   *
   * - A subscription made without specifying a commitment.
   * - A subscription made where the commitment specified is the same
   *   as the default applied to the subscription above.
   *
   * Example; these two subscriptions must produce the same hash:
   *
   * - An `accountSubscribe` subscription for `'PUBKEY'`
   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
   *   `'finalized'`.
   *
   * See the 'making a subscription with defaulted params omitted' test
   * in `connection-subscriptions.ts` for more.
   */
  args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify$1([subscriptionConfig.method, args]);
    const existingSubscription = this._subscriptionsByHash[hash];

    if (existingSubscription === undefined) {
      this._subscriptionsByHash[hash] = { ...subscriptionConfig,
        args,
        callbacks: new Set([subscriptionConfig.callback]),
        state: 'pending'
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }

    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;

    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };

    this._updateSubscriptions();

    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */


  onAccountChange(publicKey, callback, commitment) {
    const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
    'base64');

    return this._makeSubscription({
      callback,
      method: 'accountSubscribe',
      unsubscribeMethod: 'accountUnsubscribe'
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');
  }
  /**
   * @internal
   */


  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, ProgramAccountNotificationResult);

    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @param filters The program account filters to pass into the RPC method
   * @return subscription id
   */


  onProgramAccountChange(programId, callback, commitment, filters) {
    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
    'base64'
    /* encoding */
    , filters ? {
      filters: filters
    } : undefined
    /* extra */
    );

    return this._makeSubscription({
      callback,
      method: 'programSubscribe',
      unsubscribeMethod: 'programUnsubscribe'
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */


  onLogs(filter, callback, commitment) {
    const args = this._buildArgs([typeof filter === 'object' ? {
      mentions: [filter.toString()]
    } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
    );

    return this._makeSubscription({
      callback,
      method: 'logsSubscribe',
      unsubscribeMethod: 'logsUnsubscribe'
    }, args);
  }
  /**
   * Deregister a logs callback.
   *
   * @param id client subscription id to deregister.
   */


  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');
  }
  /**
   * @internal
   */


  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, LogsNotificationResult);

    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */


  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SlotNotificationResult);

    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */


  onSlotChange(callback) {
    return this._makeSubscription({
      callback,
      method: 'slotSubscribe',
      unsubscribeMethod: 'slotUnsubscribe'
    }, []
    /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');
  }
  /**
   * @internal
   */


  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SlotUpdateNotificationResult);

    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */


  onSlotUpdate(callback) {
    return this._makeSubscription({
      callback,
      method: 'slotsUpdatesSubscribe',
      unsubscribeMethod: 'slotsUpdatesUnsubscribe'
    }, []
    /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');
  }
  /**
   * @internal
   */


  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];

    if (dispose) {
      await dispose();
    } else {
      console.warn('Ignored unsubscribe request because an active subscription with id ' + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + 'could not be found.');
    }
  }

  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;

    if (commitment || encoding || extra) {
      let options = {};

      if (encoding) {
        options.encoding = encoding;
      }

      if (commitment) {
        options.commitment = commitment;
      }

      if (extra) {
        options = Object.assign(options, extra);
      }

      args.push(options);
    }

    return args;
  }
  /**
   * @internal
   */


  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
    const commitment = override || this._commitment;

    if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
      throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
    }

    return this._buildArgs(args, override, encoding, extra);
  }
  /**
   * @internal
   */


  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, SignatureNotificationResult);

    if (result.value !== 'receivedSignature') {
      /**
       * Special case.
       * After a signature is processed, RPCs automatically dispose of the
       * subscription on the server side. We need to track which of these
       * subscriptions have been disposed in such a way, so that we know
       * whether the client is dealing with a not-yet-processed signature
       * (in which case we must tear down the server subscription) or an
       * already-processed signature (in which case the client can simply
       * clear out the subscription locally without telling the server).
       *
       * NOTE: There is a proposal to eliminate this special case, here:
       * https://github.com/solana-labs/solana/issues/18892
       */
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }

    this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
      type: 'received'
    }, result.context] : [{
      type: 'status',
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */


  onSignature(signature, callback, commitment) {
    const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
    );

    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === 'status') {
          callback(notification.result, context); // Signatures subscriptions are auto-removed by the RPC service
          // so no need to explicitly send an unsubscribe message.

          try {
            this.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty
          } catch (_err) {// Already removed.
          }
        }
      },
      method: 'signatureSubscribe',
      unsubscribeMethod: 'signatureUnsubscribe'
    }, args);

    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */


  onSignatureWithOptions(signature, callback, options) {
    const {
      commitment,
      ...extra
    } = { ...options,
      commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.

    };

    const args = this._buildArgs([signature], commitment, undefined
    /* encoding */
    , extra);

    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context); // Signatures subscriptions are auto-removed by the RPC service
        // so no need to explicitly send an unsubscribe message.

        try {
          this.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty
        } catch (_err) {// Already removed.
        }
      },
      method: 'signatureSubscribe',
      unsubscribeMethod: 'signatureUnsubscribe'
    }, args);

    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');
  }
  /**
   * @internal
   */


  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = superstruct.create(notification, RootNotificationResult);

    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */


  onRootChange(callback) {
    return this._makeSubscription({
      callback,
      method: 'rootSubscribe',
      unsubscribeMethod: 'rootUnsubscribe'
    }, []
    /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param id client subscription id to deregister
   */


  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');
  }

}

/**
 * Keypair signer interface
 */

/**
 * An account keypair used for signing transactions.
 */
class Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair();
  }
  /**
   * Generate a new random keypair
   */


  static generate() {
    return new Keypair(generateKeypair());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options: skip secret key validation
   */


  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error('bad secret key size');
    }

    const publicKey = secretKey.slice(32, 64);

    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);

      for (let ii = 0; ii < 32; ii++) {
        if (publicKey[ii] !== computedPublicKey[ii]) {
          throw new Error('provided secretKey is invalid');
        }
      }
    }

    return new Keypair({
      publicKey,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   */


  static fromSeed(seed) {
    const publicKey = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return new Keypair({
      publicKey,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   */


  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   */


  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }

}

/**
 * An enumeration of valid address lookup table InstructionType's
 * @internal
 */
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('recentSlot'), BufferLayout__namespace.u8('bumpSeed')])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64(), BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'addresses')])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  }
});
class AddressLookupTableInstruction {
  /**
   * @internal
   */
  constructor() {}

  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
    const index = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == index) {
        type = layoutType;
        break;
      }
    }

    if (!type) {
      throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
    }

    return type;
  }

  static decodeCreateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 4);
    const {
      recentSlot
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
    return {
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys[2].pubkey,
      recentSlot: Number(recentSlot)
    };
  }

  static decodeExtendLookupTable(instruction) {
    this.checkProgramId(instruction.programId);

    if (instruction.keys.length < 2) {
      throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
    }

    const {
      addresses
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
      addresses: addresses.map(buffer => new PublicKey(buffer))
    };
  }

  static decodeCloseLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 3);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      recipient: instruction.keys[2].pubkey
    };
  }

  static decodeFreezeLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }

  static decodeDeactivateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }
  /**
   * @internal
   */


  static checkProgramId(programId) {
    if (!programId.equals(AddressLookupTableProgram.programId)) {
      throw new Error('invalid instruction; programId is not AddressLookupTable Program');
    }
  }
  /**
   * @internal
   */


  static checkKeysLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
class AddressLookupTableProgram {
  /**
   * @internal
   */
  constructor() {}

  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed: bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    }), lookupTableAddress];
  }

  static freezeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }

  static extendLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type, {
      addresses: params.addresses.map(addr => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];

    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }

    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }

  static deactivateLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }

  static closeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }

}
AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');

/**
 * Compute Budget Instruction class
 */

class ComputeBudgetInstruction {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */


  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout__namespace.u8('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    }

    return type;
  }
  /**
   * Decode request units compute budget instruction and retrieve the instruction params.
   */


  static decodeRequestUnits(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units,
      additionalFee
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
    return {
      units,
      additionalFee
    };
  }
  /**
   * Decode request heap frame compute budget instruction and retrieve the instruction params.
   */


  static decodeRequestHeapFrame(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      bytes
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
    return {
      bytes
    };
  }
  /**
   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
   */


  static decodeSetComputeUnitLimit(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
    return {
      units
    };
  }
  /**
   * Decode set compute unit price compute budget instruction and retrieve the instruction params.
   */


  static decodeSetComputeUnitPrice(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      microLamports
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
    return {
      microLamports
    };
  }
  /**
   * @internal
   */


  static checkProgramId(programId) {
    if (!programId.equals(ComputeBudgetProgram.programId)) {
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
    }
  }

}
/**
 * An enumeration of valid ComputeBudgetInstructionType's
 */

/**
 * An enumeration of valid ComputeBudget InstructionType's
 * @internal
 */
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units'), BufferLayout__namespace.u32('additionalFee')])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('bytes')])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units')])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), u64('microLamports')])
  }
});
/**
 * Factory class for transaction instructions to interact with the Compute Budget program
 */

class ComputeBudgetProgram {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the Compute Budget program
   */


  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }

  static requestHeapFrame(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }

  static setComputeUnitLimit(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }

  static setComputeUnitPrice(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }

}
ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');

const PRIVATE_KEY_BYTES$1 = 64;
const PUBLIC_KEY_BYTES$1 = 32;
const SIGNATURE_BYTES = 64;
/**
 * Params for creating an ed25519 instruction using a public key
 */

const ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u8('padding'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u16('signatureInstructionIndex'), BufferLayout__namespace.u16('publicKeyOffset'), BufferLayout__namespace.u16('publicKeyInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u16('messageInstructionIndex')]);
class Ed25519Program {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the ed25519 program
   */


  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey,
      message,
      signature,
      instructionIndex
    } = params;
    assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);
    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
    : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */


  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);

    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey = keypair.publicKey.toBytes();
      const signature = sign(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }

}
Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

// library interoperable with the synchronous APIs in web3.js.

secp256k1__namespace.utils.hmacSha256Sync = (key, ...msgs) => {
  const h = hmac.hmac.create(sha256.sha256, key);
  msgs.forEach(msg => h.update(msg));
  return h.digest();
};

const ecdsaSign = (msgHash, privKey) => secp256k1__namespace.signSync(msgHash, privKey, {
  der: false,
  recovered: true
});
secp256k1__namespace.utils.isValidPrivateKey;
const publicKeyCreate = secp256k1__namespace.getPublicKey;

const PRIVATE_KEY_BYTES = 32;
const ETHEREUM_ADDRESS_BYTES = 20;
const PUBLIC_KEY_BYTES = 64;
const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
/**
 * Params for creating an secp256k1 instruction using a public key
 */

const SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u8('signatureInstructionIndex'), BufferLayout__namespace.u16('ethAddressOffset'), BufferLayout__namespace.u8('ethAddressInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u8('messageInstructionIndex'), BufferLayout__namespace.blob(20, 'ethAddress'), BufferLayout__namespace.blob(64, 'signature'), BufferLayout__namespace.u8('recoveryId')]);
class Secp256k1Program {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the secp256k1 program
   */


  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey) {
    assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);

    try {
      return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */


  static createInstructionWithPublicKey(params) {
    const {
      publicKey,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */


  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;

    if (typeof rawAddress === 'string') {
      if (rawAddress.startsWith('0x')) {
        ethAddress = buffer.Buffer.from(rawAddress.substr(2), 'hex');
      } else {
        ethAddress = buffer.Buffer.from(rawAddress, 'hex');
      }
    } else {
      ethAddress = rawAddress;
    }

    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */


  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);

    try {
      const privateKey = toBuffer(pkey);
      const publicKey = publicKeyCreate(privateKey, false
      /* isCompressed */
      ).slice(1); // throw away leading byte

      const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }

}
Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');

/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */

const STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
/**
 * Stake account authority info
 */

class Authorized {
  /** stake authority */

  /** withdraw authority */

  /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */
  constructor(staker, withdrawer) {
    this.staker = void 0;
    this.withdrawer = void 0;
    this.staker = staker;
    this.withdrawer = withdrawer;
  }

}

/**
 * Stake account lockup info
 */
class Lockup {
  /** Unix timestamp of lockup expiration */

  /** Epoch of lockup expiration */

  /** Lockup custodian authority */

  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */


}
Lockup.default = new Lockup(0, 0, PublicKey.default);

/**
 * Stake Instruction class
 */
class StakeInstruction {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Decode a stake instruction and retrieve the instruction type.
   */


  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a StakeInstruction');
    }

    return type;
  }
  /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */


  static decodeInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized,
      lockup
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
    };
  }
  /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */


  static decodeDelegate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 6);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      votePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[5].pubkey
    };
  }
  /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */


  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      stakeAuthorizationType
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };

    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }

    return o;
  }
  /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */


  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      newAuthorized,
      stakeAuthorizationType,
      authoritySeed,
      authorityOwner
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorityBase: instruction.keys[1].pubkey,
      authoritySeed: authoritySeed,
      authorityOwner: new PublicKey(authorityOwner),
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };

    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }

    return o;
  }
  /**
   * Decode a split stake instruction and retrieve the instruction params.
   */


  static decodeSplit(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      splitStakePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      lamports
    };
  }
  /**
   * Decode a merge stake instruction and retrieve the instruction params.
   */


  static decodeMerge(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      sourceStakePubKey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey
    };
  }
  /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */


  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };

    if (instruction.keys.length > 5) {
      o.custodianPubkey = instruction.keys[5].pubkey;
    }

    return o;
  }
  /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */


  static decodeDeactivate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * @internal
   */


  static checkProgramId(programId) {
    if (!programId.equals(StakeProgram.programId)) {
      throw new Error('invalid instruction; programId is not StakeProgram');
    }
  }
  /**
   * @internal
   */


  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
/**
 * An enumeration of valid StakeInstructionType's
 */

/**
 * An enumeration of valid stake InstructionType's
 * @internal
 */
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  Split: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  Merge: {
    index: 7,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
  }
});
/**
 * Stake authorization type
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
const StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
/**
 * Factory class for transactions to interact with the Stake program
 */

class StakeProgram {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the Stake program
   */


  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized,
      lockup: maybeLockup
    } = params;
    const lockup = maybeLockup || Lockup.default;
    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type, {
      authorized: {
        staker: toBuffer(authorized.staker.toBuffer()),
        withdrawer: toBuffer(authorized.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup.unixTimestamp,
        epoch: lockup.epoch,
        custodian: toBuffer(lockup.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */


  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */


  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */


  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */


  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */


  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed: authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */


  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */


  static split(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */


  static splitWithSeed(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */


  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */


  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */


  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

}
StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
StakeProgram.space = 200;

/**
 * Vote account info
 */

class VoteInit {
  /** [0, 100] */
  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
    this.nodePubkey = void 0;
    this.authorizedVoter = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.nodePubkey = nodePubkey;
    this.authorizedVoter = authorizedVoter;
    this.authorizedWithdrawer = authorizedWithdrawer;
    this.commission = commission;
  }

}
/**
 * Create vote account transaction params
 */

/**
 * Vote Instruction class
 */
class VoteInstruction {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Decode a vote instruction and retrieve the instruction type.
   */


  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a VoteInstruction');
    }

    return type;
  }
  /**
   * Decode an initialize vote instruction and retrieve the instruction params.
   */


  static decodeInitializeAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 4);
    const {
      voteInit
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      nodePubkey: instruction.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
    };
  }
  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */


  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      voteAuthorizationType
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      }
    };
  }
  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */


  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed,
        newAuthorized,
        voteAuthorizationType
      }
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      },
      votePubkey: instruction.keys[0].pubkey
    };
  }
  /**
   * Decode a withdraw instruction and retrieve the instruction params.
   */


  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
      lamports,
      toPubkey: instruction.keys[1].pubkey
    };
  }
  /**
   * @internal
   */


  static checkProgramId(programId) {
    if (!programId.equals(VoteProgram.programId)) {
      throw new Error('invalid instruction; programId is not VoteProgram');
    }
  }
  /**
   * @internal
   */


  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
/**
 * An enumeration of valid VoteInstructionType's
 */

const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('voteAuthorizationType')])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteAuthorizeWithSeedArgs()])
  }
});
/**
 * VoteAuthorize type
 */

/**
 * An enumeration of valid VoteAuthorization layouts.
 */
const VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
/**
 * Factory class for transactions to interact with the Vote program
 */

class VoteProgram {
  /**
   * @internal
   */
  constructor() {}
  /**
   * Public key that identifies the Vote program
   */


  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type, {
      voteInit: {
        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
        commission: voteInit.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */


  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */


  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */


  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */


  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */


  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    }

    return VoteProgram.withdraw(params);
  }

}
VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
VoteProgram.space = 3731;

const VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');
/**
 * @internal
 */

const InfoString = superstruct.type({
  name: superstruct.string(),
  website: superstruct.optional(superstruct.string()),
  details: superstruct.optional(superstruct.string()),
  keybaseUsername: superstruct.optional(superstruct.string())
});
/**
 * ValidatorInfo class
 */

class ValidatorInfo {
  /**
   * validator public key
   */

  /**
   * validator information
   */

  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  constructor(key, info) {
    this.key = void 0;
    this.info = void 0;
    this.key = key;
    this.info = info;
  }
  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */


  static fromConfigData(buffer$1) {
    let byteArray = [...buffer$1];
    const configKeyCount = decodeLength(byteArray);
    if (configKeyCount !== 2) return null;
    const configKeys = [];

    for (let i = 0; i < 2; i++) {
      const publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      const isSigner = byteArray.slice(0, 1)[0] === 1;
      byteArray = byteArray.slice(1);
      configKeys.push({
        publicKey,
        isSigner
      });
    }

    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
      if (configKeys[1].isSigner) {
        const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));
        const info = JSON.parse(rawInfo);
        superstruct.assert(info, InfoString);
        return new ValidatorInfo(configKeys[1].publicKey, info);
      }
    }

    return null;
  }

}

const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');

/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @internal
 */
const VoteAccountLayout = BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission'), BufferLayout__namespace.nu64(), // votes.length
BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.u32('confirmationCount')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'votes'), BufferLayout__namespace.u8('rootSlotValid'), BufferLayout__namespace.nu64('rootSlot'), BufferLayout__namespace.nu64(), // authorizedVoters.length
BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'authorizedVoters'), BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey('authorizedPubkey'), BufferLayout__namespace.nu64('epochOfLastAuthorizedSwitch'), BufferLayout__namespace.nu64('targetEpoch')]), 32, 'buf'), BufferLayout__namespace.nu64('idx'), BufferLayout__namespace.u8('isEmpty')], 'priorVoters'), BufferLayout__namespace.nu64(), // epochCredits.length
BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), BufferLayout__namespace.nu64('credits'), BufferLayout__namespace.nu64('prevCredits')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'epochCredits'), BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.nu64('timestamp')], 'lastTimestamp')]);

/**
 * VoteAccount class
 */
class VoteAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args.nodePubkey;
    this.authorizedWithdrawer = args.authorizedWithdrawer;
    this.commission = args.commission;
    this.rootSlot = args.rootSlot;
    this.votes = args.votes;
    this.authorizedVoters = args.authorizedVoters;
    this.priorVoters = args.priorVoters;
    this.epochCredits = args.epochCredits;
    this.lastTimestamp = args.lastTimestamp;
  }
  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */


  static fromAccountData(buffer) {
    const versionOffset = 4;
    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
    let rootSlot = va.rootSlot;

    if (!va.rootSlotValid) {
      rootSlot = null;
    }

    return new VoteAccount({
      nodePubkey: new PublicKey(va.nodePubkey),
      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
      commission: va.commission,
      votes: va.votes,
      rootSlot,
      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(va.priorVoters),
      epochCredits: va.epochCredits,
      lastTimestamp: va.lastTimestamp
    });
  }

}

function parseAuthorizedVoter({
  authorizedVoter,
  epoch
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}

function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}

function getPriorVoters({
  buf,
  idx,
  isEmpty
}) {
  if (isEmpty) {
    return [];
  }

  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}

const endpoint = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
  }
};

/**
 * Retrieves the RPC API URL for the specified cluster
 */
function clusterApiUrl(cluster, tls) {
  const key = tls === false ? 'http' : 'https';

  if (!cluster) {
    return endpoint[key]['devnet'];
  }

  const url = endpoint[key][cluster];

  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }

  return url;
}

/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {TransactionConfirmationStrategy} confirmationStrategy
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

/**
 * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
 * is no longer supported and will be removed in a future version.
 */
// eslint-disable-next-line no-redeclare
// eslint-disable-next-line no-redeclare
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
  let confirmationStrategy;
  let options;

  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else {
    options = confirmationStrategyOrConfirmOptions;
  }

  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const commitment = options && options.commitment;
  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
  const status = (await confirmationPromise).value;

  if (status.err) {
    throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
  }

  return signature;
}

/**
 * There are 1-billion lamports in one SOL
 */

const LAMPORTS_PER_SOL = 1000000000;

exports.Account = Account;
exports.AddressLookupTableAccount = AddressLookupTableAccount;
exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
exports.AddressLookupTableProgram = AddressLookupTableProgram;
exports.Authorized = Authorized;
exports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;
exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;
exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;
exports.BpfLoader = BpfLoader;
exports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;
exports.ComputeBudgetInstruction = ComputeBudgetInstruction;
exports.ComputeBudgetProgram = ComputeBudgetProgram;
exports.Connection = Connection;
exports.Ed25519Program = Ed25519Program;
exports.Enum = Enum;
exports.EpochSchedule = EpochSchedule;
exports.FeeCalculatorLayout = FeeCalculatorLayout;
exports.Keypair = Keypair;
exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;
exports.Loader = Loader;
exports.Lockup = Lockup;
exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;
exports.Message = Message;
exports.MessageAccountKeys = MessageAccountKeys;
exports.MessageV0 = MessageV0;
exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;
exports.NonceAccount = NonceAccount;
exports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;
exports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;
exports.PublicKey = PublicKey;
exports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;
exports.SOLANA_SCHEMA = SOLANA_SCHEMA;
exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;
exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;
exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;
exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;
exports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;
exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;
exports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;
exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;
exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;
exports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;
exports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;
exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;
exports.Secp256k1Program = Secp256k1Program;
exports.SendTransactionError = SendTransactionError;
exports.SolanaJSONRPCError = SolanaJSONRPCError;
exports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;
exports.StakeAuthorizationLayout = StakeAuthorizationLayout;
exports.StakeInstruction = StakeInstruction;
exports.StakeProgram = StakeProgram;
exports.Struct = Struct;
exports.SystemInstruction = SystemInstruction;
exports.SystemProgram = SystemProgram;
exports.Transaction = Transaction;
exports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;
exports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;
exports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;
exports.TransactionInstruction = TransactionInstruction;
exports.TransactionMessage = TransactionMessage;
exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;
exports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;
exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;
exports.ValidatorInfo = ValidatorInfo;
exports.VersionedMessage = VersionedMessage;
exports.VersionedTransaction = VersionedTransaction;
exports.VoteAccount = VoteAccount;
exports.VoteAuthorizationLayout = VoteAuthorizationLayout;
exports.VoteInit = VoteInit;
exports.VoteInstruction = VoteInstruction;
exports.VoteProgram = VoteProgram;
exports.clusterApiUrl = clusterApiUrl;
exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;
exports.sendAndConfirmTransaction = sendAndConfirmTransaction;


},{"@noble/ed25519":18,"@noble/hashes/hmac":23,"@noble/hashes/sha256":24,"@noble/hashes/sha3":25,"@noble/hashes/sha512":26,"@noble/secp256k1":28,"@solana/buffer-layout":29,"bigint-buffer":32,"bn.js":33,"borsh":34,"bs58":35,"buffer":61,"jayson/lib/client/browser":37,"rpc-websockets/dist/lib/client":39,"rpc-websockets/dist/lib/client/websocket.browser":40,"superstruct":42}],31:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require('safe-buffer').Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{"safe-buffer":41}],32:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
let converter;
/**
 * Convert a little-endian buffer into a BigInt.
 * @param buf The little-endian buffer to convert
 * @returns A BigInt with the little-endian representation of buf.
 */
function toBigIntLE(buf) {
    {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
}
exports.toBigIntLE = toBigIntLE;
/**
 * Convert a big-endian buffer into a BigInt
 * @param buf The big-endian buffer to convert.
 * @returns A BigInt with the big-endian representation of buf.
 */
function toBigIntBE(buf) {
    {
        const hex = buf.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
}
exports.toBigIntBE = toBigIntBE;
/**
 * Convert a BigInt to a little-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A little-endian buffer representation of num.
 */
function toBufferLE(num, width) {
    {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
        buffer.reverse();
        return buffer;
    }
    // Allocation is done here, since it is slower using napi in C
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
}
exports.toBufferLE = toBufferLE;
/**
 * Convert a BigInt to a big-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A big-endian buffer representation of num.
 */
function toBufferBE(num, width) {
    {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
}
exports.toBufferBE = toBufferBE;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":61}],33:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":60}],34:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bs58_1 = __importDefault(require("bs58"));
// TODO: Make sure this polyfill not included when not required
const encoding = __importStar(require("text-encoding-utf-8"));
const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
function baseEncode(value) {
    if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(Buffer.from(value));
}
exports.baseEncode = baseEncode;
function baseDecode(value) {
    return Buffer.from(bs58_1.default.decode(value));
}
exports.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
    constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        // NOTE: Modifying message directly as jest doesn't use .toString()
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
}
exports.BorshError = BorshError;
/// Binary encoder.
class BinaryWriter {
    constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
    }
    maybeResize() {
        if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
    }
    writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
    }
    writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
    }
    writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
    }
    writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser
        this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH),
        ]);
        this.length += buffer.length;
    }
    writeString(str) {
        this.maybeResize();
        const b = Buffer.from(str, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
    }
    writeFixedArray(array) {
        this.writeBuffer(Buffer.from(array));
    }
    writeArray(array, fn) {
        this.maybeResize();
        this.writeU32(array.length);
        for (const elem of array) {
            this.maybeResize();
            fn(elem);
        }
    }
    toArray() {
        return this.buf.subarray(0, this.length);
    }
}
exports.BinaryWriter = BinaryWriter;
function handlingRangeError(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function (...args) {
        try {
            return originalMethod.apply(this, args);
        }
        catch (e) {
            if (e instanceof RangeError) {
                const code = e.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                    throw new BorshError("Reached the end of buffer when deserializing");
                }
            }
            throw e;
        }
    };
}
class BinaryReader {
    constructor(buf) {
        this.buf = buf;
        this.offset = 0;
    }
    readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
    }
    readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
    }
    readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
    }
    readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
    }
    readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
    }
    readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
    }
    readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
    }
    readBuffer(len) {
        if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
    }
    readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
            // NOTE: Using TextDecoder to fail on invalid UTF-8
            return textDecoder.decode(buf);
        }
        catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
    }
    readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
    }
    readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for (let i = 0; i < len; ++i) {
            result.push(fn());
        }
        return result;
    }
}
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
    handlingRangeError
], BinaryReader.prototype, "readArray", null);
exports.BinaryReader = BinaryReader;
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
        // TODO: Handle missing values properly (make sure they never result in just skipped write)
        if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        }
        else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
                if (value.length !== fieldType[0]) {
                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
                }
                writer.writeFixedArray(value);
            }
            else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
                if (value.length !== fieldType[1]) {
                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
                }
                for (let i = 0; i < fieldType[1]; i++) {
                    serializeField(schema, null, value[i], fieldType[0], writer);
                }
            }
            else {
                writer.writeArray(value, (item) => {
                    serializeField(schema, fieldName, item, fieldType[0], writer);
                });
            }
        }
        else if (fieldType.kind !== undefined) {
            switch (fieldType.kind) {
                case "option": {
                    if (value === null || value === undefined) {
                        writer.writeU8(0);
                    }
                    else {
                        writer.writeU8(1);
                        serializeField(schema, fieldName, value, fieldType.type, writer);
                    }
                    break;
                }
                case "map": {
                    writer.writeU32(value.size);
                    value.forEach((val, key) => {
                        serializeField(schema, fieldName, key, fieldType.key, writer);
                        serializeField(schema, fieldName, val, fieldType.value, writer);
                    });
                    break;
                }
                default:
                    throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
        }
        else {
            serializeStruct(schema, value, writer);
        }
    }
    catch (error) {
        if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
        }
        throw error;
    }
}
function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
    }
    else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
                writer.writeU8(idx);
                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
                break;
            }
        }
    }
    else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
}
/// Serialize given object using schema of the form:
/// { class_name -> [ [field_name, field_type], .. ], .. }
function serialize(schema, obj, Writer = BinaryWriter) {
    const writer = new Writer();
    serializeStruct(schema, obj, writer);
    return writer.toArray();
}
exports.serialize = serialize;
function deserializeField(schema, fieldName, fieldType, reader) {
    try {
        if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
                return reader.readFixedArray(fieldType[0]);
            }
            else if (typeof fieldType[1] === "number") {
                const arr = [];
                for (let i = 0; i < fieldType[1]; i++) {
                    arr.push(deserializeField(schema, null, fieldType[0], reader));
                }
                return arr;
            }
            else {
                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
        }
        if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) {
                return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return undefined;
        }
        if (fieldType.kind === "map") {
            let map = new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
                const key = deserializeField(schema, fieldName, fieldType.key, reader);
                const val = deserializeField(schema, fieldName, fieldType.value, reader);
                map.set(key, val);
            }
            return map;
        }
        return deserializeStruct(schema, fieldType, reader);
    }
    catch (error) {
        if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
        }
        throw error;
    }
}
function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
    }
    if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
}
/// Deserializes object from bytes using schema.
function deserialize(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) {
        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    }
    return result;
}
exports.deserialize = deserialize;
/// Deserializes object from bytes using schema, without checking the length read
function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    return deserializeStruct(schema, classType, reader);
}
exports.deserializeUnchecked = deserializeUnchecked;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":33,"bs58":35,"buffer":61,"text-encoding-utf-8":43}],35:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":31}],36:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],37:[function(require,module,exports){
'use strict';

const uuid = require('uuid').v4;
const generateRequest = require('../../generateRequest');

/**
 * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
 * @class ClientBrowser
 * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
 * @param {Object} [options]
 * @param {Function} [options.reviver] Reviver function for JSON
 * @param {Function} [options.replacer] Replacer function for JSON
 * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
 * @param {Function} [options.generator] Function to use for generating request IDs
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 * @return {ClientBrowser}
 */
const ClientBrowser = function(callServer, options) {
  if(!(this instanceof ClientBrowser)) {
    return new ClientBrowser(callServer, options);
  }

  if (!options) {
    options = {};
  }

  this.options = {
    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },
    version: typeof options.version !== 'undefined' ? options.version : 2,
    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,
  };

  this.callServer = callServer;
};

module.exports = ClientBrowser;

/**
 *  Creates a request and dispatches it if given a callback.
 *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
 *  @param {Array|Object} [params] Parameters for the method
 *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
 *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
 *  @throws {TypeError} Invalid parameters
 *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
 */
ClientBrowser.prototype.request = function(method, params, id, callback) {
  const self = this;
  let request = null;

  // is this a batch request?
  const isBatch = Array.isArray(method) && typeof params === 'function';

  if (this.options.version === 1 && isBatch) {
    throw new TypeError('JSON-RPC 1.0 does not support batching');
  }

  // is this a raw request?
  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';

  if(isBatch || isRaw) {
    callback = params;
    request = method;
  } else {
    if(typeof id === 'function') {
      callback = id;
      // specifically undefined because "null" is a notification request
      id = undefined;
    }

    const hasCallback = typeof callback === 'function';

    try {
      request = generateRequest(method, params, id, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull,
      });
    } catch(err) {
      if(hasCallback) {
        return callback(err);
      }
      throw err;
    }

    // no callback means we should just return a raw request
    if(!hasCallback) {
      return request;
    }

  }

  let message;
  try {
    message = JSON.stringify(request, this.options.replacer);
  } catch(err) {
    return callback(err);
  }

  this.callServer(message, function(err, response) {
    self._parseResponse(err, response, callback);
  });

  // always return the raw request
  return request;
};

/**
 * Parses a response from a server
 * @param {Object} err Error to pass on that is unrelated to the actual response
 * @param {String} responseText JSON-RPC 1.0 or 2.0 response
 * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
 * @private
 */
ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
  if(err) {
    callback(err);
    return;
  }

  if(!responseText) {
    // empty response text, assume that is correct because it could be a
    // notification which jayson does not give any body for
    return callback();
  }

  let response;
  try {
    response = JSON.parse(responseText, this.options.reviver);
  } catch(err) {
    return callback(err);
  }

  if(callback.length === 3) {
    // if callback length is 3, we split callback arguments on error and response

    // is batch response?
    if(Array.isArray(response)) {

      // neccesary to split strictly on validity according to spec here
      const isError = function(res) {
        return typeof res.error !== 'undefined';
      };

      const isNotError = function (res) {
        return !isError(res);
      };

      return callback(null, response.filter(isError), response.filter(isNotError));
    
    } else {

      // split regardless of validity
      return callback(null, response.error, response.result);
    
    }
  
  }

  callback(null, response);
};

},{"../../generateRequest":38,"uuid":44}],38:[function(require,module,exports){
'use strict';

const uuid = require('uuid').v4;

/**
 *  Generates a JSON-RPC 1.0 or 2.0 request
 *  @param {String} method Name of method to call
 *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
 *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
 *  @param {Object} [options]
 *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
 *  @throws {TypeError} If any of the parameters are invalid
 *  @return {Object} A JSON-RPC 1.0 or 2.0 request
 *  @memberOf Utils
 */
const generateRequest = function(method, params, id, options) {
  if(typeof method !== 'string') {
    throw new TypeError(method + ' must be a string');
  }

  options = options || {};

  // check valid version provided
  const version = typeof options.version === 'number' ? options.version : 2;
  if (version !== 1 && version !== 2) {
    throw new TypeError(version + ' must be 1 or 2');
  }

  const request = {
    method: method
  };

  if(version === 2) {
    request.jsonrpc = '2.0';
  }

  if(params) {
    // params given, but invalid?
    if(typeof params !== 'object' && !Array.isArray(params)) {
      throw new TypeError(params + ' must be an object, array or omitted');
    }
    request.params = params;
  }

  // if id was left out, generate one (null means explicit notification)
  if(typeof(id) === 'undefined') {
    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };
    request.id = generator(request, options);
  } else if (version === 2 && id === null) {
    // we have a version 2 notification
    if (options.notificationIdNull) {
      request.id = null; // id will not be set at all unless option provided
    }
  } else {
    request.id = id;
  }

  return request;
};

module.exports = generateRequest;

},{"uuid":44}],39:[function(require,module,exports){
(function (Buffer){(function (){
/**
 * "Client" wraps "ws" or a browser-implemented "WebSocket" library
 * according to the environment providing JSON RPC 2.0 support on top.
 * @module Client
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _eventemitter = require("eventemitter3");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}; // @ts-ignore


var CommonClient = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2["default"])(CommonClient, _EventEmitter);

  var _super = _createSuper(CommonClient);

  /**
   * Instantiate a Client class.
   * @constructor
   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
   * @param {String} address - url to a websocket server
   * @param {Object} options - ws options object with reconnect parameters
   * @param {Function} generate_request_id - custom generation request Id
   * @return {CommonClient}
   */
  function CommonClient(webSocketFactory) {
    var _this;

    var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ws://localhost:8080";

    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;
    (0, _classCallCheck2["default"])(this, CommonClient);

    var _a$autoconnect = _a.autoconnect,
        autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect,
        _a$reconnect = _a.reconnect,
        reconnect = _a$reconnect === void 0 ? true : _a$reconnect,
        _a$reconnect_interval = _a.reconnect_interval,
        reconnect_interval = _a$reconnect_interval === void 0 ? 1000 : _a$reconnect_interval,
        _a$max_reconnects = _a.max_reconnects,
        max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects,
        rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);

    _this = _super.call(this);
    _this.webSocketFactory = webSocketFactory;
    _this.queue = {};
    _this.rpc_id = 0;
    _this.address = address;
    _this.autoconnect = autoconnect;
    _this.ready = false;
    _this.reconnect = reconnect;
    _this.reconnect_interval = reconnect_interval;
    _this.max_reconnects = max_reconnects;
    _this.rest_options = rest_options;
    _this.current_reconnects = 0;

    _this.generate_request_id = generate_request_id || function () {
      return ++_this.rpc_id;
    };

    if (_this.autoconnect) _this._connect(_this.address, Object.assign({
      autoconnect: _this.autoconnect,
      reconnect: _this.reconnect,
      reconnect_interval: _this.reconnect_interval,
      max_reconnects: _this.max_reconnects
    }, _this.rest_options));
    return _this;
  }
  /**
   * Connects to a defined server if not connected already.
   * @method
   * @return {Undefined}
   */


  (0, _createClass2["default"])(CommonClient, [{
    key: "connect",
    value: function connect() {
      if (this.socket) return;

      this._connect(this.address, Object.assign({
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects
      }, this.rest_options));
    }
    /**
     * Calls a registered RPC method on server.
     * @method
     * @param {String} method - RPC method name
     * @param {Object|Array} params - optional method parameters
     * @param {Number} timeout - RPC reply timeout value
     * @param {Object} ws_opts - options passed to ws
     * @return {Promise}
     */

  }, {
    key: "call",
    value: function call(method, params, timeout, ws_opts) {
      var _this2 = this;

      if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
        ws_opts = timeout;
        timeout = null;
      }

      return new Promise(function (resolve, reject) {
        if (!_this2.ready) return reject(new Error("socket not ready"));

        var rpc_id = _this2.generate_request_id(method, params);

        var message = {
          jsonrpc: "2.0",
          method: method,
          params: params || null,
          id: rpc_id
        };

        _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {
          if (error) return reject(error);
          _this2.queue[rpc_id] = {
            promise: [resolve, reject]
          };

          if (timeout) {
            _this2.queue[rpc_id].timeout = setTimeout(function () {
              delete _this2.queue[rpc_id];
              reject(new Error("reply timeout"));
            }, timeout);
          }
        });
      });
    }
    /**
     * Logins with the other side of the connection.
     * @method
     * @param {Object} params - Login credentials object
     * @return {Promise}
     */

  }, {
    key: "login",
    value: function () {
      var _login = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(params) {
        var resp;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.call("rpc.login", params);

              case 2:
                resp = _context.sent;

                if (resp) {
                  _context.next = 5;
                  break;
                }

                throw new Error("authentication failed");

              case 5:
                return _context.abrupt("return", resp);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function login(_x) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
    /**
     * Fetches a list of client's methods registered on server.
     * @method
     * @return {Array}
     */

  }, {
    key: "listMethods",
    value: function () {
      var _listMethods = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.call("__listMethods");

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function listMethods() {
        return _listMethods.apply(this, arguments);
      }

      return listMethods;
    }()
    /**
     * Sends a JSON-RPC 2.0 notification to server.
     * @method
     * @param {String} method - RPC method name
     * @param {Object} params - optional method parameters
     * @return {Promise}
     */

  }, {
    key: "notify",
    value: function notify(method, params) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (!_this3.ready) return reject(new Error("socket not ready"));
        var message = {
          jsonrpc: "2.0",
          method: method,
          params: params || null
        };

        _this3.socket.send(JSON.stringify(message), function (error) {
          if (error) return reject(error);
          resolve();
        });
      });
    }
    /**
     * Subscribes for a defined event.
     * @method
     * @param {String|Array} event - event name
     * @return {Undefined}
     * @throws {Error}
     */

  }, {
    key: "subscribe",
    value: function () {
      var _subscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
        var result;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (typeof event === "string") event = [event];
                _context3.next = 3;
                return this.call("rpc.on", event);

              case 3:
                result = _context3.sent;

                if (!(typeof event === "string" && result[event] !== "ok")) {
                  _context3.next = 6;
                  break;
                }

                throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);

              case 6:
                return _context3.abrupt("return", result);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function subscribe(_x2) {
        return _subscribe.apply(this, arguments);
      }

      return subscribe;
    }()
    /**
     * Unsubscribes from a defined event.
     * @method
     * @param {String|Array} event - event name
     * @return {Undefined}
     * @throws {Error}
     */

  }, {
    key: "unsubscribe",
    value: function () {
      var _unsubscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(event) {
        var result;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (typeof event === "string") event = [event];
                _context4.next = 3;
                return this.call("rpc.off", event);

              case 3:
                result = _context4.sent;

                if (!(typeof event === "string" && result[event] !== "ok")) {
                  _context4.next = 6;
                  break;
                }

                throw new Error("Failed unsubscribing from an event with: " + result);

              case 6:
                return _context4.abrupt("return", result);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function unsubscribe(_x3) {
        return _unsubscribe.apply(this, arguments);
      }

      return unsubscribe;
    }()
    /**
     * Closes a WebSocket connection gracefully.
     * @method
     * @param {Number} code - socket close code
     * @param {String} data - optional data to be sent before closing
     * @return {Undefined}
     */

  }, {
    key: "close",
    value: function close(code, data) {
      this.socket.close(code || 1000, data);
    }
    /**
     * Connection/Message handler.
     * @method
     * @private
     * @param {String} address - WebSocket API address
     * @param {Object} options - ws options object
     * @return {Undefined}
     */

  }, {
    key: "_connect",
    value: function _connect(address, options) {
      var _this4 = this;

      this.socket = this.webSocketFactory(address, options);
      this.socket.addEventListener("open", function () {
        _this4.ready = true;

        _this4.emit("open");

        _this4.current_reconnects = 0;
      });
      this.socket.addEventListener("message", function (_ref) {
        var message = _ref.data;
        if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();

        try {
          message = JSON.parse(message);
        } catch (error) {
          return;
        } // check if any listeners are attached and forward event


        if (message.notification && _this4.listeners(message.notification).length) {
          if (!Object.keys(message.params).length) return _this4.emit(message.notification);
          var args = [message.notification];
          if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better
            for (var i = 0; i < message.params.length; i++) {
              args.push(message.params[i]);
            } // run as microtask so that pending queue messages are resolved first
          // eslint-disable-next-line prefer-spread

          return Promise.resolve().then(function () {
            _this4.emit.apply(_this4, args);
          });
        }

        if (!_this4.queue[message.id]) {
          // general JSON RPC 2.0 events
          if (message.method && message.params) {
            // run as microtask so that pending queue messages are resolved first
            return Promise.resolve().then(function () {
              _this4.emit(message.method, message.params);
            });
          }

          return;
        } // reject early since server's response is invalid


        if ("error" in message === "result" in message) _this4.queue[message.id].promise[1](new Error("Server response malformed. Response must include either \"result\"" + " or \"error\", but not both."));
        if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);
        if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);
        delete _this4.queue[message.id];
      });
      this.socket.addEventListener("error", function (error) {
        return _this4.emit("error", error);
      });
      this.socket.addEventListener("close", function (_ref2) {
        var code = _ref2.code,
            reason = _ref2.reason;
        if (_this4.ready) // Delay close event until internal state is updated
          setTimeout(function () {
            return _this4.emit("close", code, reason);
          }, 0);
        _this4.ready = false;
        _this4.socket = undefined;
        if (code === 1000) return;
        _this4.current_reconnects++;
        if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) setTimeout(function () {
          return _this4._connect(address, options);
        }, _this4.reconnect_interval);
      });
    }
  }]);
  return CommonClient;
}(_eventemitter.EventEmitter);

exports["default"] = CommonClient;
}).call(this)}).call(this,require("buffer").Buffer)
},{"@babel/runtime/helpers/asyncToGenerator":5,"@babel/runtime/helpers/classCallCheck":6,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":11,"@babel/runtime/helpers/typeof":16,"@babel/runtime/regenerator":17,"buffer":61,"eventemitter3":36}],40:[function(require,module,exports){
/**
 * WebSocket implements a browser-side WebSocket specification.
 * @module Client
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _eventemitter = require("eventemitter3");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var WebSocketBrowserImpl = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2["default"])(WebSocketBrowserImpl, _EventEmitter);

  var _super = _createSuper(WebSocketBrowserImpl);

  /** Instantiate a WebSocket class
   * @constructor
   * @param {String} address - url to a websocket server
   * @param {(Object)} options - websocket options
   * @param {(String|Array)} protocols - a list of protocols
   * @return {WebSocketBrowserImpl} - returns a WebSocket instance
   */
  function WebSocketBrowserImpl(address, options, protocols) {
    var _this;

    (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl);
    _this = _super.call(this);
    _this.socket = new window.WebSocket(address, protocols);

    _this.socket.onopen = function () {
      return _this.emit("open");
    };

    _this.socket.onmessage = function (event) {
      return _this.emit("message", event.data);
    };

    _this.socket.onerror = function (error) {
      return _this.emit("error", error);
    };

    _this.socket.onclose = function (event) {
      _this.emit("close", event.code, event.reason);
    };

    return _this;
  }
  /**
   * Sends data through a websocket connection
   * @method
   * @param {(String|Object)} data - data to be sent via websocket
   * @param {Object} optionsOrCallback - ws options
   * @param {Function} callback - a callback called once the data is sent
   * @return {Undefined}
   */


  (0, _createClass2["default"])(WebSocketBrowserImpl, [{
    key: "send",
    value: function send(data, optionsOrCallback, callback) {
      var cb = callback || optionsOrCallback;

      try {
        this.socket.send(data);
        cb();
      } catch (error) {
        cb(error);
      }
    }
    /**
     * Closes an underlying socket
     * @method
     * @param {Number} code - status code explaining why the connection is being closed
     * @param {String} reason - a description why the connection is closing
     * @return {Undefined}
     * @throws {Error}
     */

  }, {
    key: "close",
    value: function close(code, reason) {
      this.socket.close(code, reason);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      this.socket.addEventListener(type, listener, options);
    }
  }]);
  return WebSocketBrowserImpl;
}(_eventemitter.EventEmitter);
/**
 * factory method for common WebSocket instance
 * @method
 * @param {String} address - url to a websocket server
 * @param {(Object)} options - websocket options
 * @return {Undefined}
 */


function _default(address, options) {
  return new WebSocketBrowserImpl(address, options);
}
},{"@babel/runtime/helpers/classCallCheck":6,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":11,"eventemitter3":36}],41:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":61}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * A `StructFailure` represents a single specific failure in validation.
 */

/**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join('.') + " -- " + message;
    super(msg);
    Object.assign(this, rest);
    this.name = this.constructor.name;

    this.failures = () => {
      var _cached;

      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }

}

/**
 * Check if a value is an iterator.
 */
function isIterable(x) {
  return isObject(x) && typeof x[Symbol.iterator] === 'function';
}
/**
 * Check if a value is a plain object.
 */


function isObject(x) {
  return typeof x === 'object' && x != null;
}
/**
 * Check if a value is a plain object.
 */

function isPlainObject(x) {
  if (Object.prototype.toString.call(x) !== '[object Object]') {
    return false;
  }

  const prototype = Object.getPrototypeOf(x);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Return a value as a printable string.
 */

function print(value) {
  return typeof value === 'string' ? JSON.stringify(value) : "" + value;
}
/**
 * Shifts (removes and returns) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 */

function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? undefined : value;
}
/**
 * Convert a single validation result to a failure.
 */

function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === 'string') {
    result = {
      message: result
    };
  }

  const {
    path,
    branch
  } = context;
  const {
    type
  } = struct;
  const {
    refinement,
    message = "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : '') + ", but received: `" + print(value) + "`"
  } = result;
  return {
    value,
    type,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
/**
 * Convert a validation result to an iterable of failures.
 */

function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }

  for (const r of result) {
    const failure = toFailure(r, context, struct, value);

    if (failure) {
      yield failure;
    }
  }
}
/**
 * Check a value against a struct, traversing deeply into nested values, and
 * returning an iterator of failures or success.
 */

function* run(value, struct, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce = false,
    mask = false
  } = options;
  const ctx = {
    path,
    branch
  };

  if (coerce) {
    value = struct.coercer(value, ctx);

    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct.schema[key] === undefined) {
          delete value[key];
        }
      }
    }
  }

  let valid = true;

  for (const failure of struct.validator(value, ctx)) {
    valid = false;
    yield [failure, undefined];
  }

  for (let [k, v, s] of struct.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce,
      mask
    });

    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], undefined];
      } else if (coerce) {
        v = t[1];

        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject(value)) {
          value[k] = v;
        }
      }
    }
  }

  if (valid) {
    for (const failure of struct.refiner(value, ctx)) {
      valid = false;
      yield [failure, undefined];
    }
  }

  if (valid) {
    yield [undefined, value];
  }
}

/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */

class Struct {
  constructor(props) {
    const {
      type,
      schema,
      validator,
      refiner,
      coercer = value => value,
      entries = function* () {}
    } = props;
    this.type = type;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;

    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }

    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */


  assert(value) {
    return assert(value, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */


  create(value) {
    return create(value, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */


  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */


  mask(value) {
    return mask(value, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */


  validate(value, options = {}) {
    return validate(value, this, options);
  }

}
/**
 * Assert that a value passes a struct, throwing if it doesn't.
 */

function assert(value, struct) {
  const result = validate(value, struct);

  if (result[0]) {
    throw result[0];
  }
}
/**
 * Create a value with the coercion logic of struct and validate it.
 */

function create(value, struct) {
  const result = validate(value, struct, {
    coerce: true
  });

  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
/**
 * Mask a value, returning only the subset of properties defined by a struct.
 */

function mask(value, struct) {
  const result = validate(value, struct, {
    coerce: true,
    mask: true
  });

  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
/**
 * Check if a value passes a struct.
 */

function is(value, struct) {
  const result = validate(value, struct);
  return !result[0];
}
/**
 * Validate a value against a struct, returning an error if invalid, or the
 * value (with potential coercion) if valid.
 */

function validate(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple = shiftIterator(tuples);

  if (tuple[0]) {
    const error = new StructError(tuple[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple[1];
    return [undefined, v];
  }
}

function assign(...Structs) {
  const schemas = Structs.map(s => s.schema);
  const schema = Object.assign({}, ...schemas);
  return object(schema);
}
/**
 * Define a new struct type with a custom validation function.
 */

function define(name, validator) {
  return new Struct({
    type: name,
    schema: null,
    validator
  });
}
/**
 * Create a new struct based on an existing struct, but the value is allowed to
 * be `undefined`. `log` will be called if the value is not `undefined`.
 */

function deprecated(struct, log) {
  return new Struct({ ...struct,
    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),

    validator(value, ctx) {
      if (value === undefined) {
        return true;
      } else {
        log(value, ctx);
        return struct.validator(value, ctx);
      }
    }

  });
}
/**
 * Create a struct with dynamic validation logic.
 *
 * The callback will receive the value currently being validated, and must
 * return a struct object to validate it with. This can be useful to model
 * validation logic that changes based on its input.
 */

function dynamic(fn) {
  return new Struct({
    type: 'dynamic',
    schema: null,

    *entries(value, ctx) {
      const struct = fn(value, ctx);
      yield* struct.entries(value, ctx);
    },

    validator(value, ctx) {
      const struct = fn(value, ctx);
      return struct.validator(value, ctx);
    },

    coercer(value, ctx) {
      const struct = fn(value, ctx);
      return struct.coercer(value, ctx);
    }

  });
}
/**
 * Create a struct with lazily evaluated validation logic.
 *
 * The first time validation is run with the struct, the callback will be called
 * and must return a struct object to use. This is useful for cases where you
 * want to have self-referential structs for nested data structures to avoid a
 * circular definition problem.
 */

function lazy(fn) {
  let struct;
  return new Struct({
    type: 'lazy',
    schema: null,

    *entries(value, ctx) {
      var _struct;

      (_struct = struct) != null ? _struct : struct = fn();
      yield* struct.entries(value, ctx);
    },

    validator(value, ctx) {
      var _struct2;

      (_struct2 = struct) != null ? _struct2 : struct = fn();
      return struct.validator(value, ctx);
    },

    coercer(value, ctx) {
      var _struct3;

      (_struct3 = struct) != null ? _struct3 : struct = fn();
      return struct.coercer(value, ctx);
    }

  });
}
/**
 * Create a new struct based on an existing object struct, but excluding
 * specific properties.
 *
 * Like TypeScript's `Omit` utility.
 */

function omit(struct, keys) {
  const {
    schema
  } = struct;
  const subschema = { ...schema
  };

  for (const key of keys) {
    delete subschema[key];
  }

  return object(subschema);
}
/**
 * Create a new struct based on an existing object struct, but with all of its
 * properties allowed to be `undefined`.
 *
 * Like TypeScript's `Partial` utility.
 */

function partial(struct) {
  const schema = struct instanceof Struct ? { ...struct.schema
  } : { ...struct
  };

  for (const key in schema) {
    schema[key] = optional(schema[key]);
  }

  return object(schema);
}
/**
 * Create a new struct based on an existing object struct, but only including
 * specific properties.
 *
 * Like TypeScript's `Pick` utility.
 */

function pick(struct, keys) {
  const {
    schema
  } = struct;
  const subschema = {};

  for (const key of keys) {
    subschema[key] = schema[key];
  }

  return object(subschema);
}
/**
 * Define a new struct type with a custom validation function.
 *
 * @deprecated This function has been renamed to `define`.
 */

function struct(name, validator) {
  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
  return define(name, validator);
}

/**
 * Ensure that any value passes validation.
 */

function any() {
  return define('any', () => true);
}
function array(Element) {
  return new Struct({
    type: 'array',
    schema: Element,

    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },

    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },

    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value is a boolean.
 */

function boolean() {
  return define('boolean', value => {
    return typeof value === 'boolean';
  });
}
/**
 * Ensure that a value is a valid `Date`.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 */

function date() {
  return define('date', value => {
    return value instanceof Date && !isNaN(value.getTime()) || "Expected a valid `Date` object, but received: " + print(value);
  });
}
function enums(values) {
  const schema = {};
  const description = values.map(v => print(v)).join();

  for (const key of values) {
    schema[key] = key;
  }

  return new Struct({
    type: 'enums',
    schema,

    validator(value) {
      return values.includes(value) || "Expected one of `" + description + "`, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value is a function.
 */

function func() {
  return define('func', value => {
    return typeof value === 'function' || "Expected a function, but received: " + print(value);
  });
}
/**
 * Ensure that a value is an instance of a specific class.
 */

function instance(Class) {
  return define('instance', value => {
    return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
  });
}
/**
 * Ensure that a value is an integer.
 */

function integer() {
  return define('integer', value => {
    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || "Expected an integer, but received: " + print(value);
  });
}
function intersection(Structs) {
  return new Struct({
    type: 'intersection',
    schema: null,

    *entries(value, ctx) {
      for (const S of Structs) {
        yield* S.entries(value, ctx);
      }
    },

    *validator(value, ctx) {
      for (const S of Structs) {
        yield* S.validator(value, ctx);
      }
    },

    *refiner(value, ctx) {
      for (const S of Structs) {
        yield* S.refiner(value, ctx);
      }
    }

  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: 'literal',
    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,

    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }

  });
}
function map(Key, Value) {
  return new Struct({
    type: 'map',
    schema: null,

    *entries(value) {
      if (Key && Value && value instanceof Map) {
        for (const [k, v] of value.entries()) {
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },

    coercer(value) {
      return value instanceof Map ? new Map(value) : value;
    },

    validator(value) {
      return value instanceof Map || "Expected a `Map` object, but received: " + print(value);
    }

  });
}
/**
 * Ensure that no value ever passes validation.
 */

function never() {
  return define('never', () => false);
}
/**
 * Augment an existing struct to allow `null` values.
 */

function nullable(struct) {
  return new Struct({ ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
}
/**
 * Ensure that a value is a number.
 */

function number() {
  return define('number', value => {
    return typeof value === 'number' && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: 'object',
    schema: schema ? schema : null,

    *entries(value) {
      if (schema && isObject(value)) {
        const unknowns = new Set(Object.keys(value));

        for (const key of knowns) {
          unknowns.delete(key);
          yield [key, value[key], schema[key]];
        }

        for (const key of unknowns) {
          yield [key, value[key], Never];
        }
      }
    },

    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    },

    coercer(value) {
      return isObject(value) ? { ...value
      } : value;
    }

  });
}
/**
 * Augment a struct to allow `undefined` values.
 */

function optional(struct) {
  return new Struct({ ...struct,
    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
  });
}
/**
 * Ensure that a value is an object with keys and values of specific types, but
 * without ensuring any specific shape of properties.
 *
 * Like TypeScript's `Record` utility.
 */

function record(Key, Value) {
  return new Struct({
    type: 'record',
    schema: null,

    *entries(value) {
      if (isObject(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },

    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value is a `RegExp`.
 *
 * Note: this does not test the value against the regular expression! For that
 * you need to use the `pattern()` refinement.
 */

function regexp() {
  return define('regexp', value => {
    return value instanceof RegExp;
  });
}
function set(Element) {
  return new Struct({
    type: 'set',
    schema: null,

    *entries(value) {
      if (Element && value instanceof Set) {
        for (const v of value) {
          yield [v, v, Element];
        }
      }
    },

    coercer(value) {
      return value instanceof Set ? new Set(value) : value;
    },

    validator(value) {
      return value instanceof Set || "Expected a `Set` object, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value is a string.
 */

function string() {
  return define('string', value => {
    return typeof value === 'string' || "Expected a string, but received: " + print(value);
  });
}
function tuple(Elements) {
  const Never = never();
  return new Struct({
    type: 'tuple',
    schema: null,

    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Elements.length, value.length);

        for (let i = 0; i < length; i++) {
          yield [i, value[i], Elements[i] || Never];
        }
      }
    },

    validator(value) {
      return Array.isArray(value) || "Expected an array, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value has a set of known properties of specific types.
 *
 * Note: Unrecognized properties are allowed and untouched. This is similar to
 * how TypeScript's structural typing works.
 */

function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: 'type',
    schema,

    *entries(value) {
      if (isObject(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },

    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }

  });
}
function union(Structs) {
  const description = Structs.map(s => s.type).join(' | ');
  return new Struct({
    type: 'union',
    schema: null,

    validator(value, ctx) {
      const failures = [];

      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;

        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }

      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }

  });
}
/**
 * Ensure that any value passes validation, without widening its type to `any`.
 */

function unknown() {
  return define('unknown', () => true);
}

/**
 * Augment a `Struct` to add an additional coercion step to its input.
 *
 * This allows you to transform input data before validating it, to increase the
 * likelihood that it passes validation—for example for default values, parsing
 * different formats, etc.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */

function coerce(struct, condition, coercer) {
  return new Struct({ ...struct,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    }
  });
}
/**
 * Augment a struct to replace `undefined` values with a default.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */

function defaulted(struct, fallback, options = {}) {
  return coerce(struct, unknown(), x => {
    const f = typeof fallback === 'function' ? fallback() : fallback;

    if (x === undefined) {
      return f;
    }

    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
      const ret = { ...x
      };
      let changed = false;

      for (const key in f) {
        if (ret[key] === undefined) {
          ret[key] = f[key];
          changed = true;
        }
      }

      if (changed) {
        return ret;
      }
    }

    return x;
  });
}
/**
 * Augment a struct to trim string inputs.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 */

function trimmed(struct) {
  return coerce(struct, string(), x => x.trim());
}

/**
 * Ensure that a string, array, map, or set is empty.
 */

function empty(struct) {
  const expected = "Expected an empty " + struct.type;
  return refine(struct, 'empty', value => {
    if (value instanceof Map || value instanceof Set) {
      const {
        size
      } = value;
      return size === 0 || expected + " but received one with a size of `" + size + "`";
    } else {
      const {
        length
      } = value;
      return length === 0 || expected + " but received one with a length of `" + length + "`";
    }
  });
}
/**
 * Ensure that a number or date is below a threshold.
 */

function max(struct, threshold, options = {}) {
  const {
    exclusive
  } = options;
  return refine(struct, 'max', value => {
    return exclusive ? value < threshold : value <= threshold || "Expected a " + struct.type + " greater than " + (exclusive ? '' : 'or equal to ') + threshold + " but received `" + value + "`";
  });
}
/**
 * Ensure that a number or date is above a threshold.
 */

function min(struct, threshold, options = {}) {
  const {
    exclusive
  } = options;
  return refine(struct, 'min', value => {
    return exclusive ? value > threshold : value >= threshold || "Expected a " + struct.type + " greater than " + (exclusive ? '' : 'or equal to ') + threshold + " but received `" + value + "`";
  });
}
/**
 * Ensure that a string matches a regular expression.
 */

function pattern(struct, regexp) {
  return refine(struct, 'pattern', value => {
    return regexp.test(value) || "Expected a " + struct.type + " matching `/" + regexp.source + "/` but received \"" + value + "\"";
  });
}
/**
 * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
 */

function size(struct, min, max = min) {
  const expected = "Expected a " + struct.type;
  const of = min === max ? "of `" + min + "`" : "between `" + min + "` and `" + max + "`";
  return refine(struct, 'size', value => {
    if (typeof value === 'number' || value instanceof Date) {
      return min <= value && value <= max || expected + " " + of + " but received `" + value + "`";
    } else if (value instanceof Map || value instanceof Set) {
      const {
        size
      } = value;
      return min <= size && size <= max || expected + " with a size " + of + " but received one with a size of `" + size + "`";
    } else {
      const {
        length
      } = value;
      return min <= length && length <= max || expected + " with a length " + of + " but received one with a length of `" + length + "`";
    }
  });
}
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 *
 * The refiner function is guaranteed to receive a value of the struct's type,
 * because the struct's existing validation will already have passed. This
 * allows you to layer additional validation on top of existing structs.
 */

function refine(struct, name, refiner) {
  return new Struct({ ...struct,

    *refiner(value, ctx) {
      yield* struct.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct, value);

      for (const failure of failures) {
        yield { ...failure,
          refinement: name
        };
      }
    }

  });
}

exports.Struct = Struct;
exports.StructError = StructError;
exports.any = any;
exports.array = array;
exports.assert = assert;
exports.assign = assign;
exports.boolean = boolean;
exports.coerce = coerce;
exports.create = create;
exports.date = date;
exports.defaulted = defaulted;
exports.define = define;
exports.deprecated = deprecated;
exports.dynamic = dynamic;
exports.empty = empty;
exports.enums = enums;
exports.func = func;
exports.instance = instance;
exports.integer = integer;
exports.intersection = intersection;
exports.is = is;
exports.lazy = lazy;
exports.literal = literal;
exports.map = map;
exports.mask = mask;
exports.max = max;
exports.min = min;
exports.never = never;
exports.nullable = nullable;
exports.number = number;
exports.object = object;
exports.omit = omit;
exports.optional = optional;
exports.partial = partial;
exports.pattern = pattern;
exports.pick = pick;
exports.record = record;
exports.refine = refine;
exports.regexp = regexp;
exports.set = set;
exports.size = size;
exports.string = string;
exports.struct = struct;
exports.trimmed = trimmed;
exports.tuple = tuple;
exports.type = type;
exports.union = union;
exports.unknown = unknown;
exports.validate = validate;


},{}],43:[function(require,module,exports){
'use strict';

// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

//
// Utilities
//

/**
 * @param {number} a The number to test.
 * @param {number} min The minimum value in the range, inclusive.
 * @param {number} max The maximum value in the range, inclusive.
 * @return {boolean} True if a >= min and a <= max.
 */
function inRange(a, min, max) {
  return min <= a && a <= max;
}

/**
 * @param {*} o
 * @return {Object}
 */
function ToDictionary(o) {
  if (o === undefined) return {};
  if (o === Object(o)) return o;
  throw TypeError('Could not convert argument to dictionary');
}

/**
 * @param {string} string Input string of UTF-16 code units.
 * @return {!Array.<number>} Code points.
 */
function stringToCodePoints(string) {
  // https://heycam.github.io/webidl/#dfn-obtain-unicode

  // 1. Let S be the DOMString value.
  var s = String(string);

  // 2. Let n be the length of S.
  var n = s.length;

  // 3. Initialize i to 0.
  var i = 0;

  // 4. Initialize U to be an empty sequence of Unicode characters.
  var u = [];

  // 5. While i < n:
  while (i < n) {

    // 1. Let c be the code unit in S at index i.
    var c = s.charCodeAt(i);

    // 2. Depending on the value of c:

    // c < 0xD800 or c > 0xDFFF
    if (c < 0xD800 || c > 0xDFFF) {
      // Append to U the Unicode character with code point c.
      u.push(c);
    }

    // 0xDC00 ≤ c ≤ 0xDFFF
    else if (0xDC00 <= c && c <= 0xDFFF) {
      // Append to U a U+FFFD REPLACEMENT CHARACTER.
      u.push(0xFFFD);
    }

    // 0xD800 ≤ c ≤ 0xDBFF
    else if (0xD800 <= c && c <= 0xDBFF) {
      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
      // CHARACTER.
      if (i === n - 1) {
        u.push(0xFFFD);
      }
      // 2. Otherwise, i < n−1:
      else {
        // 1. Let d be the code unit in S at index i+1.
        var d = string.charCodeAt(i + 1);

        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:
        if (0xDC00 <= d && d <= 0xDFFF) {
          // 1. Let a be c & 0x3FF.
          var a = c & 0x3FF;

          // 2. Let b be d & 0x3FF.
          var b = d & 0x3FF;

          // 3. Append to U the Unicode character with code point
          // 2^16+2^10*a+b.
          u.push(0x10000 + (a << 10) + b);

          // 4. Set i to i+1.
          i += 1;
        }

        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
        // U+FFFD REPLACEMENT CHARACTER.
        else  {
          u.push(0xFFFD);
        }
      }
    }

    // 3. Set i to i+1.
    i += 1;
  }

  // 6. Return U.
  return u;
}

/**
 * @param {!Array.<number>} code_points Array of code points.
 * @return {string} string String of UTF-16 code units.
 */
function codePointsToString(code_points) {
  var s = '';
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 0xFFFF) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 0x10000;
      s += String.fromCharCode((cp >> 10) + 0xD800,
                               (cp & 0x3FF) + 0xDC00);
    }
  }
  return s;
}


//
// Implementation of Encoding specification
// https://encoding.spec.whatwg.org/
//

//
// 3. Terminology
//

/**
 * End-of-stream is a special token that signifies no more tokens
 * are in the stream.
 * @const
 */ var end_of_stream = -1;

/**
 * A stream represents an ordered sequence of tokens.
 *
 * @constructor
 * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
 * stream.
 */
function Stream(tokens) {
  /** @type {!Array.<number>} */
  this.tokens = [].slice.call(tokens);
}

Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },

  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
   read: function() {
    if (!this.tokens.length)
      return end_of_stream;
     return this.tokens.shift();
   },

  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },

  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};

//
// 4. Encodings
//

// 4.1 Encoders and decoders

/** @const */
var finished = -1;

/**
 * @param {boolean} fatal If true, decoding errors raise an exception.
 * @param {number=} opt_code_point Override the standard fallback code point.
 * @return {number} The code point to insert on a decoding error.
 */
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError('Decoder error');
  return opt_code_point || 0xFFFD;
}

//
// 7. API
//

/** @const */ var DEFAULT_ENCODING = 'utf-8';

// 7.1 Interface TextDecoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextDecoder(encoding, options) {
  if (!(this instanceof TextDecoder)) {
    return new TextDecoder(encoding, options);
  }
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {boolean} */
  this._BOMseen = false;
  /** @private @type {?Decoder} */
  this._decoder = null;
  /** @private @type {boolean} */
  this._fatal = Boolean(options['fatal']);
  /** @private @type {boolean} */
  this._ignoreBOM = Boolean(options['ignoreBOM']);

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
  Object.defineProperty(this, 'fatal', {value: this._fatal});
  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});
}

TextDecoder.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input &&
               input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer,
                             input.byteOffset,
                             input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }

    options = ToDictionary(options);

    if (!this._streaming) {
      this._decoder = new UTF8Decoder({fatal: this._fatal});
      this._BOMseen = false;
    }
    this._streaming = Boolean(options['stream']);

    var input_stream = new Stream(bytes);

    var code_points = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    if (code_points.length) {
      // If encoding is one of utf-8, utf-16be, and utf-16le, and
      // ignore BOM flag and BOM seen flag are unset, run these
      // subsubsteps:
      if (['utf-8'].indexOf(this.encoding) !== -1 &&
          !this._ignoreBOM && !this._BOMseen) {
        // If token is U+FEFF, set BOM seen flag.
        if (code_points[0] === 0xFEFF) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          // Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to output.
          this._BOMseen = true;
        }
      }
    }

    return codePointsToString(code_points);
  }
};

// 7.2 Interface TextEncoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextEncoder(encoding, options) {
  if (!(this instanceof TextEncoder))
    return new TextEncoder(encoding, options);
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {?Encoder} */
  this._encoder = null;
  /** @private @type {{fatal: boolean}} */
  this._options = {fatal: Boolean(options['fatal'])};

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
}

TextEncoder.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : '';
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
    // so streaming is not necessary.
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options['stream']);

    var bytes = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    /** @type {?(number|!Array.<number>)} */
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
      else
        bytes.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
        else
          bytes.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes);
  }
};

//
// 8. The encoding
//

// 8.1 utf-8

/**
 * @constructor
 * @implements {Decoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Decoder(options) {
  var fatal = options.fatal;

  // utf-8's decoder's has an associated utf-8 code point, utf-8
  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
  // lower boundary (initially 0x80), and a utf-8 upper boundary
  // (initially 0xBF).
  var /** @type {number} */ utf8_code_point = 0,
      /** @type {number} */ utf8_bytes_seen = 0,
      /** @type {number} */ utf8_bytes_needed = 0,
      /** @type {number} */ utf8_lower_boundary = 0x80,
      /** @type {number} */ utf8_upper_boundary = 0xBF;

  /**
   * @param {Stream} stream The stream of bytes being decoded.
   * @param {number} bite The next byte read from the stream.
   * @return {?(number|!Array.<number>)} The next code point(s)
   *     decoded, or null if not enough data exists in the input
   *     stream to decode a complete code point.
   */
  this.handler = function(stream, bite) {
    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
    // set utf-8 bytes needed to 0 and return error.
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }

    // 2. If byte is end-of-stream, return finished.
    if (bite === end_of_stream)
      return finished;

    // 3. If utf-8 bytes needed is 0, based on byte:
    if (utf8_bytes_needed === 0) {

      // 0x00 to 0x7F
      if (inRange(bite, 0x00, 0x7F)) {
        // Return a code point whose value is byte.
        return bite;
      }

      // 0xC2 to 0xDF
      if (inRange(bite, 0xC2, 0xDF)) {
        // Set utf-8 bytes needed to 1 and utf-8 code point to byte
        // − 0xC0.
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 0xC0;
      }

      // 0xE0 to 0xEF
      else if (inRange(bite, 0xE0, 0xEF)) {
        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
        if (bite === 0xE0)
          utf8_lower_boundary = 0xA0;
        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
        if (bite === 0xED)
          utf8_upper_boundary = 0x9F;
        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
        // byte − 0xE0.
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 0xE0;
      }

      // 0xF0 to 0xF4
      else if (inRange(bite, 0xF0, 0xF4)) {
        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
        if (bite === 0xF0)
          utf8_lower_boundary = 0x90;
        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
        if (bite === 0xF4)
          utf8_upper_boundary = 0x8F;
        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
        // byte − 0xF0.
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 0xF0;
      }

      // Otherwise
      else {
        // Return error.
        return decoderError(fatal);
      }

      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
      // point to utf-8 code point << (6 × utf-8 bytes needed) and
      // return continue.
      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
      return null;
    }

    // 4. If byte is not in the range utf-8 lower boundary to utf-8
    // upper boundary, run these substeps:
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
      // utf-8 upper boundary to 0xBF.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 2. Prepend byte to stream.
      stream.prepend(bite);

      // 3. Return error.
      return decoderError(fatal);
    }

    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
    // to 0xBF.
    utf8_lower_boundary = 0x80;
    utf8_upper_boundary = 0xBF;

    // 6. Increase utf-8 bytes seen by one and set utf-8 code point
    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes
    // needed − utf-8 bytes seen)).
    utf8_bytes_seen += 1;
    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));

    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
    // continue.
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;

    // 8. Let code point be utf-8 code point.
    var code_point = utf8_code_point;

    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
    // seen to 0.
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

    // 10. Return a code point whose value is code point.
    return code_point;
  };
}

/**
 * @constructor
 * @implements {Encoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Encoder(options) {
  var fatal = options.fatal;
  /**
   * @param {Stream} stream Input stream.
   * @param {number} code_point Next code point read from the stream.
   * @return {(number|!Array.<number>)} Byte(s) to emit.
   */
  this.handler = function(stream, code_point) {
    // 1. If code point is end-of-stream, return finished.
    if (code_point === end_of_stream)
      return finished;

    // 2. If code point is in the range U+0000 to U+007F, return a
    // byte whose value is code point.
    if (inRange(code_point, 0x0000, 0x007f))
      return code_point;

    // 3. Set count and offset based on the range code point is in:
    var count, offset;
    // U+0080 to U+07FF:    1 and 0xC0
    if (inRange(code_point, 0x0080, 0x07FF)) {
      count = 1;
      offset = 0xC0;
    }
    // U+0800 to U+FFFF:    2 and 0xE0
    else if (inRange(code_point, 0x0800, 0xFFFF)) {
      count = 2;
      offset = 0xE0;
    }
    // U+10000 to U+10FFFF: 3 and 0xF0
    else if (inRange(code_point, 0x10000, 0x10FFFF)) {
      count = 3;
      offset = 0xF0;
    }

    // 4.Let bytes be a byte sequence whose first byte is (code
    // point >> (6 × count)) + offset.
    var bytes = [(code_point >> (6 * count)) + offset];

    // 5. Run these substeps while count is greater than 0:
    while (count > 0) {

      // 1. Set temp to code point >> (6 × (count − 1)).
      var temp = code_point >> (6 * (count - 1));

      // 2. Append to bytes 0x80 | (temp & 0x3F).
      bytes.push(0x80 | (temp & 0x3F));

      // 3. Decrease count by one.
      count -= 1;
    }

    // 6. Return bytes bytes, in order.
    return bytes;
  };
}

exports.TextEncoder = TextEncoder;
exports.TextDecoder = TextDecoder;
},{}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":46,"./parse.js":47,"./stringify.js":51,"./v1.js":52,"./v3.js":53,"./v4.js":55,"./v5.js":56,"./validate.js":57,"./version.js":58}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":57}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":57}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":49,"./stringify.js":51}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":45,"./v35.js":54}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":47,"./stringify.js":51}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":49,"./stringify.js":51}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":50,"./v35.js":54}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":48}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":57}],59:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],60:[function(require,module,exports){

},{}],61:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":59,"buffer":61,"ieee754":62}],62:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}]},{},[2]);
